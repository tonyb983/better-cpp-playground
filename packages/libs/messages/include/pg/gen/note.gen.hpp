// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_NOTE_PG_GEN_H_
#define FLATBUFFERS_GENERATED_NOTE_PG_GEN_H_

#pragma clang system_header

#include <array>

#include "flatbuffers/flatbuffers.h"

namespace pg {
namespace gen {

    struct Timestamp;
    struct TimestampBuilder;
    struct TimestampT;

    struct ResponseError;
    struct ResponseErrorBuilder;
    struct ResponseErrorT;

    struct ReplaceTextPair;
    struct ReplaceTextPairBuilder;
    struct ReplaceTextPairT;

    struct AppendTextOp;
    struct AppendTextOpBuilder;
    struct AppendTextOpT;

    struct InsertTextOp;
    struct InsertTextOpBuilder;
    struct InsertTextOpT;

    struct PrependTextOp;
    struct PrependTextOpBuilder;
    struct PrependTextOpT;

    struct RemoveTextRangeOp;
    struct RemoveTextRangeOpBuilder;
    struct RemoveTextRangeOpT;

    struct ReplaceTextOp;
    struct ReplaceTextOpBuilder;
    struct ReplaceTextOpT;

    struct ReplaceTextMultipleOp;
    struct ReplaceTextMultipleOpBuilder;
    struct ReplaceTextMultipleOpT;

    struct RemoveTextOp;
    struct RemoveTextOpBuilder;
    struct RemoveTextOpT;

    struct RemoveTextMultipleOp;
    struct RemoveTextMultipleOpBuilder;
    struct RemoveTextMultipleOpT;

    struct TextModificationKind;
    struct TextModificationKindBuilder;
    struct TextModificationKindT;

    struct TextMatchesQuery;
    struct TextMatchesQueryBuilder;
    struct TextMatchesQueryT;

    struct TextContainsQuery;
    struct TextContainsQueryBuilder;
    struct TextContainsQueryT;

    struct TextStartsWithQuery;
    struct TextStartsWithQueryBuilder;
    struct TextStartsWithQueryT;

    struct TextEndsWithQuery;
    struct TextEndsWithQueryBuilder;
    struct TextEndsWithQueryT;

    struct TextSearchKind;
    struct TextSearchKindBuilder;
    struct TextSearchKindT;

    struct BeforeDateQuery;
    struct BeforeDateQueryBuilder;
    struct BeforeDateQueryT;

    struct AfterDateQuery;
    struct AfterDateQueryBuilder;
    struct AfterDateQueryT;

    struct InDateRangeQuery;
    struct InDateRangeQueryBuilder;
    struct InDateRangeQueryT;

    struct NotInDateRangeQuery;
    struct NotInDateRangeQueryBuilder;
    struct NotInDateRangeQueryT;

    struct DateSearchKind;
    struct DateSearchKindBuilder;
    struct DateSearchKindT;

    struct NoteTitleSearch;
    struct NoteTitleSearchBuilder;
    struct NoteTitleSearchT;

    struct NoteContentSearch;
    struct NoteContentSearchBuilder;
    struct NoteContentSearchT;

    struct NoteTagSearch;
    struct NoteTagSearchBuilder;
    struct NoteTagSearchT;

    struct NoteCreatedSearch;
    struct NoteCreatedSearchBuilder;
    struct NoteCreatedSearchT;

    struct NoteUpdatedSearch;
    struct NoteUpdatedSearchBuilder;
    struct NoteUpdatedSearchT;

    struct SearchNoteData;
    struct SearchNoteDataBuilder;
    struct SearchNoteDataT;

    struct SearchNoteRequest;
    struct SearchNoteRequestBuilder;
    struct SearchNoteRequestT;

    struct SearchNoteResponse;
    struct SearchNoteResponseBuilder;
    struct SearchNoteResponseT;

    struct CreateNoteData;
    struct CreateNoteDataBuilder;
    struct CreateNoteDataT;

    struct CreateNoteRequest;
    struct CreateNoteRequestBuilder;
    struct CreateNoteRequestT;

    struct CreateNoteResponse;
    struct CreateNoteResponseBuilder;
    struct CreateNoteResponseT;

    struct UpdateNoteData;
    struct UpdateNoteDataBuilder;
    struct UpdateNoteDataT;

    struct UpdateNoteRequest;
    struct UpdateNoteRequestBuilder;
    struct UpdateNoteRequestT;

    struct UpdateNoteResponse;
    struct UpdateNoteResponseBuilder;
    struct UpdateNoteResponseT;

    struct UpdateNotesRequest;
    struct UpdateNotesRequestBuilder;
    struct UpdateNotesRequestT;

    struct UpdateNotesResponse;
    struct UpdateNotesResponseBuilder;
    struct UpdateNotesResponseT;

    struct DeleteNoteData;
    struct DeleteNoteDataBuilder;
    struct DeleteNoteDataT;

    struct DeleteNoteRequest;
    struct DeleteNoteRequestBuilder;
    struct DeleteNoteRequestT;

    struct Boolean;
    struct BooleanBuilder;
    struct BooleanT;

    struct DeleteNoteResponse;
    struct DeleteNoteResponseBuilder;
    struct DeleteNoteResponseT;

    struct DeleteNotesRequest;
    struct DeleteNotesRequestBuilder;
    struct DeleteNotesRequestT;

    struct DeleteNotesResponse;
    struct DeleteNotesResponseBuilder;
    struct DeleteNotesResponseT;

    struct ListNotesRequest;
    struct ListNotesRequestBuilder;
    struct ListNotesRequestT;

    struct ListNotesResponse;
    struct ListNotesResponseBuilder;
    struct ListNotesResponseT;

    struct GetNoteRequest;
    struct GetNoteRequestBuilder;
    struct GetNoteRequestT;

    struct GetNoteResponse;
    struct GetNoteResponseBuilder;
    struct GetNoteResponseT;

    struct NoteObject;
    struct NoteObjectBuilder;
    struct NoteObjectT;

    struct NoteStorage;
    struct NoteStorageBuilder;
    struct NoteStorageT;

    bool operator==(const TimestampT& lhs, const TimestampT& rhs);
    bool operator!=(const TimestampT& lhs, const TimestampT& rhs);
    bool operator==(const ResponseErrorT& lhs, const ResponseErrorT& rhs);
    bool operator!=(const ResponseErrorT& lhs, const ResponseErrorT& rhs);
    bool operator==(const ReplaceTextPairT& lhs, const ReplaceTextPairT& rhs);
    bool operator!=(const ReplaceTextPairT& lhs, const ReplaceTextPairT& rhs);
    bool operator==(const AppendTextOpT& lhs, const AppendTextOpT& rhs);
    bool operator!=(const AppendTextOpT& lhs, const AppendTextOpT& rhs);
    bool operator==(const InsertTextOpT& lhs, const InsertTextOpT& rhs);
    bool operator!=(const InsertTextOpT& lhs, const InsertTextOpT& rhs);
    bool operator==(const PrependTextOpT& lhs, const PrependTextOpT& rhs);
    bool operator!=(const PrependTextOpT& lhs, const PrependTextOpT& rhs);
    bool operator==(const RemoveTextRangeOpT& lhs, const RemoveTextRangeOpT& rhs);
    bool operator!=(const RemoveTextRangeOpT& lhs, const RemoveTextRangeOpT& rhs);
    bool operator==(const ReplaceTextOpT& lhs, const ReplaceTextOpT& rhs);
    bool operator!=(const ReplaceTextOpT& lhs, const ReplaceTextOpT& rhs);
    bool operator==(const ReplaceTextMultipleOpT& lhs, const ReplaceTextMultipleOpT& rhs);
    bool operator!=(const ReplaceTextMultipleOpT& lhs, const ReplaceTextMultipleOpT& rhs);
    bool operator==(const RemoveTextOpT& lhs, const RemoveTextOpT& rhs);
    bool operator!=(const RemoveTextOpT& lhs, const RemoveTextOpT& rhs);
    bool operator==(const RemoveTextMultipleOpT& lhs, const RemoveTextMultipleOpT& rhs);
    bool operator!=(const RemoveTextMultipleOpT& lhs, const RemoveTextMultipleOpT& rhs);
    bool operator==(const TextModificationKindT& lhs, const TextModificationKindT& rhs);
    bool operator!=(const TextModificationKindT& lhs, const TextModificationKindT& rhs);
    bool operator==(const TextMatchesQueryT& lhs, const TextMatchesQueryT& rhs);
    bool operator!=(const TextMatchesQueryT& lhs, const TextMatchesQueryT& rhs);
    bool operator==(const TextContainsQueryT& lhs, const TextContainsQueryT& rhs);
    bool operator!=(const TextContainsQueryT& lhs, const TextContainsQueryT& rhs);
    bool operator==(const TextStartsWithQueryT& lhs, const TextStartsWithQueryT& rhs);
    bool operator!=(const TextStartsWithQueryT& lhs, const TextStartsWithQueryT& rhs);
    bool operator==(const TextEndsWithQueryT& lhs, const TextEndsWithQueryT& rhs);
    bool operator!=(const TextEndsWithQueryT& lhs, const TextEndsWithQueryT& rhs);
    bool operator==(const TextSearchKindT& lhs, const TextSearchKindT& rhs);
    bool operator!=(const TextSearchKindT& lhs, const TextSearchKindT& rhs);
    bool operator==(const BeforeDateQueryT& lhs, const BeforeDateQueryT& rhs);
    bool operator!=(const BeforeDateQueryT& lhs, const BeforeDateQueryT& rhs);
    bool operator==(const AfterDateQueryT& lhs, const AfterDateQueryT& rhs);
    bool operator!=(const AfterDateQueryT& lhs, const AfterDateQueryT& rhs);
    bool operator==(const InDateRangeQueryT& lhs, const InDateRangeQueryT& rhs);
    bool operator!=(const InDateRangeQueryT& lhs, const InDateRangeQueryT& rhs);
    bool operator==(const NotInDateRangeQueryT& lhs, const NotInDateRangeQueryT& rhs);
    bool operator!=(const NotInDateRangeQueryT& lhs, const NotInDateRangeQueryT& rhs);
    bool operator==(const DateSearchKindT& lhs, const DateSearchKindT& rhs);
    bool operator!=(const DateSearchKindT& lhs, const DateSearchKindT& rhs);
    bool operator==(const NoteTitleSearchT& lhs, const NoteTitleSearchT& rhs);
    bool operator!=(const NoteTitleSearchT& lhs, const NoteTitleSearchT& rhs);
    bool operator==(const NoteContentSearchT& lhs, const NoteContentSearchT& rhs);
    bool operator!=(const NoteContentSearchT& lhs, const NoteContentSearchT& rhs);
    bool operator==(const NoteTagSearchT& lhs, const NoteTagSearchT& rhs);
    bool operator!=(const NoteTagSearchT& lhs, const NoteTagSearchT& rhs);
    bool operator==(const NoteCreatedSearchT& lhs, const NoteCreatedSearchT& rhs);
    bool operator!=(const NoteCreatedSearchT& lhs, const NoteCreatedSearchT& rhs);
    bool operator==(const NoteUpdatedSearchT& lhs, const NoteUpdatedSearchT& rhs);
    bool operator!=(const NoteUpdatedSearchT& lhs, const NoteUpdatedSearchT& rhs);
    bool operator==(const SearchNoteDataT& lhs, const SearchNoteDataT& rhs);
    bool operator!=(const SearchNoteDataT& lhs, const SearchNoteDataT& rhs);
    bool operator==(const SearchNoteRequestT& lhs, const SearchNoteRequestT& rhs);
    bool operator!=(const SearchNoteRequestT& lhs, const SearchNoteRequestT& rhs);
    bool operator==(const SearchNoteResponseT& lhs, const SearchNoteResponseT& rhs);
    bool operator!=(const SearchNoteResponseT& lhs, const SearchNoteResponseT& rhs);
    bool operator==(const CreateNoteDataT& lhs, const CreateNoteDataT& rhs);
    bool operator!=(const CreateNoteDataT& lhs, const CreateNoteDataT& rhs);
    bool operator==(const CreateNoteRequestT& lhs, const CreateNoteRequestT& rhs);
    bool operator!=(const CreateNoteRequestT& lhs, const CreateNoteRequestT& rhs);
    bool operator==(const CreateNoteResponseT& lhs, const CreateNoteResponseT& rhs);
    bool operator!=(const CreateNoteResponseT& lhs, const CreateNoteResponseT& rhs);
    bool operator==(const UpdateNoteDataT& lhs, const UpdateNoteDataT& rhs);
    bool operator!=(const UpdateNoteDataT& lhs, const UpdateNoteDataT& rhs);
    bool operator==(const UpdateNoteRequestT& lhs, const UpdateNoteRequestT& rhs);
    bool operator!=(const UpdateNoteRequestT& lhs, const UpdateNoteRequestT& rhs);
    bool operator==(const UpdateNoteResponseT& lhs, const UpdateNoteResponseT& rhs);
    bool operator!=(const UpdateNoteResponseT& lhs, const UpdateNoteResponseT& rhs);
    bool operator==(const UpdateNotesRequestT& lhs, const UpdateNotesRequestT& rhs);
    bool operator!=(const UpdateNotesRequestT& lhs, const UpdateNotesRequestT& rhs);
    bool operator==(const UpdateNotesResponseT& lhs, const UpdateNotesResponseT& rhs);
    bool operator!=(const UpdateNotesResponseT& lhs, const UpdateNotesResponseT& rhs);
    bool operator==(const DeleteNoteDataT& lhs, const DeleteNoteDataT& rhs);
    bool operator!=(const DeleteNoteDataT& lhs, const DeleteNoteDataT& rhs);
    bool operator==(const DeleteNoteRequestT& lhs, const DeleteNoteRequestT& rhs);
    bool operator!=(const DeleteNoteRequestT& lhs, const DeleteNoteRequestT& rhs);
    bool operator==(const BooleanT& lhs, const BooleanT& rhs);
    bool operator!=(const BooleanT& lhs, const BooleanT& rhs);
    bool operator==(const DeleteNoteResponseT& lhs, const DeleteNoteResponseT& rhs);
    bool operator!=(const DeleteNoteResponseT& lhs, const DeleteNoteResponseT& rhs);
    bool operator==(const DeleteNotesRequestT& lhs, const DeleteNotesRequestT& rhs);
    bool operator!=(const DeleteNotesRequestT& lhs, const DeleteNotesRequestT& rhs);
    bool operator==(const DeleteNotesResponseT& lhs, const DeleteNotesResponseT& rhs);
    bool operator!=(const DeleteNotesResponseT& lhs, const DeleteNotesResponseT& rhs);
    bool operator==(const ListNotesRequestT& lhs, const ListNotesRequestT& rhs);
    bool operator!=(const ListNotesRequestT& lhs, const ListNotesRequestT& rhs);
    bool operator==(const ListNotesResponseT& lhs, const ListNotesResponseT& rhs);
    bool operator!=(const ListNotesResponseT& lhs, const ListNotesResponseT& rhs);
    bool operator==(const GetNoteRequestT& lhs, const GetNoteRequestT& rhs);
    bool operator!=(const GetNoteRequestT& lhs, const GetNoteRequestT& rhs);
    bool operator==(const GetNoteResponseT& lhs, const GetNoteResponseT& rhs);
    bool operator!=(const GetNoteResponseT& lhs, const GetNoteResponseT& rhs);
    bool operator==(const NoteObjectT& lhs, const NoteObjectT& rhs);
    bool operator!=(const NoteObjectT& lhs, const NoteObjectT& rhs);
    bool operator==(const NoteStorageT& lhs, const NoteStorageT& rhs);
    bool operator!=(const NoteStorageT& lhs, const NoteStorageT& rhs);

    inline const flatbuffers::TypeTable* TimestampTypeTable();

    inline const flatbuffers::TypeTable* ResponseErrorTypeTable();

    inline const flatbuffers::TypeTable* ReplaceTextPairTypeTable();

    inline const flatbuffers::TypeTable* AppendTextOpTypeTable();

    inline const flatbuffers::TypeTable* InsertTextOpTypeTable();

    inline const flatbuffers::TypeTable* PrependTextOpTypeTable();

    inline const flatbuffers::TypeTable* RemoveTextRangeOpTypeTable();

    inline const flatbuffers::TypeTable* ReplaceTextOpTypeTable();

    inline const flatbuffers::TypeTable* ReplaceTextMultipleOpTypeTable();

    inline const flatbuffers::TypeTable* RemoveTextOpTypeTable();

    inline const flatbuffers::TypeTable* RemoveTextMultipleOpTypeTable();

    inline const flatbuffers::TypeTable* TextModificationKindTypeTable();

    inline const flatbuffers::TypeTable* TextMatchesQueryTypeTable();

    inline const flatbuffers::TypeTable* TextContainsQueryTypeTable();

    inline const flatbuffers::TypeTable* TextStartsWithQueryTypeTable();

    inline const flatbuffers::TypeTable* TextEndsWithQueryTypeTable();

    inline const flatbuffers::TypeTable* TextSearchKindTypeTable();

    inline const flatbuffers::TypeTable* BeforeDateQueryTypeTable();

    inline const flatbuffers::TypeTable* AfterDateQueryTypeTable();

    inline const flatbuffers::TypeTable* InDateRangeQueryTypeTable();

    inline const flatbuffers::TypeTable* NotInDateRangeQueryTypeTable();

    inline const flatbuffers::TypeTable* DateSearchKindTypeTable();

    inline const flatbuffers::TypeTable* NoteTitleSearchTypeTable();

    inline const flatbuffers::TypeTable* NoteContentSearchTypeTable();

    inline const flatbuffers::TypeTable* NoteTagSearchTypeTable();

    inline const flatbuffers::TypeTable* NoteCreatedSearchTypeTable();

    inline const flatbuffers::TypeTable* NoteUpdatedSearchTypeTable();

    inline const flatbuffers::TypeTable* SearchNoteDataTypeTable();

    inline const flatbuffers::TypeTable* SearchNoteRequestTypeTable();

    inline const flatbuffers::TypeTable* SearchNoteResponseTypeTable();

    inline const flatbuffers::TypeTable* CreateNoteDataTypeTable();

    inline const flatbuffers::TypeTable* CreateNoteRequestTypeTable();

    inline const flatbuffers::TypeTable* CreateNoteResponseTypeTable();

    inline const flatbuffers::TypeTable* UpdateNoteDataTypeTable();

    inline const flatbuffers::TypeTable* UpdateNoteRequestTypeTable();

    inline const flatbuffers::TypeTable* UpdateNoteResponseTypeTable();

    inline const flatbuffers::TypeTable* UpdateNotesRequestTypeTable();

    inline const flatbuffers::TypeTable* UpdateNotesResponseTypeTable();

    inline const flatbuffers::TypeTable* DeleteNoteDataTypeTable();

    inline const flatbuffers::TypeTable* DeleteNoteRequestTypeTable();

    inline const flatbuffers::TypeTable* BooleanTypeTable();

    inline const flatbuffers::TypeTable* DeleteNoteResponseTypeTable();

    inline const flatbuffers::TypeTable* DeleteNotesRequestTypeTable();

    inline const flatbuffers::TypeTable* DeleteNotesResponseTypeTable();

    inline const flatbuffers::TypeTable* ListNotesRequestTypeTable();

    inline const flatbuffers::TypeTable* ListNotesResponseTypeTable();

    inline const flatbuffers::TypeTable* GetNoteRequestTypeTable();

    inline const flatbuffers::TypeTable* GetNoteResponseTypeTable();

    inline const flatbuffers::TypeTable* NoteObjectTypeTable();

    inline const flatbuffers::TypeTable* NoteStorageTypeTable();

    namespace TextModificationKind_ {

        enum class KindUnion : uint8_t {
            NONE = 0,
            pg_gen_AppendTextOp = 1,
            pg_gen_InsertTextOp = 2,
            pg_gen_PrependTextOp = 3,
            pg_gen_RemoveTextRangeOp = 4,
            pg_gen_ReplaceTextOp = 5,
            pg_gen_ReplaceTextMultipleOp = 6,
            pg_gen_RemoveTextOp = 7,
            pg_gen_RemoveTextMultipleOp = 8,
            MIN = NONE,
            MAX = pg_gen_RemoveTextMultipleOp
        };

        inline const KindUnion (&EnumValuesKindUnion())[9] {
            static const KindUnion values[] = { KindUnion::NONE,
                                                KindUnion::pg_gen_AppendTextOp,
                                                KindUnion::pg_gen_InsertTextOp,
                                                KindUnion::pg_gen_PrependTextOp,
                                                KindUnion::pg_gen_RemoveTextRangeOp,
                                                KindUnion::pg_gen_ReplaceTextOp,
                                                KindUnion::pg_gen_ReplaceTextMultipleOp,
                                                KindUnion::pg_gen_RemoveTextOp,
                                                KindUnion::pg_gen_RemoveTextMultipleOp };
            return values;
        }

        inline const char* const* EnumNamesKindUnion() {
            static const char* const names[10] = { "NONE",
                                                   "pg_gen_AppendTextOp",
                                                   "pg_gen_InsertTextOp",
                                                   "pg_gen_PrependTextOp",
                                                   "pg_gen_RemoveTextRangeOp",
                                                   "pg_gen_ReplaceTextOp",
                                                   "pg_gen_ReplaceTextMultipleOp",
                                                   "pg_gen_RemoveTextOp",
                                                   "pg_gen_RemoveTextMultipleOp",
                                                   nullptr };
            return names;
        }

        inline const char* EnumNameKindUnion(KindUnion e) {
            if (flatbuffers::IsOutRange(e, KindUnion::NONE, KindUnion::pg_gen_RemoveTextMultipleOp))
                return "";
            const size_t index = static_cast<size_t>(e);
            return EnumNamesKindUnion()[index];
        }

        template<typename T>
        struct KindUnionTraits {
            static const KindUnion enum_value = KindUnion::NONE;
        };

        template<>
        struct KindUnionTraits<pg::gen::AppendTextOp> {
            static const KindUnion enum_value = KindUnion::pg_gen_AppendTextOp;
        };

        template<>
        struct KindUnionTraits<pg::gen::InsertTextOp> {
            static const KindUnion enum_value = KindUnion::pg_gen_InsertTextOp;
        };

        template<>
        struct KindUnionTraits<pg::gen::PrependTextOp> {
            static const KindUnion enum_value = KindUnion::pg_gen_PrependTextOp;
        };

        template<>
        struct KindUnionTraits<pg::gen::RemoveTextRangeOp> {
            static const KindUnion enum_value = KindUnion::pg_gen_RemoveTextRangeOp;
        };

        template<>
        struct KindUnionTraits<pg::gen::ReplaceTextOp> {
            static const KindUnion enum_value = KindUnion::pg_gen_ReplaceTextOp;
        };

        template<>
        struct KindUnionTraits<pg::gen::ReplaceTextMultipleOp> {
            static const KindUnion enum_value = KindUnion::pg_gen_ReplaceTextMultipleOp;
        };

        template<>
        struct KindUnionTraits<pg::gen::RemoveTextOp> {
            static const KindUnion enum_value = KindUnion::pg_gen_RemoveTextOp;
        };

        template<>
        struct KindUnionTraits<pg::gen::RemoveTextMultipleOp> {
            static const KindUnion enum_value = KindUnion::pg_gen_RemoveTextMultipleOp;
        };

        struct KindUnionUnion {
            KindUnion type;
            void* value;

            KindUnionUnion() : type(KindUnion::NONE), value(nullptr) {}
            KindUnionUnion(KindUnionUnion&& u) FLATBUFFERS_NOEXCEPT: type(KindUnion::NONE), value(nullptr) {
                std::swap(type, u.type);
                std::swap(value, u.value);
            }
            KindUnionUnion(const KindUnionUnion&);
            KindUnionUnion& operator=(const KindUnionUnion& u) {
                KindUnionUnion t(u);
                std::swap(type, t.type);
                std::swap(value, t.value);
                return *this;
            }
            KindUnionUnion& operator=(KindUnionUnion&& u) FLATBUFFERS_NOEXCEPT {
                std::swap(type, u.type);
                std::swap(value, u.value);
                return *this;
            }
            ~KindUnionUnion() {
                Reset();
            }

            void Reset();

#ifndef FLATBUFFERS_CPP98_STL
            template<typename T>
            void Set(T&& val) {
                using RT = typename std::remove_reference<T>::type;
                Reset();
                type = KindUnionTraits<typename RT::TableType>::enum_value;
                if (type != KindUnion::NONE) {
                    value = new RT(std::forward<T>(val));
                }
            }
#endif  // FLATBUFFERS_CPP98_STL

            static void* UnPack(const void* obj, KindUnion type, const flatbuffers::resolver_function_t* resolver);
            flatbuffers::Offset<void> Pack(
                flatbuffers::FlatBufferBuilder& _fbb,
                const flatbuffers::rehasher_function_t* _rehasher = nullptr) const;

            pg::gen::AppendTextOpT* Aspg_gen_AppendTextOp() {
                return type == KindUnion::pg_gen_AppendTextOp ? reinterpret_cast<pg::gen::AppendTextOpT*>(value)
                                                              : nullptr;
            }
            const pg::gen::AppendTextOpT* Aspg_gen_AppendTextOp() const {
                return type == KindUnion::pg_gen_AppendTextOp ? reinterpret_cast<const pg::gen::AppendTextOpT*>(value)
                                                              : nullptr;
            }
            pg::gen::InsertTextOpT* Aspg_gen_InsertTextOp() {
                return type == KindUnion::pg_gen_InsertTextOp ? reinterpret_cast<pg::gen::InsertTextOpT*>(value)
                                                              : nullptr;
            }
            const pg::gen::InsertTextOpT* Aspg_gen_InsertTextOp() const {
                return type == KindUnion::pg_gen_InsertTextOp ? reinterpret_cast<const pg::gen::InsertTextOpT*>(value)
                                                              : nullptr;
            }
            pg::gen::PrependTextOpT* Aspg_gen_PrependTextOp() {
                return type == KindUnion::pg_gen_PrependTextOp ? reinterpret_cast<pg::gen::PrependTextOpT*>(value)
                                                               : nullptr;
            }
            const pg::gen::PrependTextOpT* Aspg_gen_PrependTextOp() const {
                return type == KindUnion::pg_gen_PrependTextOp ? reinterpret_cast<const pg::gen::PrependTextOpT*>(value)
                                                               : nullptr;
            }
            pg::gen::RemoveTextRangeOpT* Aspg_gen_RemoveTextRangeOp() {
                return type == KindUnion::pg_gen_RemoveTextRangeOp
                    ? reinterpret_cast<pg::gen::RemoveTextRangeOpT*>(value)
                    : nullptr;
            }
            const pg::gen::RemoveTextRangeOpT* Aspg_gen_RemoveTextRangeOp() const {
                return type == KindUnion::pg_gen_RemoveTextRangeOp
                    ? reinterpret_cast<const pg::gen::RemoveTextRangeOpT*>(value)
                    : nullptr;
            }
            pg::gen::ReplaceTextOpT* Aspg_gen_ReplaceTextOp() {
                return type == KindUnion::pg_gen_ReplaceTextOp ? reinterpret_cast<pg::gen::ReplaceTextOpT*>(value)
                                                               : nullptr;
            }
            const pg::gen::ReplaceTextOpT* Aspg_gen_ReplaceTextOp() const {
                return type == KindUnion::pg_gen_ReplaceTextOp ? reinterpret_cast<const pg::gen::ReplaceTextOpT*>(value)
                                                               : nullptr;
            }
            pg::gen::ReplaceTextMultipleOpT* Aspg_gen_ReplaceTextMultipleOp() {
                return type == KindUnion::pg_gen_ReplaceTextMultipleOp
                    ? reinterpret_cast<pg::gen::ReplaceTextMultipleOpT*>(value)
                    : nullptr;
            }
            const pg::gen::ReplaceTextMultipleOpT* Aspg_gen_ReplaceTextMultipleOp() const {
                return type == KindUnion::pg_gen_ReplaceTextMultipleOp
                    ? reinterpret_cast<const pg::gen::ReplaceTextMultipleOpT*>(value)
                    : nullptr;
            }
            pg::gen::RemoveTextOpT* Aspg_gen_RemoveTextOp() {
                return type == KindUnion::pg_gen_RemoveTextOp ? reinterpret_cast<pg::gen::RemoveTextOpT*>(value)
                                                              : nullptr;
            }
            const pg::gen::RemoveTextOpT* Aspg_gen_RemoveTextOp() const {
                return type == KindUnion::pg_gen_RemoveTextOp ? reinterpret_cast<const pg::gen::RemoveTextOpT*>(value)
                                                              : nullptr;
            }
            pg::gen::RemoveTextMultipleOpT* Aspg_gen_RemoveTextMultipleOp() {
                return type == KindUnion::pg_gen_RemoveTextMultipleOp
                    ? reinterpret_cast<pg::gen::RemoveTextMultipleOpT*>(value)
                    : nullptr;
            }
            const pg::gen::RemoveTextMultipleOpT* Aspg_gen_RemoveTextMultipleOp() const {
                return type == KindUnion::pg_gen_RemoveTextMultipleOp
                    ? reinterpret_cast<const pg::gen::RemoveTextMultipleOpT*>(value)
                    : nullptr;
            }
        };

        inline bool operator==(const KindUnionUnion& lhs, const KindUnionUnion& rhs) {
            if (lhs.type != rhs.type)
                return false;
            switch (lhs.type) {
                case KindUnion::NONE: {
                    return true;
                }
                case KindUnion::pg_gen_AppendTextOp: {
                    return *(reinterpret_cast<const pg::gen::AppendTextOpT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::AppendTextOpT*>(rhs.value));
                }
                case KindUnion::pg_gen_InsertTextOp: {
                    return *(reinterpret_cast<const pg::gen::InsertTextOpT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::InsertTextOpT*>(rhs.value));
                }
                case KindUnion::pg_gen_PrependTextOp: {
                    return *(reinterpret_cast<const pg::gen::PrependTextOpT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::PrependTextOpT*>(rhs.value));
                }
                case KindUnion::pg_gen_RemoveTextRangeOp: {
                    return *(reinterpret_cast<const pg::gen::RemoveTextRangeOpT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::RemoveTextRangeOpT*>(rhs.value));
                }
                case KindUnion::pg_gen_ReplaceTextOp: {
                    return *(reinterpret_cast<const pg::gen::ReplaceTextOpT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::ReplaceTextOpT*>(rhs.value));
                }
                case KindUnion::pg_gen_ReplaceTextMultipleOp: {
                    return *(reinterpret_cast<const pg::gen::ReplaceTextMultipleOpT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::ReplaceTextMultipleOpT*>(rhs.value));
                }
                case KindUnion::pg_gen_RemoveTextOp: {
                    return *(reinterpret_cast<const pg::gen::RemoveTextOpT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::RemoveTextOpT*>(rhs.value));
                }
                case KindUnion::pg_gen_RemoveTextMultipleOp: {
                    return *(reinterpret_cast<const pg::gen::RemoveTextMultipleOpT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::RemoveTextMultipleOpT*>(rhs.value));
                }
                default: {
                    return false;
                }
            }
        }

        inline bool operator!=(const KindUnionUnion& lhs, const KindUnionUnion& rhs) {
            return !(lhs == rhs);
        }

        bool VerifyKindUnion(flatbuffers::Verifier& verifier, const void* obj, KindUnion type);
        bool VerifyKindUnionVector(
            flatbuffers::Verifier& verifier,
            const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
            const flatbuffers::Vector<uint8_t>* types);

    }  // namespace TextModificationKind_

    namespace TextSearchKind_ {

        enum class KindUnion : uint8_t {
            NONE = 0,
            pg_gen_TextMatchesQuery = 1,
            pg_gen_TextContainsQuery = 2,
            pg_gen_TextStartsWithQuery = 3,
            pg_gen_TextEndsWithQuery = 4,
            MIN = NONE,
            MAX = pg_gen_TextEndsWithQuery
        };

        inline const KindUnion (&EnumValuesKindUnion())[5] {
            static const KindUnion values[] = { KindUnion::NONE,
                                                KindUnion::pg_gen_TextMatchesQuery,
                                                KindUnion::pg_gen_TextContainsQuery,
                                                KindUnion::pg_gen_TextStartsWithQuery,
                                                KindUnion::pg_gen_TextEndsWithQuery };
            return values;
        }

        inline const char* const* EnumNamesKindUnion() {
            static const char* const names[6] = { "NONE",
                                                  "pg_gen_TextMatchesQuery",
                                                  "pg_gen_TextContainsQuery",
                                                  "pg_gen_TextStartsWithQuery",
                                                  "pg_gen_TextEndsWithQuery",
                                                  nullptr };
            return names;
        }

        inline const char* EnumNameKindUnion(KindUnion e) {
            if (flatbuffers::IsOutRange(e, KindUnion::NONE, KindUnion::pg_gen_TextEndsWithQuery))
                return "";
            const size_t index = static_cast<size_t>(e);
            return EnumNamesKindUnion()[index];
        }

        template<typename T>
        struct KindUnionTraits {
            static const KindUnion enum_value = KindUnion::NONE;
        };

        template<>
        struct KindUnionTraits<pg::gen::TextMatchesQuery> {
            static const KindUnion enum_value = KindUnion::pg_gen_TextMatchesQuery;
        };

        template<>
        struct KindUnionTraits<pg::gen::TextContainsQuery> {
            static const KindUnion enum_value = KindUnion::pg_gen_TextContainsQuery;
        };

        template<>
        struct KindUnionTraits<pg::gen::TextStartsWithQuery> {
            static const KindUnion enum_value = KindUnion::pg_gen_TextStartsWithQuery;
        };

        template<>
        struct KindUnionTraits<pg::gen::TextEndsWithQuery> {
            static const KindUnion enum_value = KindUnion::pg_gen_TextEndsWithQuery;
        };

        struct KindUnionUnion {
            KindUnion type;
            void* value;

            KindUnionUnion() : type(KindUnion::NONE), value(nullptr) {}
            KindUnionUnion(KindUnionUnion&& u) FLATBUFFERS_NOEXCEPT: type(KindUnion::NONE), value(nullptr) {
                std::swap(type, u.type);
                std::swap(value, u.value);
            }
            KindUnionUnion(const KindUnionUnion&);
            KindUnionUnion& operator=(const KindUnionUnion& u) {
                KindUnionUnion t(u);
                std::swap(type, t.type);
                std::swap(value, t.value);
                return *this;
            }
            KindUnionUnion& operator=(KindUnionUnion&& u) FLATBUFFERS_NOEXCEPT {
                std::swap(type, u.type);
                std::swap(value, u.value);
                return *this;
            }
            ~KindUnionUnion() {
                Reset();
            }

            void Reset();

#ifndef FLATBUFFERS_CPP98_STL
            template<typename T>
            void Set(T&& val) {
                using RT = typename std::remove_reference<T>::type;
                Reset();
                type = KindUnionTraits<typename RT::TableType>::enum_value;
                if (type != KindUnion::NONE) {
                    value = new RT(std::forward<T>(val));
                }
            }
#endif  // FLATBUFFERS_CPP98_STL

            static void* UnPack(const void* obj, KindUnion type, const flatbuffers::resolver_function_t* resolver);
            flatbuffers::Offset<void> Pack(
                flatbuffers::FlatBufferBuilder& _fbb,
                const flatbuffers::rehasher_function_t* _rehasher = nullptr) const;

            pg::gen::TextMatchesQueryT* Aspg_gen_TextMatchesQuery() {
                return type == KindUnion::pg_gen_TextMatchesQuery ? reinterpret_cast<pg::gen::TextMatchesQueryT*>(value)
                                                                  : nullptr;
            }
            const pg::gen::TextMatchesQueryT* Aspg_gen_TextMatchesQuery() const {
                return type == KindUnion::pg_gen_TextMatchesQuery
                    ? reinterpret_cast<const pg::gen::TextMatchesQueryT*>(value)
                    : nullptr;
            }
            pg::gen::TextContainsQueryT* Aspg_gen_TextContainsQuery() {
                return type == KindUnion::pg_gen_TextContainsQuery
                    ? reinterpret_cast<pg::gen::TextContainsQueryT*>(value)
                    : nullptr;
            }
            const pg::gen::TextContainsQueryT* Aspg_gen_TextContainsQuery() const {
                return type == KindUnion::pg_gen_TextContainsQuery
                    ? reinterpret_cast<const pg::gen::TextContainsQueryT*>(value)
                    : nullptr;
            }
            pg::gen::TextStartsWithQueryT* Aspg_gen_TextStartsWithQuery() {
                return type == KindUnion::pg_gen_TextStartsWithQuery
                    ? reinterpret_cast<pg::gen::TextStartsWithQueryT*>(value)
                    : nullptr;
            }
            const pg::gen::TextStartsWithQueryT* Aspg_gen_TextStartsWithQuery() const {
                return type == KindUnion::pg_gen_TextStartsWithQuery
                    ? reinterpret_cast<const pg::gen::TextStartsWithQueryT*>(value)
                    : nullptr;
            }
            pg::gen::TextEndsWithQueryT* Aspg_gen_TextEndsWithQuery() {
                return type == KindUnion::pg_gen_TextEndsWithQuery
                    ? reinterpret_cast<pg::gen::TextEndsWithQueryT*>(value)
                    : nullptr;
            }
            const pg::gen::TextEndsWithQueryT* Aspg_gen_TextEndsWithQuery() const {
                return type == KindUnion::pg_gen_TextEndsWithQuery
                    ? reinterpret_cast<const pg::gen::TextEndsWithQueryT*>(value)
                    : nullptr;
            }
        };

        inline bool operator==(const KindUnionUnion& lhs, const KindUnionUnion& rhs) {
            if (lhs.type != rhs.type)
                return false;
            switch (lhs.type) {
                case KindUnion::NONE: {
                    return true;
                }
                case KindUnion::pg_gen_TextMatchesQuery: {
                    return *(reinterpret_cast<const pg::gen::TextMatchesQueryT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::TextMatchesQueryT*>(rhs.value));
                }
                case KindUnion::pg_gen_TextContainsQuery: {
                    return *(reinterpret_cast<const pg::gen::TextContainsQueryT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::TextContainsQueryT*>(rhs.value));
                }
                case KindUnion::pg_gen_TextStartsWithQuery: {
                    return *(reinterpret_cast<const pg::gen::TextStartsWithQueryT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::TextStartsWithQueryT*>(rhs.value));
                }
                case KindUnion::pg_gen_TextEndsWithQuery: {
                    return *(reinterpret_cast<const pg::gen::TextEndsWithQueryT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::TextEndsWithQueryT*>(rhs.value));
                }
                default: {
                    return false;
                }
            }
        }

        inline bool operator!=(const KindUnionUnion& lhs, const KindUnionUnion& rhs) {
            return !(lhs == rhs);
        }

        bool VerifyKindUnion(flatbuffers::Verifier& verifier, const void* obj, KindUnion type);
        bool VerifyKindUnionVector(
            flatbuffers::Verifier& verifier,
            const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
            const flatbuffers::Vector<uint8_t>* types);

    }  // namespace TextSearchKind_

    namespace DateSearchKind_ {

        enum class KindUnion : uint8_t {
            NONE = 0,
            pg_gen_BeforeDateQuery = 1,
            pg_gen_AfterDateQuery = 2,
            pg_gen_InDateRangeQuery = 3,
            pg_gen_NotInDateRangeQuery = 4,
            MIN = NONE,
            MAX = pg_gen_NotInDateRangeQuery
        };

        inline const KindUnion (&EnumValuesKindUnion())[5] {
            static const KindUnion values[] = { KindUnion::NONE,
                                                KindUnion::pg_gen_BeforeDateQuery,
                                                KindUnion::pg_gen_AfterDateQuery,
                                                KindUnion::pg_gen_InDateRangeQuery,
                                                KindUnion::pg_gen_NotInDateRangeQuery };
            return values;
        }

        inline const char* const* EnumNamesKindUnion() {
            static const char* const names[6] = { "NONE",
                                                  "pg_gen_BeforeDateQuery",
                                                  "pg_gen_AfterDateQuery",
                                                  "pg_gen_InDateRangeQuery",
                                                  "pg_gen_NotInDateRangeQuery",
                                                  nullptr };
            return names;
        }

        inline const char* EnumNameKindUnion(KindUnion e) {
            if (flatbuffers::IsOutRange(e, KindUnion::NONE, KindUnion::pg_gen_NotInDateRangeQuery))
                return "";
            const size_t index = static_cast<size_t>(e);
            return EnumNamesKindUnion()[index];
        }

        template<typename T>
        struct KindUnionTraits {
            static const KindUnion enum_value = KindUnion::NONE;
        };

        template<>
        struct KindUnionTraits<pg::gen::BeforeDateQuery> {
            static const KindUnion enum_value = KindUnion::pg_gen_BeforeDateQuery;
        };

        template<>
        struct KindUnionTraits<pg::gen::AfterDateQuery> {
            static const KindUnion enum_value = KindUnion::pg_gen_AfterDateQuery;
        };

        template<>
        struct KindUnionTraits<pg::gen::InDateRangeQuery> {
            static const KindUnion enum_value = KindUnion::pg_gen_InDateRangeQuery;
        };

        template<>
        struct KindUnionTraits<pg::gen::NotInDateRangeQuery> {
            static const KindUnion enum_value = KindUnion::pg_gen_NotInDateRangeQuery;
        };

        struct KindUnionUnion {
            KindUnion type;
            void* value;

            KindUnionUnion() : type(KindUnion::NONE), value(nullptr) {}
            KindUnionUnion(KindUnionUnion&& u) FLATBUFFERS_NOEXCEPT: type(KindUnion::NONE), value(nullptr) {
                std::swap(type, u.type);
                std::swap(value, u.value);
            }
            KindUnionUnion(const KindUnionUnion&);
            KindUnionUnion& operator=(const KindUnionUnion& u) {
                KindUnionUnion t(u);
                std::swap(type, t.type);
                std::swap(value, t.value);
                return *this;
            }
            KindUnionUnion& operator=(KindUnionUnion&& u) FLATBUFFERS_NOEXCEPT {
                std::swap(type, u.type);
                std::swap(value, u.value);
                return *this;
            }
            ~KindUnionUnion() {
                Reset();
            }

            void Reset();

#ifndef FLATBUFFERS_CPP98_STL
            template<typename T>
            void Set(T&& val) {
                using RT = typename std::remove_reference<T>::type;
                Reset();
                type = KindUnionTraits<typename RT::TableType>::enum_value;
                if (type != KindUnion::NONE) {
                    value = new RT(std::forward<T>(val));
                }
            }
#endif  // FLATBUFFERS_CPP98_STL

            static void* UnPack(const void* obj, KindUnion type, const flatbuffers::resolver_function_t* resolver);
            flatbuffers::Offset<void> Pack(
                flatbuffers::FlatBufferBuilder& _fbb,
                const flatbuffers::rehasher_function_t* _rehasher = nullptr) const;

            pg::gen::BeforeDateQueryT* Aspg_gen_BeforeDateQuery() {
                return type == KindUnion::pg_gen_BeforeDateQuery ? reinterpret_cast<pg::gen::BeforeDateQueryT*>(value)
                                                                 : nullptr;
            }
            const pg::gen::BeforeDateQueryT* Aspg_gen_BeforeDateQuery() const {
                return type == KindUnion::pg_gen_BeforeDateQuery
                    ? reinterpret_cast<const pg::gen::BeforeDateQueryT*>(value)
                    : nullptr;
            }
            pg::gen::AfterDateQueryT* Aspg_gen_AfterDateQuery() {
                return type == KindUnion::pg_gen_AfterDateQuery ? reinterpret_cast<pg::gen::AfterDateQueryT*>(value)
                                                                : nullptr;
            }
            const pg::gen::AfterDateQueryT* Aspg_gen_AfterDateQuery() const {
                return type == KindUnion::pg_gen_AfterDateQuery
                    ? reinterpret_cast<const pg::gen::AfterDateQueryT*>(value)
                    : nullptr;
            }
            pg::gen::InDateRangeQueryT* Aspg_gen_InDateRangeQuery() {
                return type == KindUnion::pg_gen_InDateRangeQuery ? reinterpret_cast<pg::gen::InDateRangeQueryT*>(value)
                                                                  : nullptr;
            }
            const pg::gen::InDateRangeQueryT* Aspg_gen_InDateRangeQuery() const {
                return type == KindUnion::pg_gen_InDateRangeQuery
                    ? reinterpret_cast<const pg::gen::InDateRangeQueryT*>(value)
                    : nullptr;
            }
            pg::gen::NotInDateRangeQueryT* Aspg_gen_NotInDateRangeQuery() {
                return type == KindUnion::pg_gen_NotInDateRangeQuery
                    ? reinterpret_cast<pg::gen::NotInDateRangeQueryT*>(value)
                    : nullptr;
            }
            const pg::gen::NotInDateRangeQueryT* Aspg_gen_NotInDateRangeQuery() const {
                return type == KindUnion::pg_gen_NotInDateRangeQuery
                    ? reinterpret_cast<const pg::gen::NotInDateRangeQueryT*>(value)
                    : nullptr;
            }
        };

        inline bool operator==(const KindUnionUnion& lhs, const KindUnionUnion& rhs) {
            if (lhs.type != rhs.type)
                return false;
            switch (lhs.type) {
                case KindUnion::NONE: {
                    return true;
                }
                case KindUnion::pg_gen_BeforeDateQuery: {
                    return *(reinterpret_cast<const pg::gen::BeforeDateQueryT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::BeforeDateQueryT*>(rhs.value));
                }
                case KindUnion::pg_gen_AfterDateQuery: {
                    return *(reinterpret_cast<const pg::gen::AfterDateQueryT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::AfterDateQueryT*>(rhs.value));
                }
                case KindUnion::pg_gen_InDateRangeQuery: {
                    return *(reinterpret_cast<const pg::gen::InDateRangeQueryT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::InDateRangeQueryT*>(rhs.value));
                }
                case KindUnion::pg_gen_NotInDateRangeQuery: {
                    return *(reinterpret_cast<const pg::gen::NotInDateRangeQueryT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::NotInDateRangeQueryT*>(rhs.value));
                }
                default: {
                    return false;
                }
            }
        }

        inline bool operator!=(const KindUnionUnion& lhs, const KindUnionUnion& rhs) {
            return !(lhs == rhs);
        }

        bool VerifyKindUnion(flatbuffers::Verifier& verifier, const void* obj, KindUnion type);
        bool VerifyKindUnionVector(
            flatbuffers::Verifier& verifier,
            const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
            const flatbuffers::Vector<uint8_t>* types);

    }  // namespace DateSearchKind_

    namespace SearchNoteData_ {

        enum class KindUnion : uint8_t {
            NONE = 0,
            pg_gen_NoteTitleSearch = 1,
            pg_gen_NoteContentSearch = 2,
            pg_gen_NoteTagSearch = 3,
            pg_gen_NoteCreatedSearch = 4,
            pg_gen_NoteUpdatedSearch = 5,
            MIN = NONE,
            MAX = pg_gen_NoteUpdatedSearch
        };

        inline const KindUnion (&EnumValuesKindUnion())[6] {
            static const KindUnion values[] = { KindUnion::NONE,
                                                KindUnion::pg_gen_NoteTitleSearch,
                                                KindUnion::pg_gen_NoteContentSearch,
                                                KindUnion::pg_gen_NoteTagSearch,
                                                KindUnion::pg_gen_NoteCreatedSearch,
                                                KindUnion::pg_gen_NoteUpdatedSearch };
            return values;
        }

        inline const char* const* EnumNamesKindUnion() {
            static const char* const names[7] = { "NONE",
                                                  "pg_gen_NoteTitleSearch",
                                                  "pg_gen_NoteContentSearch",
                                                  "pg_gen_NoteTagSearch",
                                                  "pg_gen_NoteCreatedSearch",
                                                  "pg_gen_NoteUpdatedSearch",
                                                  nullptr };
            return names;
        }

        inline const char* EnumNameKindUnion(KindUnion e) {
            if (flatbuffers::IsOutRange(e, KindUnion::NONE, KindUnion::pg_gen_NoteUpdatedSearch))
                return "";
            const size_t index = static_cast<size_t>(e);
            return EnumNamesKindUnion()[index];
        }

        template<typename T>
        struct KindUnionTraits {
            static const KindUnion enum_value = KindUnion::NONE;
        };

        template<>
        struct KindUnionTraits<pg::gen::NoteTitleSearch> {
            static const KindUnion enum_value = KindUnion::pg_gen_NoteTitleSearch;
        };

        template<>
        struct KindUnionTraits<pg::gen::NoteContentSearch> {
            static const KindUnion enum_value = KindUnion::pg_gen_NoteContentSearch;
        };

        template<>
        struct KindUnionTraits<pg::gen::NoteTagSearch> {
            static const KindUnion enum_value = KindUnion::pg_gen_NoteTagSearch;
        };

        template<>
        struct KindUnionTraits<pg::gen::NoteCreatedSearch> {
            static const KindUnion enum_value = KindUnion::pg_gen_NoteCreatedSearch;
        };

        template<>
        struct KindUnionTraits<pg::gen::NoteUpdatedSearch> {
            static const KindUnion enum_value = KindUnion::pg_gen_NoteUpdatedSearch;
        };

        struct KindUnionUnion {
            KindUnion type;
            void* value;

            KindUnionUnion() : type(KindUnion::NONE), value(nullptr) {}
            KindUnionUnion(KindUnionUnion&& u) FLATBUFFERS_NOEXCEPT: type(KindUnion::NONE), value(nullptr) {
                std::swap(type, u.type);
                std::swap(value, u.value);
            }
            KindUnionUnion(const KindUnionUnion&);
            KindUnionUnion& operator=(const KindUnionUnion& u) {
                KindUnionUnion t(u);
                std::swap(type, t.type);
                std::swap(value, t.value);
                return *this;
            }
            KindUnionUnion& operator=(KindUnionUnion&& u) FLATBUFFERS_NOEXCEPT {
                std::swap(type, u.type);
                std::swap(value, u.value);
                return *this;
            }
            ~KindUnionUnion() {
                Reset();
            }

            void Reset();

#ifndef FLATBUFFERS_CPP98_STL
            template<typename T>
            void Set(T&& val) {
                using RT = typename std::remove_reference<T>::type;
                Reset();
                type = KindUnionTraits<typename RT::TableType>::enum_value;
                if (type != KindUnion::NONE) {
                    value = new RT(std::forward<T>(val));
                }
            }
#endif  // FLATBUFFERS_CPP98_STL

            static void* UnPack(const void* obj, KindUnion type, const flatbuffers::resolver_function_t* resolver);
            flatbuffers::Offset<void> Pack(
                flatbuffers::FlatBufferBuilder& _fbb,
                const flatbuffers::rehasher_function_t* _rehasher = nullptr) const;

            pg::gen::NoteTitleSearchT* Aspg_gen_NoteTitleSearch() {
                return type == KindUnion::pg_gen_NoteTitleSearch ? reinterpret_cast<pg::gen::NoteTitleSearchT*>(value)
                                                                 : nullptr;
            }
            const pg::gen::NoteTitleSearchT* Aspg_gen_NoteTitleSearch() const {
                return type == KindUnion::pg_gen_NoteTitleSearch
                    ? reinterpret_cast<const pg::gen::NoteTitleSearchT*>(value)
                    : nullptr;
            }
            pg::gen::NoteContentSearchT* Aspg_gen_NoteContentSearch() {
                return type == KindUnion::pg_gen_NoteContentSearch
                    ? reinterpret_cast<pg::gen::NoteContentSearchT*>(value)
                    : nullptr;
            }
            const pg::gen::NoteContentSearchT* Aspg_gen_NoteContentSearch() const {
                return type == KindUnion::pg_gen_NoteContentSearch
                    ? reinterpret_cast<const pg::gen::NoteContentSearchT*>(value)
                    : nullptr;
            }
            pg::gen::NoteTagSearchT* Aspg_gen_NoteTagSearch() {
                return type == KindUnion::pg_gen_NoteTagSearch ? reinterpret_cast<pg::gen::NoteTagSearchT*>(value)
                                                               : nullptr;
            }
            const pg::gen::NoteTagSearchT* Aspg_gen_NoteTagSearch() const {
                return type == KindUnion::pg_gen_NoteTagSearch ? reinterpret_cast<const pg::gen::NoteTagSearchT*>(value)
                                                               : nullptr;
            }
            pg::gen::NoteCreatedSearchT* Aspg_gen_NoteCreatedSearch() {
                return type == KindUnion::pg_gen_NoteCreatedSearch
                    ? reinterpret_cast<pg::gen::NoteCreatedSearchT*>(value)
                    : nullptr;
            }
            const pg::gen::NoteCreatedSearchT* Aspg_gen_NoteCreatedSearch() const {
                return type == KindUnion::pg_gen_NoteCreatedSearch
                    ? reinterpret_cast<const pg::gen::NoteCreatedSearchT*>(value)
                    : nullptr;
            }
            pg::gen::NoteUpdatedSearchT* Aspg_gen_NoteUpdatedSearch() {
                return type == KindUnion::pg_gen_NoteUpdatedSearch
                    ? reinterpret_cast<pg::gen::NoteUpdatedSearchT*>(value)
                    : nullptr;
            }
            const pg::gen::NoteUpdatedSearchT* Aspg_gen_NoteUpdatedSearch() const {
                return type == KindUnion::pg_gen_NoteUpdatedSearch
                    ? reinterpret_cast<const pg::gen::NoteUpdatedSearchT*>(value)
                    : nullptr;
            }
        };

        inline bool operator==(const KindUnionUnion& lhs, const KindUnionUnion& rhs) {
            if (lhs.type != rhs.type)
                return false;
            switch (lhs.type) {
                case KindUnion::NONE: {
                    return true;
                }
                case KindUnion::pg_gen_NoteTitleSearch: {
                    return *(reinterpret_cast<const pg::gen::NoteTitleSearchT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::NoteTitleSearchT*>(rhs.value));
                }
                case KindUnion::pg_gen_NoteContentSearch: {
                    return *(reinterpret_cast<const pg::gen::NoteContentSearchT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::NoteContentSearchT*>(rhs.value));
                }
                case KindUnion::pg_gen_NoteTagSearch: {
                    return *(reinterpret_cast<const pg::gen::NoteTagSearchT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::NoteTagSearchT*>(rhs.value));
                }
                case KindUnion::pg_gen_NoteCreatedSearch: {
                    return *(reinterpret_cast<const pg::gen::NoteCreatedSearchT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::NoteCreatedSearchT*>(rhs.value));
                }
                case KindUnion::pg_gen_NoteUpdatedSearch: {
                    return *(reinterpret_cast<const pg::gen::NoteUpdatedSearchT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::NoteUpdatedSearchT*>(rhs.value));
                }
                default: {
                    return false;
                }
            }
        }

        inline bool operator!=(const KindUnionUnion& lhs, const KindUnionUnion& rhs) {
            return !(lhs == rhs);
        }

        bool VerifyKindUnion(flatbuffers::Verifier& verifier, const void* obj, KindUnion type);
        bool VerifyKindUnionVector(
            flatbuffers::Verifier& verifier,
            const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
            const flatbuffers::Vector<uint8_t>* types);

    }  // namespace SearchNoteData_

    namespace CreateNoteResponse_ {

        enum class RespUnion : uint8_t {
            NONE = 0,
            pg_gen_NoteObject = 1,
            pg_gen_ResponseError = 2,
            MIN = NONE,
            MAX = pg_gen_ResponseError
        };

        inline const RespUnion (&EnumValuesRespUnion())[3] {
            static const RespUnion values[] = { RespUnion::NONE,
                                                RespUnion::pg_gen_NoteObject,
                                                RespUnion::pg_gen_ResponseError };
            return values;
        }

        inline const char* const* EnumNamesRespUnion() {
            static const char* const names[4] = { "NONE", "pg_gen_NoteObject", "pg_gen_ResponseError", nullptr };
            return names;
        }

        inline const char* EnumNameRespUnion(RespUnion e) {
            if (flatbuffers::IsOutRange(e, RespUnion::NONE, RespUnion::pg_gen_ResponseError))
                return "";
            const size_t index = static_cast<size_t>(e);
            return EnumNamesRespUnion()[index];
        }

        template<typename T>
        struct RespUnionTraits {
            static const RespUnion enum_value = RespUnion::NONE;
        };

        template<>
        struct RespUnionTraits<pg::gen::NoteObject> {
            static const RespUnion enum_value = RespUnion::pg_gen_NoteObject;
        };

        template<>
        struct RespUnionTraits<pg::gen::ResponseError> {
            static const RespUnion enum_value = RespUnion::pg_gen_ResponseError;
        };

        struct RespUnionUnion {
            RespUnion type;
            void* value;

            RespUnionUnion() : type(RespUnion::NONE), value(nullptr) {}
            RespUnionUnion(RespUnionUnion&& u) FLATBUFFERS_NOEXCEPT: type(RespUnion::NONE), value(nullptr) {
                std::swap(type, u.type);
                std::swap(value, u.value);
            }
            RespUnionUnion(const RespUnionUnion&);
            RespUnionUnion& operator=(const RespUnionUnion& u) {
                RespUnionUnion t(u);
                std::swap(type, t.type);
                std::swap(value, t.value);
                return *this;
            }
            RespUnionUnion& operator=(RespUnionUnion&& u) FLATBUFFERS_NOEXCEPT {
                std::swap(type, u.type);
                std::swap(value, u.value);
                return *this;
            }
            ~RespUnionUnion() {
                Reset();
            }

            void Reset();

#ifndef FLATBUFFERS_CPP98_STL
            template<typename T>
            void Set(T&& val) {
                using RT = typename std::remove_reference<T>::type;
                Reset();
                type = RespUnionTraits<typename RT::TableType>::enum_value;
                if (type != RespUnion::NONE) {
                    value = new RT(std::forward<T>(val));
                }
            }
#endif  // FLATBUFFERS_CPP98_STL

            static void* UnPack(const void* obj, RespUnion type, const flatbuffers::resolver_function_t* resolver);
            flatbuffers::Offset<void> Pack(
                flatbuffers::FlatBufferBuilder& _fbb,
                const flatbuffers::rehasher_function_t* _rehasher = nullptr) const;

            pg::gen::NoteObjectT* Aspg_gen_NoteObject() {
                return type == RespUnion::pg_gen_NoteObject ? reinterpret_cast<pg::gen::NoteObjectT*>(value) : nullptr;
            }
            const pg::gen::NoteObjectT* Aspg_gen_NoteObject() const {
                return type == RespUnion::pg_gen_NoteObject ? reinterpret_cast<const pg::gen::NoteObjectT*>(value)
                                                            : nullptr;
            }
            pg::gen::ResponseErrorT* Aspg_gen_ResponseError() {
                return type == RespUnion::pg_gen_ResponseError ? reinterpret_cast<pg::gen::ResponseErrorT*>(value)
                                                               : nullptr;
            }
            const pg::gen::ResponseErrorT* Aspg_gen_ResponseError() const {
                return type == RespUnion::pg_gen_ResponseError ? reinterpret_cast<const pg::gen::ResponseErrorT*>(value)
                                                               : nullptr;
            }
        };

        inline bool operator==(const RespUnionUnion& lhs, const RespUnionUnion& rhs) {
            if (lhs.type != rhs.type)
                return false;
            switch (lhs.type) {
                case RespUnion::NONE: {
                    return true;
                }
                case RespUnion::pg_gen_NoteObject: {
                    return *(reinterpret_cast<const pg::gen::NoteObjectT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::NoteObjectT*>(rhs.value));
                }
                case RespUnion::pg_gen_ResponseError: {
                    return *(reinterpret_cast<const pg::gen::ResponseErrorT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::ResponseErrorT*>(rhs.value));
                }
                default: {
                    return false;
                }
            }
        }

        inline bool operator!=(const RespUnionUnion& lhs, const RespUnionUnion& rhs) {
            return !(lhs == rhs);
        }

        bool VerifyRespUnion(flatbuffers::Verifier& verifier, const void* obj, RespUnion type);
        bool VerifyRespUnionVector(
            flatbuffers::Verifier& verifier,
            const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
            const flatbuffers::Vector<uint8_t>* types);

    }  // namespace CreateNoteResponse_

    namespace UpdateNoteResponse_ {

        enum class RespUnion : uint8_t {
            NONE = 0,
            pg_gen_NoteObject = 1,
            pg_gen_ResponseError = 2,
            MIN = NONE,
            MAX = pg_gen_ResponseError
        };

        inline const RespUnion (&EnumValuesRespUnion())[3] {
            static const RespUnion values[] = { RespUnion::NONE,
                                                RespUnion::pg_gen_NoteObject,
                                                RespUnion::pg_gen_ResponseError };
            return values;
        }

        inline const char* const* EnumNamesRespUnion() {
            static const char* const names[4] = { "NONE", "pg_gen_NoteObject", "pg_gen_ResponseError", nullptr };
            return names;
        }

        inline const char* EnumNameRespUnion(RespUnion e) {
            if (flatbuffers::IsOutRange(e, RespUnion::NONE, RespUnion::pg_gen_ResponseError))
                return "";
            const size_t index = static_cast<size_t>(e);
            return EnumNamesRespUnion()[index];
        }

        template<typename T>
        struct RespUnionTraits {
            static const RespUnion enum_value = RespUnion::NONE;
        };

        template<>
        struct RespUnionTraits<pg::gen::NoteObject> {
            static const RespUnion enum_value = RespUnion::pg_gen_NoteObject;
        };

        template<>
        struct RespUnionTraits<pg::gen::ResponseError> {
            static const RespUnion enum_value = RespUnion::pg_gen_ResponseError;
        };

        struct RespUnionUnion {
            RespUnion type;
            void* value;

            RespUnionUnion() : type(RespUnion::NONE), value(nullptr) {}
            RespUnionUnion(RespUnionUnion&& u) FLATBUFFERS_NOEXCEPT: type(RespUnion::NONE), value(nullptr) {
                std::swap(type, u.type);
                std::swap(value, u.value);
            }
            RespUnionUnion(const RespUnionUnion&);
            RespUnionUnion& operator=(const RespUnionUnion& u) {
                RespUnionUnion t(u);
                std::swap(type, t.type);
                std::swap(value, t.value);
                return *this;
            }
            RespUnionUnion& operator=(RespUnionUnion&& u) FLATBUFFERS_NOEXCEPT {
                std::swap(type, u.type);
                std::swap(value, u.value);
                return *this;
            }
            ~RespUnionUnion() {
                Reset();
            }

            void Reset();

#ifndef FLATBUFFERS_CPP98_STL
            template<typename T>
            void Set(T&& val) {
                using RT = typename std::remove_reference<T>::type;
                Reset();
                type = RespUnionTraits<typename RT::TableType>::enum_value;
                if (type != RespUnion::NONE) {
                    value = new RT(std::forward<T>(val));
                }
            }
#endif  // FLATBUFFERS_CPP98_STL

            static void* UnPack(const void* obj, RespUnion type, const flatbuffers::resolver_function_t* resolver);
            flatbuffers::Offset<void> Pack(
                flatbuffers::FlatBufferBuilder& _fbb,
                const flatbuffers::rehasher_function_t* _rehasher = nullptr) const;

            pg::gen::NoteObjectT* Aspg_gen_NoteObject() {
                return type == RespUnion::pg_gen_NoteObject ? reinterpret_cast<pg::gen::NoteObjectT*>(value) : nullptr;
            }
            const pg::gen::NoteObjectT* Aspg_gen_NoteObject() const {
                return type == RespUnion::pg_gen_NoteObject ? reinterpret_cast<const pg::gen::NoteObjectT*>(value)
                                                            : nullptr;
            }
            pg::gen::ResponseErrorT* Aspg_gen_ResponseError() {
                return type == RespUnion::pg_gen_ResponseError ? reinterpret_cast<pg::gen::ResponseErrorT*>(value)
                                                               : nullptr;
            }
            const pg::gen::ResponseErrorT* Aspg_gen_ResponseError() const {
                return type == RespUnion::pg_gen_ResponseError ? reinterpret_cast<const pg::gen::ResponseErrorT*>(value)
                                                               : nullptr;
            }
        };

        inline bool operator==(const RespUnionUnion& lhs, const RespUnionUnion& rhs) {
            if (lhs.type != rhs.type)
                return false;
            switch (lhs.type) {
                case RespUnion::NONE: {
                    return true;
                }
                case RespUnion::pg_gen_NoteObject: {
                    return *(reinterpret_cast<const pg::gen::NoteObjectT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::NoteObjectT*>(rhs.value));
                }
                case RespUnion::pg_gen_ResponseError: {
                    return *(reinterpret_cast<const pg::gen::ResponseErrorT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::ResponseErrorT*>(rhs.value));
                }
                default: {
                    return false;
                }
            }
        }

        inline bool operator!=(const RespUnionUnion& lhs, const RespUnionUnion& rhs) {
            return !(lhs == rhs);
        }

        bool VerifyRespUnion(flatbuffers::Verifier& verifier, const void* obj, RespUnion type);
        bool VerifyRespUnionVector(
            flatbuffers::Verifier& verifier,
            const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
            const flatbuffers::Vector<uint8_t>* types);

    }  // namespace UpdateNoteResponse_

    namespace DeleteNoteResponse_ {

        enum class RespUnion : uint8_t {
            NONE = 0,
            pg_gen_Boolean = 1,
            pg_gen_ResponseError = 2,
            MIN = NONE,
            MAX = pg_gen_ResponseError
        };

        inline const RespUnion (&EnumValuesRespUnion())[3] {
            static const RespUnion values[] = { RespUnion::NONE,
                                                RespUnion::pg_gen_Boolean,
                                                RespUnion::pg_gen_ResponseError };
            return values;
        }

        inline const char* const* EnumNamesRespUnion() {
            static const char* const names[4] = { "NONE", "pg_gen_Boolean", "pg_gen_ResponseError", nullptr };
            return names;
        }

        inline const char* EnumNameRespUnion(RespUnion e) {
            if (flatbuffers::IsOutRange(e, RespUnion::NONE, RespUnion::pg_gen_ResponseError))
                return "";
            const size_t index = static_cast<size_t>(e);
            return EnumNamesRespUnion()[index];
        }

        template<typename T>
        struct RespUnionTraits {
            static const RespUnion enum_value = RespUnion::NONE;
        };

        template<>
        struct RespUnionTraits<pg::gen::Boolean> {
            static const RespUnion enum_value = RespUnion::pg_gen_Boolean;
        };

        template<>
        struct RespUnionTraits<pg::gen::ResponseError> {
            static const RespUnion enum_value = RespUnion::pg_gen_ResponseError;
        };

        struct RespUnionUnion {
            RespUnion type;
            void* value;

            RespUnionUnion() : type(RespUnion::NONE), value(nullptr) {}
            RespUnionUnion(RespUnionUnion&& u) FLATBUFFERS_NOEXCEPT: type(RespUnion::NONE), value(nullptr) {
                std::swap(type, u.type);
                std::swap(value, u.value);
            }
            RespUnionUnion(const RespUnionUnion&);
            RespUnionUnion& operator=(const RespUnionUnion& u) {
                RespUnionUnion t(u);
                std::swap(type, t.type);
                std::swap(value, t.value);
                return *this;
            }
            RespUnionUnion& operator=(RespUnionUnion&& u) FLATBUFFERS_NOEXCEPT {
                std::swap(type, u.type);
                std::swap(value, u.value);
                return *this;
            }
            ~RespUnionUnion() {
                Reset();
            }

            void Reset();

#ifndef FLATBUFFERS_CPP98_STL
            template<typename T>
            void Set(T&& val) {
                using RT = typename std::remove_reference<T>::type;
                Reset();
                type = RespUnionTraits<typename RT::TableType>::enum_value;
                if (type != RespUnion::NONE) {
                    value = new RT(std::forward<T>(val));
                }
            }
#endif  // FLATBUFFERS_CPP98_STL

            static void* UnPack(const void* obj, RespUnion type, const flatbuffers::resolver_function_t* resolver);
            flatbuffers::Offset<void> Pack(
                flatbuffers::FlatBufferBuilder& _fbb,
                const flatbuffers::rehasher_function_t* _rehasher = nullptr) const;

            pg::gen::BooleanT* Aspg_gen_Boolean() {
                return type == RespUnion::pg_gen_Boolean ? reinterpret_cast<pg::gen::BooleanT*>(value) : nullptr;
            }
            const pg::gen::BooleanT* Aspg_gen_Boolean() const {
                return type == RespUnion::pg_gen_Boolean ? reinterpret_cast<const pg::gen::BooleanT*>(value) : nullptr;
            }
            pg::gen::ResponseErrorT* Aspg_gen_ResponseError() {
                return type == RespUnion::pg_gen_ResponseError ? reinterpret_cast<pg::gen::ResponseErrorT*>(value)
                                                               : nullptr;
            }
            const pg::gen::ResponseErrorT* Aspg_gen_ResponseError() const {
                return type == RespUnion::pg_gen_ResponseError ? reinterpret_cast<const pg::gen::ResponseErrorT*>(value)
                                                               : nullptr;
            }
        };

        inline bool operator==(const RespUnionUnion& lhs, const RespUnionUnion& rhs) {
            if (lhs.type != rhs.type)
                return false;
            switch (lhs.type) {
                case RespUnion::NONE: {
                    return true;
                }
                case RespUnion::pg_gen_Boolean: {
                    return *(reinterpret_cast<const pg::gen::BooleanT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::BooleanT*>(rhs.value));
                }
                case RespUnion::pg_gen_ResponseError: {
                    return *(reinterpret_cast<const pg::gen::ResponseErrorT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::ResponseErrorT*>(rhs.value));
                }
                default: {
                    return false;
                }
            }
        }

        inline bool operator!=(const RespUnionUnion& lhs, const RespUnionUnion& rhs) {
            return !(lhs == rhs);
        }

        bool VerifyRespUnion(flatbuffers::Verifier& verifier, const void* obj, RespUnion type);
        bool VerifyRespUnionVector(
            flatbuffers::Verifier& verifier,
            const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
            const flatbuffers::Vector<uint8_t>* types);

    }  // namespace DeleteNoteResponse_

    namespace GetNoteResponse_ {

        enum class RespUnion : uint8_t {
            NONE = 0,
            pg_gen_NoteObject = 1,
            pg_gen_ResponseError = 2,
            MIN = NONE,
            MAX = pg_gen_ResponseError
        };

        inline const RespUnion (&EnumValuesRespUnion())[3] {
            static const RespUnion values[] = { RespUnion::NONE,
                                                RespUnion::pg_gen_NoteObject,
                                                RespUnion::pg_gen_ResponseError };
            return values;
        }

        inline const char* const* EnumNamesRespUnion() {
            static const char* const names[4] = { "NONE", "pg_gen_NoteObject", "pg_gen_ResponseError", nullptr };
            return names;
        }

        inline const char* EnumNameRespUnion(RespUnion e) {
            if (flatbuffers::IsOutRange(e, RespUnion::NONE, RespUnion::pg_gen_ResponseError))
                return "";
            const size_t index = static_cast<size_t>(e);
            return EnumNamesRespUnion()[index];
        }

        template<typename T>
        struct RespUnionTraits {
            static const RespUnion enum_value = RespUnion::NONE;
        };

        template<>
        struct RespUnionTraits<pg::gen::NoteObject> {
            static const RespUnion enum_value = RespUnion::pg_gen_NoteObject;
        };

        template<>
        struct RespUnionTraits<pg::gen::ResponseError> {
            static const RespUnion enum_value = RespUnion::pg_gen_ResponseError;
        };

        struct RespUnionUnion {
            RespUnion type;
            void* value;

            RespUnionUnion() : type(RespUnion::NONE), value(nullptr) {}
            RespUnionUnion(RespUnionUnion&& u) FLATBUFFERS_NOEXCEPT: type(RespUnion::NONE), value(nullptr) {
                std::swap(type, u.type);
                std::swap(value, u.value);
            }
            RespUnionUnion(const RespUnionUnion&);
            RespUnionUnion& operator=(const RespUnionUnion& u) {
                RespUnionUnion t(u);
                std::swap(type, t.type);
                std::swap(value, t.value);
                return *this;
            }
            RespUnionUnion& operator=(RespUnionUnion&& u) FLATBUFFERS_NOEXCEPT {
                std::swap(type, u.type);
                std::swap(value, u.value);
                return *this;
            }
            ~RespUnionUnion() {
                Reset();
            }

            void Reset();

#ifndef FLATBUFFERS_CPP98_STL
            template<typename T>
            void Set(T&& val) {
                using RT = typename std::remove_reference<T>::type;
                Reset();
                type = RespUnionTraits<typename RT::TableType>::enum_value;
                if (type != RespUnion::NONE) {
                    value = new RT(std::forward<T>(val));
                }
            }
#endif  // FLATBUFFERS_CPP98_STL

            static void* UnPack(const void* obj, RespUnion type, const flatbuffers::resolver_function_t* resolver);
            flatbuffers::Offset<void> Pack(
                flatbuffers::FlatBufferBuilder& _fbb,
                const flatbuffers::rehasher_function_t* _rehasher = nullptr) const;

            pg::gen::NoteObjectT* Aspg_gen_NoteObject() {
                return type == RespUnion::pg_gen_NoteObject ? reinterpret_cast<pg::gen::NoteObjectT*>(value) : nullptr;
            }
            const pg::gen::NoteObjectT* Aspg_gen_NoteObject() const {
                return type == RespUnion::pg_gen_NoteObject ? reinterpret_cast<const pg::gen::NoteObjectT*>(value)
                                                            : nullptr;
            }
            pg::gen::ResponseErrorT* Aspg_gen_ResponseError() {
                return type == RespUnion::pg_gen_ResponseError ? reinterpret_cast<pg::gen::ResponseErrorT*>(value)
                                                               : nullptr;
            }
            const pg::gen::ResponseErrorT* Aspg_gen_ResponseError() const {
                return type == RespUnion::pg_gen_ResponseError ? reinterpret_cast<const pg::gen::ResponseErrorT*>(value)
                                                               : nullptr;
            }
        };

        inline bool operator==(const RespUnionUnion& lhs, const RespUnionUnion& rhs) {
            if (lhs.type != rhs.type)
                return false;
            switch (lhs.type) {
                case RespUnion::NONE: {
                    return true;
                }
                case RespUnion::pg_gen_NoteObject: {
                    return *(reinterpret_cast<const pg::gen::NoteObjectT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::NoteObjectT*>(rhs.value));
                }
                case RespUnion::pg_gen_ResponseError: {
                    return *(reinterpret_cast<const pg::gen::ResponseErrorT*>(lhs.value))
                        == *(reinterpret_cast<const pg::gen::ResponseErrorT*>(rhs.value));
                }
                default: {
                    return false;
                }
            }
        }

        inline bool operator!=(const RespUnionUnion& lhs, const RespUnionUnion& rhs) {
            return !(lhs == rhs);
        }

        bool VerifyRespUnion(flatbuffers::Verifier& verifier, const void* obj, RespUnion type);
        bool VerifyRespUnionVector(
            flatbuffers::Verifier& verifier,
            const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
            const flatbuffers::Vector<uint8_t>* types);

    }  // namespace GetNoteResponse_

    struct TimestampT: public flatbuffers::NativeTable {
        typedef Timestamp TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.TimestampT";
        }
        int64_t seconds = 0;
        int32_t nanos = 0;
    };

    inline bool operator==(const TimestampT& lhs, const TimestampT& rhs) {
        return (lhs.seconds == rhs.seconds) && (lhs.nanos == rhs.nanos);
    }

    inline bool operator!=(const TimestampT& lhs, const TimestampT& rhs) {
        return !(lhs == rhs);
    }

    struct Timestamp FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef TimestampT NativeTableType;
        typedef TimestampBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return TimestampTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.Timestamp";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_SECONDS = 4, VT_NANOS = 6 };
        int64_t seconds() const {
            return GetField<int64_t>(VT_SECONDS, 0);
        }
        int32_t nanos() const {
            return GetField<int32_t>(VT_NANOS, 0);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return seconds();
            else if constexpr (Index == 1)
                return nanos();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyField<int64_t>(verifier, VT_SECONDS)
                && VerifyField<int32_t>(verifier, VT_NANOS) && verifier.EndTable();
        }
        TimestampT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(TimestampT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<Timestamp> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const TimestampT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct TimestampBuilder {
        typedef Timestamp Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_seconds(int64_t seconds) {
            fbb_.AddElement<int64_t>(Timestamp::VT_SECONDS, seconds, 0);
        }
        void add_nanos(int32_t nanos) {
            fbb_.AddElement<int32_t>(Timestamp::VT_NANOS, nanos, 0);
        }
        explicit TimestampBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Timestamp> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Timestamp>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Timestamp>
    CreateTimestamp(flatbuffers::FlatBufferBuilder& _fbb, int64_t seconds = 0, int32_t nanos = 0) {
        TimestampBuilder builder_(_fbb);
        builder_.add_seconds(seconds);
        builder_.add_nanos(nanos);
        return builder_.Finish();
    }

    struct Timestamp::Traits {
        using type = Timestamp;
        static auto constexpr Create = CreateTimestamp;
        static constexpr auto name = "Timestamp";
        static constexpr auto fully_qualified_name = "pg.gen.Timestamp";
        static constexpr std::array<const char*, 2> field_names = { "seconds", "nanos" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    flatbuffers::Offset<Timestamp> CreateTimestamp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TimestampT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct ResponseErrorT: public flatbuffers::NativeTable {
        typedef ResponseError TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.ResponseErrorT";
        }
        uint32_t code = 0;
        std::string message {};
    };

    inline bool operator==(const ResponseErrorT& lhs, const ResponseErrorT& rhs) {
        return (lhs.code == rhs.code) && (lhs.message == rhs.message);
    }

    inline bool operator!=(const ResponseErrorT& lhs, const ResponseErrorT& rhs) {
        return !(lhs == rhs);
    }

    struct ResponseError FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef ResponseErrorT NativeTableType;
        typedef ResponseErrorBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return ResponseErrorTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.ResponseError";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_CODE = 4, VT_MESSAGE = 6 };
        uint32_t code() const {
            return GetField<uint32_t>(VT_CODE, 0);
        }
        const flatbuffers::String* _Nullable message() const {
            return GetPointer<const flatbuffers::String*>(VT_MESSAGE);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return code();
            else if constexpr (Index == 1)
                return message();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_CODE)
                && VerifyOffset(verifier, VT_MESSAGE) && verifier.VerifyString(message()) && verifier.EndTable();
        }
        ResponseErrorT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(ResponseErrorT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<ResponseError> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const ResponseErrorT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct ResponseErrorBuilder {
        typedef ResponseError Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_code(uint32_t code) {
            fbb_.AddElement<uint32_t>(ResponseError::VT_CODE, code, 0);
        }
        void add_message(flatbuffers::Offset<flatbuffers::String> message) {
            fbb_.AddOffset(ResponseError::VT_MESSAGE, message);
        }
        explicit ResponseErrorBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<ResponseError> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<ResponseError>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<ResponseError> CreateResponseError(
        flatbuffers::FlatBufferBuilder& _fbb,
        uint32_t code = 0,
        flatbuffers::Offset<flatbuffers::String> message = 0) {
        ResponseErrorBuilder builder_(_fbb);
        builder_.add_message(message);
        builder_.add_code(code);
        return builder_.Finish();
    }

    struct ResponseError::Traits {
        using type = ResponseError;
        static auto constexpr Create = CreateResponseError;
        static constexpr auto name = "ResponseError";
        static constexpr auto fully_qualified_name = "pg.gen.ResponseError";
        static constexpr std::array<const char*, 2> field_names = { "code", "message" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    inline flatbuffers::Offset<ResponseError>
    CreateResponseErrorDirect(flatbuffers::FlatBufferBuilder& _fbb, uint32_t code = 0, const char* message = nullptr) {
        auto message__ = message ? _fbb.CreateString(message) : 0;
        return pg::gen::CreateResponseError(_fbb, code, message__);
    }

    flatbuffers::Offset<ResponseError> CreateResponseError(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ResponseErrorT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct ReplaceTextPairT: public flatbuffers::NativeTable {
        typedef ReplaceTextPair TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.ReplaceTextPairT";
        }
        std::string search {};
        std::string replace {};
    };

    inline bool operator==(const ReplaceTextPairT& lhs, const ReplaceTextPairT& rhs) {
        return (lhs.search == rhs.search) && (lhs.replace == rhs.replace);
    }

    inline bool operator!=(const ReplaceTextPairT& lhs, const ReplaceTextPairT& rhs) {
        return !(lhs == rhs);
    }

    struct ReplaceTextPair FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef ReplaceTextPairT NativeTableType;
        typedef ReplaceTextPairBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return ReplaceTextPairTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.ReplaceTextPair";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_SEARCH = 4, VT_REPLACE = 6 };
        const flatbuffers::String* _Nullable search() const {
            return GetPointer<const flatbuffers::String*>(VT_SEARCH);
        }
        const flatbuffers::String* _Nullable replace() const {
            return GetPointer<const flatbuffers::String*>(VT_REPLACE);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return search();
            else if constexpr (Index == 1)
                return replace();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SEARCH) && verifier.VerifyString(search())
                && VerifyOffset(verifier, VT_REPLACE) && verifier.VerifyString(replace()) && verifier.EndTable();
        }
        ReplaceTextPairT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(ReplaceTextPairT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<ReplaceTextPair> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const ReplaceTextPairT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct ReplaceTextPairBuilder {
        typedef ReplaceTextPair Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_search(flatbuffers::Offset<flatbuffers::String> search) {
            fbb_.AddOffset(ReplaceTextPair::VT_SEARCH, search);
        }
        void add_replace(flatbuffers::Offset<flatbuffers::String> replace) {
            fbb_.AddOffset(ReplaceTextPair::VT_REPLACE, replace);
        }
        explicit ReplaceTextPairBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<ReplaceTextPair> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<ReplaceTextPair>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<ReplaceTextPair> CreateReplaceTextPair(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::String> search = 0,
        flatbuffers::Offset<flatbuffers::String> replace = 0) {
        ReplaceTextPairBuilder builder_(_fbb);
        builder_.add_replace(replace);
        builder_.add_search(search);
        return builder_.Finish();
    }

    struct ReplaceTextPair::Traits {
        using type = ReplaceTextPair;
        static auto constexpr Create = CreateReplaceTextPair;
        static constexpr auto name = "ReplaceTextPair";
        static constexpr auto fully_qualified_name = "pg.gen.ReplaceTextPair";
        static constexpr std::array<const char*, 2> field_names = { "search", "replace" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    inline flatbuffers::Offset<ReplaceTextPair> CreateReplaceTextPairDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const char* search = nullptr,
        const char* replace = nullptr) {
        auto search__ = search ? _fbb.CreateString(search) : 0;
        auto replace__ = replace ? _fbb.CreateString(replace) : 0;
        return pg::gen::CreateReplaceTextPair(_fbb, search__, replace__);
    }

    flatbuffers::Offset<ReplaceTextPair> CreateReplaceTextPair(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ReplaceTextPairT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct AppendTextOpT: public flatbuffers::NativeTable {
        typedef AppendTextOp TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.AppendTextOpT";
        }
        std::string text {};
    };

    inline bool operator==(const AppendTextOpT& lhs, const AppendTextOpT& rhs) {
        return (lhs.text == rhs.text);
    }

    inline bool operator!=(const AppendTextOpT& lhs, const AppendTextOpT& rhs) {
        return !(lhs == rhs);
    }

    struct AppendTextOp FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef AppendTextOpT NativeTableType;
        typedef AppendTextOpBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return AppendTextOpTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.AppendTextOp";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TEXT = 4 };
        const flatbuffers::String* _Nullable text() const {
            return GetPointer<const flatbuffers::String*>(VT_TEXT);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return text();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TEXT) && verifier.VerifyString(text())
                && verifier.EndTable();
        }
        AppendTextOpT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(AppendTextOpT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<AppendTextOp> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const AppendTextOpT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct AppendTextOpBuilder {
        typedef AppendTextOp Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_text(flatbuffers::Offset<flatbuffers::String> text) {
            fbb_.AddOffset(AppendTextOp::VT_TEXT, text);
        }
        explicit AppendTextOpBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<AppendTextOp> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<AppendTextOp>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<AppendTextOp>
    CreateAppendTextOp(flatbuffers::FlatBufferBuilder& _fbb, flatbuffers::Offset<flatbuffers::String> text = 0) {
        AppendTextOpBuilder builder_(_fbb);
        builder_.add_text(text);
        return builder_.Finish();
    }

    struct AppendTextOp::Traits {
        using type = AppendTextOp;
        static auto constexpr Create = CreateAppendTextOp;
        static constexpr auto name = "AppendTextOp";
        static constexpr auto fully_qualified_name = "pg.gen.AppendTextOp";
        static constexpr std::array<const char*, 1> field_names = { "text" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    inline flatbuffers::Offset<AppendTextOp>
    CreateAppendTextOpDirect(flatbuffers::FlatBufferBuilder& _fbb, const char* text = nullptr) {
        auto text__ = text ? _fbb.CreateString(text) : 0;
        return pg::gen::CreateAppendTextOp(_fbb, text__);
    }

    flatbuffers::Offset<AppendTextOp> CreateAppendTextOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const AppendTextOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct InsertTextOpT: public flatbuffers::NativeTable {
        typedef InsertTextOp TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.InsertTextOpT";
        }
        std::string text {};
        uint32_t position = 0;
    };

    inline bool operator==(const InsertTextOpT& lhs, const InsertTextOpT& rhs) {
        return (lhs.text == rhs.text) && (lhs.position == rhs.position);
    }

    inline bool operator!=(const InsertTextOpT& lhs, const InsertTextOpT& rhs) {
        return !(lhs == rhs);
    }

    struct InsertTextOp FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef InsertTextOpT NativeTableType;
        typedef InsertTextOpBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return InsertTextOpTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.InsertTextOp";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TEXT = 4, VT_POSITION = 6 };
        const flatbuffers::String* _Nullable text() const {
            return GetPointer<const flatbuffers::String*>(VT_TEXT);
        }
        uint32_t position() const {
            return GetField<uint32_t>(VT_POSITION, 0);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return text();
            else if constexpr (Index == 1)
                return position();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TEXT) && verifier.VerifyString(text())
                && VerifyField<uint32_t>(verifier, VT_POSITION) && verifier.EndTable();
        }
        InsertTextOpT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(InsertTextOpT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<InsertTextOp> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const InsertTextOpT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct InsertTextOpBuilder {
        typedef InsertTextOp Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_text(flatbuffers::Offset<flatbuffers::String> text) {
            fbb_.AddOffset(InsertTextOp::VT_TEXT, text);
        }
        void add_position(uint32_t position) {
            fbb_.AddElement<uint32_t>(InsertTextOp::VT_POSITION, position, 0);
        }
        explicit InsertTextOpBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<InsertTextOp> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<InsertTextOp>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<InsertTextOp> CreateInsertTextOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::String> text = 0,
        uint32_t position = 0) {
        InsertTextOpBuilder builder_(_fbb);
        builder_.add_position(position);
        builder_.add_text(text);
        return builder_.Finish();
    }

    struct InsertTextOp::Traits {
        using type = InsertTextOp;
        static auto constexpr Create = CreateInsertTextOp;
        static constexpr auto name = "InsertTextOp";
        static constexpr auto fully_qualified_name = "pg.gen.InsertTextOp";
        static constexpr std::array<const char*, 2> field_names = { "text", "position" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    inline flatbuffers::Offset<InsertTextOp>
    CreateInsertTextOpDirect(flatbuffers::FlatBufferBuilder& _fbb, const char* text = nullptr, uint32_t position = 0) {
        auto text__ = text ? _fbb.CreateString(text) : 0;
        return pg::gen::CreateInsertTextOp(_fbb, text__, position);
    }

    flatbuffers::Offset<InsertTextOp> CreateInsertTextOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const InsertTextOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct PrependTextOpT: public flatbuffers::NativeTable {
        typedef PrependTextOp TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.PrependTextOpT";
        }
        std::string text {};
    };

    inline bool operator==(const PrependTextOpT& lhs, const PrependTextOpT& rhs) {
        return (lhs.text == rhs.text);
    }

    inline bool operator!=(const PrependTextOpT& lhs, const PrependTextOpT& rhs) {
        return !(lhs == rhs);
    }

    struct PrependTextOp FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef PrependTextOpT NativeTableType;
        typedef PrependTextOpBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return PrependTextOpTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.PrependTextOp";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TEXT = 4 };
        const flatbuffers::String* _Nullable text() const {
            return GetPointer<const flatbuffers::String*>(VT_TEXT);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return text();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TEXT) && verifier.VerifyString(text())
                && verifier.EndTable();
        }
        PrependTextOpT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(PrependTextOpT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<PrependTextOp> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const PrependTextOpT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct PrependTextOpBuilder {
        typedef PrependTextOp Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_text(flatbuffers::Offset<flatbuffers::String> text) {
            fbb_.AddOffset(PrependTextOp::VT_TEXT, text);
        }
        explicit PrependTextOpBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<PrependTextOp> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<PrependTextOp>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<PrependTextOp>
    CreatePrependTextOp(flatbuffers::FlatBufferBuilder& _fbb, flatbuffers::Offset<flatbuffers::String> text = 0) {
        PrependTextOpBuilder builder_(_fbb);
        builder_.add_text(text);
        return builder_.Finish();
    }

    struct PrependTextOp::Traits {
        using type = PrependTextOp;
        static auto constexpr Create = CreatePrependTextOp;
        static constexpr auto name = "PrependTextOp";
        static constexpr auto fully_qualified_name = "pg.gen.PrependTextOp";
        static constexpr std::array<const char*, 1> field_names = { "text" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    inline flatbuffers::Offset<PrependTextOp>
    CreatePrependTextOpDirect(flatbuffers::FlatBufferBuilder& _fbb, const char* text = nullptr) {
        auto text__ = text ? _fbb.CreateString(text) : 0;
        return pg::gen::CreatePrependTextOp(_fbb, text__);
    }

    flatbuffers::Offset<PrependTextOp> CreatePrependTextOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const PrependTextOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct RemoveTextRangeOpT: public flatbuffers::NativeTable {
        typedef RemoveTextRangeOp TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.RemoveTextRangeOpT";
        }
        uint32_t start = 0;
        uint32_t end = 0;
    };

    inline bool operator==(const RemoveTextRangeOpT& lhs, const RemoveTextRangeOpT& rhs) {
        return (lhs.start == rhs.start) && (lhs.end == rhs.end);
    }

    inline bool operator!=(const RemoveTextRangeOpT& lhs, const RemoveTextRangeOpT& rhs) {
        return !(lhs == rhs);
    }

    struct RemoveTextRangeOp FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef RemoveTextRangeOpT NativeTableType;
        typedef RemoveTextRangeOpBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return RemoveTextRangeOpTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.RemoveTextRangeOp";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_START = 4, VT_END = 6 };
        uint32_t start() const {
            return GetField<uint32_t>(VT_START, 0);
        }
        uint32_t end() const {
            return GetField<uint32_t>(VT_END, 0);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return start();
            else if constexpr (Index == 1)
                return end();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_START)
                && VerifyField<uint32_t>(verifier, VT_END) && verifier.EndTable();
        }
        RemoveTextRangeOpT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(RemoveTextRangeOpT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<RemoveTextRangeOp> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const RemoveTextRangeOpT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct RemoveTextRangeOpBuilder {
        typedef RemoveTextRangeOp Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_start(uint32_t start) {
            fbb_.AddElement<uint32_t>(RemoveTextRangeOp::VT_START, start, 0);
        }
        void add_end(uint32_t end) {
            fbb_.AddElement<uint32_t>(RemoveTextRangeOp::VT_END, end, 0);
        }
        explicit RemoveTextRangeOpBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<RemoveTextRangeOp> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<RemoveTextRangeOp>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<RemoveTextRangeOp>
    CreateRemoveTextRangeOp(flatbuffers::FlatBufferBuilder& _fbb, uint32_t start = 0, uint32_t end = 0) {
        RemoveTextRangeOpBuilder builder_(_fbb);
        builder_.add_end(end);
        builder_.add_start(start);
        return builder_.Finish();
    }

    struct RemoveTextRangeOp::Traits {
        using type = RemoveTextRangeOp;
        static auto constexpr Create = CreateRemoveTextRangeOp;
        static constexpr auto name = "RemoveTextRangeOp";
        static constexpr auto fully_qualified_name = "pg.gen.RemoveTextRangeOp";
        static constexpr std::array<const char*, 2> field_names = { "start", "end" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    flatbuffers::Offset<RemoveTextRangeOp> CreateRemoveTextRangeOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const RemoveTextRangeOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct ReplaceTextOpT: public flatbuffers::NativeTable {
        typedef ReplaceTextOp TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.ReplaceTextOpT";
        }
        std::unique_ptr<pg::gen::ReplaceTextPairT> input {};
    };

    inline bool operator==(const ReplaceTextOpT& lhs, const ReplaceTextOpT& rhs) {
        return (lhs.input == rhs.input);
    }

    inline bool operator!=(const ReplaceTextOpT& lhs, const ReplaceTextOpT& rhs) {
        return !(lhs == rhs);
    }

    struct ReplaceTextOp FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef ReplaceTextOpT NativeTableType;
        typedef ReplaceTextOpBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return ReplaceTextOpTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.ReplaceTextOp";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_INPUT = 4 };
        const pg::gen::ReplaceTextPair* _Nullable input() const {
            return GetPointer<const pg::gen::ReplaceTextPair*>(VT_INPUT);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return input();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_INPUT) && verifier.VerifyTable(input())
                && verifier.EndTable();
        }
        ReplaceTextOpT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(ReplaceTextOpT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<ReplaceTextOp> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const ReplaceTextOpT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct ReplaceTextOpBuilder {
        typedef ReplaceTextOp Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_input(flatbuffers::Offset<pg::gen::ReplaceTextPair> input) {
            fbb_.AddOffset(ReplaceTextOp::VT_INPUT, input);
        }
        explicit ReplaceTextOpBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<ReplaceTextOp> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<ReplaceTextOp>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<ReplaceTextOp>
    CreateReplaceTextOp(flatbuffers::FlatBufferBuilder& _fbb, flatbuffers::Offset<pg::gen::ReplaceTextPair> input = 0) {
        ReplaceTextOpBuilder builder_(_fbb);
        builder_.add_input(input);
        return builder_.Finish();
    }

    struct ReplaceTextOp::Traits {
        using type = ReplaceTextOp;
        static auto constexpr Create = CreateReplaceTextOp;
        static constexpr auto name = "ReplaceTextOp";
        static constexpr auto fully_qualified_name = "pg.gen.ReplaceTextOp";
        static constexpr std::array<const char*, 1> field_names = { "input" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    flatbuffers::Offset<ReplaceTextOp> CreateReplaceTextOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ReplaceTextOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct ReplaceTextMultipleOpT: public flatbuffers::NativeTable {
        typedef ReplaceTextMultipleOp TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.ReplaceTextMultipleOpT";
        }
        std::vector<std::unique_ptr<pg::gen::ReplaceTextPairT>> pairs {};
    };

    inline bool operator==(const ReplaceTextMultipleOpT& lhs, const ReplaceTextMultipleOpT& rhs) {
        return (lhs.pairs == rhs.pairs);
    }

    inline bool operator!=(const ReplaceTextMultipleOpT& lhs, const ReplaceTextMultipleOpT& rhs) {
        return !(lhs == rhs);
    }

    struct ReplaceTextMultipleOp FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef ReplaceTextMultipleOpT NativeTableType;
        typedef ReplaceTextMultipleOpBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return ReplaceTextMultipleOpTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.ReplaceTextMultipleOp";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_PAIRS = 4 };
        const flatbuffers::Vector<flatbuffers::Offset<pg::gen::ReplaceTextPair>>* _Nullable pairs() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pg::gen::ReplaceTextPair>>*>(VT_PAIRS);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return pairs();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_PAIRS) && verifier.VerifyVector(pairs())
                && verifier.VerifyVectorOfTables(pairs()) && verifier.EndTable();
        }
        ReplaceTextMultipleOpT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(ReplaceTextMultipleOpT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<ReplaceTextMultipleOp> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const ReplaceTextMultipleOpT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct ReplaceTextMultipleOpBuilder {
        typedef ReplaceTextMultipleOp Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_pairs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::ReplaceTextPair>>> pairs) {
            fbb_.AddOffset(ReplaceTextMultipleOp::VT_PAIRS, pairs);
        }
        explicit ReplaceTextMultipleOpBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<ReplaceTextMultipleOp> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<ReplaceTextMultipleOp>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<ReplaceTextMultipleOp> CreateReplaceTextMultipleOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::ReplaceTextPair>>> pairs = 0) {
        ReplaceTextMultipleOpBuilder builder_(_fbb);
        builder_.add_pairs(pairs);
        return builder_.Finish();
    }

    struct ReplaceTextMultipleOp::Traits {
        using type = ReplaceTextMultipleOp;
        static auto constexpr Create = CreateReplaceTextMultipleOp;
        static constexpr auto name = "ReplaceTextMultipleOp";
        static constexpr auto fully_qualified_name = "pg.gen.ReplaceTextMultipleOp";
        static constexpr std::array<const char*, 1> field_names = { "pairs" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    inline flatbuffers::Offset<ReplaceTextMultipleOp> CreateReplaceTextMultipleOpDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const std::vector<flatbuffers::Offset<pg::gen::ReplaceTextPair>>* pairs = nullptr) {
        auto pairs__ = pairs ? _fbb.CreateVector<flatbuffers::Offset<pg::gen::ReplaceTextPair>>(*pairs) : 0;
        return pg::gen::CreateReplaceTextMultipleOp(_fbb, pairs__);
    }

    flatbuffers::Offset<ReplaceTextMultipleOp> CreateReplaceTextMultipleOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ReplaceTextMultipleOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct RemoveTextOpT: public flatbuffers::NativeTable {
        typedef RemoveTextOp TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.RemoveTextOpT";
        }
        std::string removal {};
    };

    inline bool operator==(const RemoveTextOpT& lhs, const RemoveTextOpT& rhs) {
        return (lhs.removal == rhs.removal);
    }

    inline bool operator!=(const RemoveTextOpT& lhs, const RemoveTextOpT& rhs) {
        return !(lhs == rhs);
    }

    struct RemoveTextOp FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef RemoveTextOpT NativeTableType;
        typedef RemoveTextOpBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return RemoveTextOpTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.RemoveTextOp";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_REMOVAL = 4 };
        const flatbuffers::String* _Nullable removal() const {
            return GetPointer<const flatbuffers::String*>(VT_REMOVAL);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return removal();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_REMOVAL) && verifier.VerifyString(removal())
                && verifier.EndTable();
        }
        RemoveTextOpT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(RemoveTextOpT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<RemoveTextOp> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const RemoveTextOpT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct RemoveTextOpBuilder {
        typedef RemoveTextOp Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_removal(flatbuffers::Offset<flatbuffers::String> removal) {
            fbb_.AddOffset(RemoveTextOp::VT_REMOVAL, removal);
        }
        explicit RemoveTextOpBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<RemoveTextOp> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<RemoveTextOp>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<RemoveTextOp>
    CreateRemoveTextOp(flatbuffers::FlatBufferBuilder& _fbb, flatbuffers::Offset<flatbuffers::String> removal = 0) {
        RemoveTextOpBuilder builder_(_fbb);
        builder_.add_removal(removal);
        return builder_.Finish();
    }

    struct RemoveTextOp::Traits {
        using type = RemoveTextOp;
        static auto constexpr Create = CreateRemoveTextOp;
        static constexpr auto name = "RemoveTextOp";
        static constexpr auto fully_qualified_name = "pg.gen.RemoveTextOp";
        static constexpr std::array<const char*, 1> field_names = { "removal" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    inline flatbuffers::Offset<RemoveTextOp>
    CreateRemoveTextOpDirect(flatbuffers::FlatBufferBuilder& _fbb, const char* removal = nullptr) {
        auto removal__ = removal ? _fbb.CreateString(removal) : 0;
        return pg::gen::CreateRemoveTextOp(_fbb, removal__);
    }

    flatbuffers::Offset<RemoveTextOp> CreateRemoveTextOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const RemoveTextOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct RemoveTextMultipleOpT: public flatbuffers::NativeTable {
        typedef RemoveTextMultipleOp TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.RemoveTextMultipleOpT";
        }
        std::vector<std::string> removals {};
    };

    inline bool operator==(const RemoveTextMultipleOpT& lhs, const RemoveTextMultipleOpT& rhs) {
        return (lhs.removals == rhs.removals);
    }

    inline bool operator!=(const RemoveTextMultipleOpT& lhs, const RemoveTextMultipleOpT& rhs) {
        return !(lhs == rhs);
    }

    struct RemoveTextMultipleOp FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef RemoveTextMultipleOpT NativeTableType;
        typedef RemoveTextMultipleOpBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return RemoveTextMultipleOpTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.RemoveTextMultipleOp";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_REMOVALS = 4 };
        const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>* _Nullable removals() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>*>(VT_REMOVALS);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return removals();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_REMOVALS)
                && verifier.VerifyVector(removals()) && verifier.VerifyVectorOfStrings(removals())
                && verifier.EndTable();
        }
        RemoveTextMultipleOpT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(RemoveTextMultipleOpT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<RemoveTextMultipleOp> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const RemoveTextMultipleOpT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct RemoveTextMultipleOpBuilder {
        typedef RemoveTextMultipleOp Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_removals(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> removals) {
            fbb_.AddOffset(RemoveTextMultipleOp::VT_REMOVALS, removals);
        }
        explicit RemoveTextMultipleOpBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<RemoveTextMultipleOp> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<RemoveTextMultipleOp>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<RemoveTextMultipleOp> CreateRemoveTextMultipleOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> removals = 0) {
        RemoveTextMultipleOpBuilder builder_(_fbb);
        builder_.add_removals(removals);
        return builder_.Finish();
    }

    struct RemoveTextMultipleOp::Traits {
        using type = RemoveTextMultipleOp;
        static auto constexpr Create = CreateRemoveTextMultipleOp;
        static constexpr auto name = "RemoveTextMultipleOp";
        static constexpr auto fully_qualified_name = "pg.gen.RemoveTextMultipleOp";
        static constexpr std::array<const char*, 1> field_names = { "removals" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    inline flatbuffers::Offset<RemoveTextMultipleOp> CreateRemoveTextMultipleOpDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const std::vector<flatbuffers::Offset<flatbuffers::String>>* removals = nullptr) {
        auto removals__ = removals ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*removals) : 0;
        return pg::gen::CreateRemoveTextMultipleOp(_fbb, removals__);
    }

    flatbuffers::Offset<RemoveTextMultipleOp> CreateRemoveTextMultipleOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const RemoveTextMultipleOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct TextModificationKindT: public flatbuffers::NativeTable {
        typedef TextModificationKind TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.TextModificationKindT";
        }
        pg::gen::TextModificationKind_::KindUnionUnion kind {};
    };

    inline bool operator==(const TextModificationKindT& lhs, const TextModificationKindT& rhs) {
        return (lhs.kind == rhs.kind);
    }

    inline bool operator!=(const TextModificationKindT& lhs, const TextModificationKindT& rhs) {
        return !(lhs == rhs);
    }

    struct TextModificationKind FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef TextModificationKindT NativeTableType;
        typedef TextModificationKindBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return TextModificationKindTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.TextModificationKind";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_KIND_TYPE = 4, VT_KIND = 6 };
        pg::gen::TextModificationKind_::KindUnion kind_type() const {
            return static_cast<pg::gen::TextModificationKind_::KindUnion>(GetField<uint8_t>(VT_KIND_TYPE, 0));
        }
        const void* _Nullable kind() const {
            return GetPointer<const void*>(VT_KIND);
        }
        template<typename T>
        const T* _Nullable kind_as() const;
        const pg::gen::AppendTextOp* _Nullable kind_as_pg_gen_AppendTextOp() const {
            return kind_type() == pg::gen::TextModificationKind_::KindUnion::pg_gen_AppendTextOp
                ? static_cast<const pg::gen::AppendTextOp*>(kind())
                : nullptr;
        }
        const pg::gen::InsertTextOp* _Nullable kind_as_pg_gen_InsertTextOp() const {
            return kind_type() == pg::gen::TextModificationKind_::KindUnion::pg_gen_InsertTextOp
                ? static_cast<const pg::gen::InsertTextOp*>(kind())
                : nullptr;
        }
        const pg::gen::PrependTextOp* _Nullable kind_as_pg_gen_PrependTextOp() const {
            return kind_type() == pg::gen::TextModificationKind_::KindUnion::pg_gen_PrependTextOp
                ? static_cast<const pg::gen::PrependTextOp*>(kind())
                : nullptr;
        }
        const pg::gen::RemoveTextRangeOp* _Nullable kind_as_pg_gen_RemoveTextRangeOp() const {
            return kind_type() == pg::gen::TextModificationKind_::KindUnion::pg_gen_RemoveTextRangeOp
                ? static_cast<const pg::gen::RemoveTextRangeOp*>(kind())
                : nullptr;
        }
        const pg::gen::ReplaceTextOp* _Nullable kind_as_pg_gen_ReplaceTextOp() const {
            return kind_type() == pg::gen::TextModificationKind_::KindUnion::pg_gen_ReplaceTextOp
                ? static_cast<const pg::gen::ReplaceTextOp*>(kind())
                : nullptr;
        }
        const pg::gen::ReplaceTextMultipleOp* _Nullable kind_as_pg_gen_ReplaceTextMultipleOp() const {
            return kind_type() == pg::gen::TextModificationKind_::KindUnion::pg_gen_ReplaceTextMultipleOp
                ? static_cast<const pg::gen::ReplaceTextMultipleOp*>(kind())
                : nullptr;
        }
        const pg::gen::RemoveTextOp* _Nullable kind_as_pg_gen_RemoveTextOp() const {
            return kind_type() == pg::gen::TextModificationKind_::KindUnion::pg_gen_RemoveTextOp
                ? static_cast<const pg::gen::RemoveTextOp*>(kind())
                : nullptr;
        }
        const pg::gen::RemoveTextMultipleOp* _Nullable kind_as_pg_gen_RemoveTextMultipleOp() const {
            return kind_type() == pg::gen::TextModificationKind_::KindUnion::pg_gen_RemoveTextMultipleOp
                ? static_cast<const pg::gen::RemoveTextMultipleOp*>(kind())
                : nullptr;
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return kind_type();
            else if constexpr (Index == 1)
                return kind();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_KIND_TYPE)
                && VerifyOffset(verifier, VT_KIND) && VerifyKindUnion(verifier, kind(), kind_type())
                && verifier.EndTable();
        }
        TextModificationKindT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(TextModificationKindT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<TextModificationKind> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const TextModificationKindT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    template<>
    inline const pg::gen::AppendTextOp* TextModificationKind::kind_as<pg::gen::AppendTextOp>() const {
        return kind_as_pg_gen_AppendTextOp();
    }

    template<>
    inline const pg::gen::InsertTextOp* TextModificationKind::kind_as<pg::gen::InsertTextOp>() const {
        return kind_as_pg_gen_InsertTextOp();
    }

    template<>
    inline const pg::gen::PrependTextOp* TextModificationKind::kind_as<pg::gen::PrependTextOp>() const {
        return kind_as_pg_gen_PrependTextOp();
    }

    template<>
    inline const pg::gen::RemoveTextRangeOp* TextModificationKind::kind_as<pg::gen::RemoveTextRangeOp>() const {
        return kind_as_pg_gen_RemoveTextRangeOp();
    }

    template<>
    inline const pg::gen::ReplaceTextOp* TextModificationKind::kind_as<pg::gen::ReplaceTextOp>() const {
        return kind_as_pg_gen_ReplaceTextOp();
    }

    template<>
    inline const pg::gen::ReplaceTextMultipleOp* TextModificationKind::kind_as<pg::gen::ReplaceTextMultipleOp>() const {
        return kind_as_pg_gen_ReplaceTextMultipleOp();
    }

    template<>
    inline const pg::gen::RemoveTextOp* TextModificationKind::kind_as<pg::gen::RemoveTextOp>() const {
        return kind_as_pg_gen_RemoveTextOp();
    }

    template<>
    inline const pg::gen::RemoveTextMultipleOp* TextModificationKind::kind_as<pg::gen::RemoveTextMultipleOp>() const {
        return kind_as_pg_gen_RemoveTextMultipleOp();
    }

    struct TextModificationKindBuilder {
        typedef TextModificationKind Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_kind_type(pg::gen::TextModificationKind_::KindUnion kind_type) {
            fbb_.AddElement<uint8_t>(TextModificationKind::VT_KIND_TYPE, static_cast<uint8_t>(kind_type), 0);
        }
        void add_kind(flatbuffers::Offset<void> kind) {
            fbb_.AddOffset(TextModificationKind::VT_KIND, kind);
        }
        explicit TextModificationKindBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<TextModificationKind> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<TextModificationKind>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<TextModificationKind> CreateTextModificationKind(
        flatbuffers::FlatBufferBuilder& _fbb,
        pg::gen::TextModificationKind_::KindUnion kind_type = pg::gen::TextModificationKind_::KindUnion::NONE,
        flatbuffers::Offset<void> kind = 0) {
        TextModificationKindBuilder builder_(_fbb);
        builder_.add_kind(kind);
        builder_.add_kind_type(kind_type);
        return builder_.Finish();
    }

    struct TextModificationKind::Traits {
        using type = TextModificationKind;
        static auto constexpr Create = CreateTextModificationKind;
        static constexpr auto name = "TextModificationKind";
        static constexpr auto fully_qualified_name = "pg.gen.TextModificationKind";
        static constexpr std::array<const char*, 2> field_names = { "kind_type", "kind" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    flatbuffers::Offset<TextModificationKind> CreateTextModificationKind(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextModificationKindT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct TextMatchesQueryT: public flatbuffers::NativeTable {
        typedef TextMatchesQuery TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.TextMatchesQueryT";
        }
        std::string text {};
        bool case_sensitive = false;
    };

    inline bool operator==(const TextMatchesQueryT& lhs, const TextMatchesQueryT& rhs) {
        return (lhs.text == rhs.text) && (lhs.case_sensitive == rhs.case_sensitive);
    }

    inline bool operator!=(const TextMatchesQueryT& lhs, const TextMatchesQueryT& rhs) {
        return !(lhs == rhs);
    }

    struct TextMatchesQuery FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef TextMatchesQueryT NativeTableType;
        typedef TextMatchesQueryBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return TextMatchesQueryTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.TextMatchesQuery";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TEXT = 4, VT_CASE_SENSITIVE = 6 };
        const flatbuffers::String* _Nullable text() const {
            return GetPointer<const flatbuffers::String*>(VT_TEXT);
        }
        bool case_sensitive() const {
            return GetField<uint8_t>(VT_CASE_SENSITIVE, 0) != 0;
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return text();
            else if constexpr (Index == 1)
                return case_sensitive();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TEXT) && verifier.VerifyString(text())
                && VerifyField<uint8_t>(verifier, VT_CASE_SENSITIVE) && verifier.EndTable();
        }
        TextMatchesQueryT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(TextMatchesQueryT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<TextMatchesQuery> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const TextMatchesQueryT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct TextMatchesQueryBuilder {
        typedef TextMatchesQuery Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_text(flatbuffers::Offset<flatbuffers::String> text) {
            fbb_.AddOffset(TextMatchesQuery::VT_TEXT, text);
        }
        void add_case_sensitive(bool case_sensitive) {
            fbb_.AddElement<uint8_t>(TextMatchesQuery::VT_CASE_SENSITIVE, static_cast<uint8_t>(case_sensitive), 0);
        }
        explicit TextMatchesQueryBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<TextMatchesQuery> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<TextMatchesQuery>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<TextMatchesQuery> CreateTextMatchesQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::String> text = 0,
        bool case_sensitive = false) {
        TextMatchesQueryBuilder builder_(_fbb);
        builder_.add_text(text);
        builder_.add_case_sensitive(case_sensitive);
        return builder_.Finish();
    }

    struct TextMatchesQuery::Traits {
        using type = TextMatchesQuery;
        static auto constexpr Create = CreateTextMatchesQuery;
        static constexpr auto name = "TextMatchesQuery";
        static constexpr auto fully_qualified_name = "pg.gen.TextMatchesQuery";
        static constexpr std::array<const char*, 2> field_names = { "text", "case_sensitive" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    inline flatbuffers::Offset<TextMatchesQuery> CreateTextMatchesQueryDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const char* text = nullptr,
        bool case_sensitive = false) {
        auto text__ = text ? _fbb.CreateString(text) : 0;
        return pg::gen::CreateTextMatchesQuery(_fbb, text__, case_sensitive);
    }

    flatbuffers::Offset<TextMatchesQuery> CreateTextMatchesQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextMatchesQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct TextContainsQueryT: public flatbuffers::NativeTable {
        typedef TextContainsQuery TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.TextContainsQueryT";
        }
        std::string text {};
        bool case_sensitive = false;
    };

    inline bool operator==(const TextContainsQueryT& lhs, const TextContainsQueryT& rhs) {
        return (lhs.text == rhs.text) && (lhs.case_sensitive == rhs.case_sensitive);
    }

    inline bool operator!=(const TextContainsQueryT& lhs, const TextContainsQueryT& rhs) {
        return !(lhs == rhs);
    }

    struct TextContainsQuery FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef TextContainsQueryT NativeTableType;
        typedef TextContainsQueryBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return TextContainsQueryTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.TextContainsQuery";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TEXT = 4, VT_CASE_SENSITIVE = 6 };
        const flatbuffers::String* _Nullable text() const {
            return GetPointer<const flatbuffers::String*>(VT_TEXT);
        }
        bool case_sensitive() const {
            return GetField<uint8_t>(VT_CASE_SENSITIVE, 0) != 0;
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return text();
            else if constexpr (Index == 1)
                return case_sensitive();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TEXT) && verifier.VerifyString(text())
                && VerifyField<uint8_t>(verifier, VT_CASE_SENSITIVE) && verifier.EndTable();
        }
        TextContainsQueryT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(TextContainsQueryT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<TextContainsQuery> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const TextContainsQueryT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct TextContainsQueryBuilder {
        typedef TextContainsQuery Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_text(flatbuffers::Offset<flatbuffers::String> text) {
            fbb_.AddOffset(TextContainsQuery::VT_TEXT, text);
        }
        void add_case_sensitive(bool case_sensitive) {
            fbb_.AddElement<uint8_t>(TextContainsQuery::VT_CASE_SENSITIVE, static_cast<uint8_t>(case_sensitive), 0);
        }
        explicit TextContainsQueryBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<TextContainsQuery> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<TextContainsQuery>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<TextContainsQuery> CreateTextContainsQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::String> text = 0,
        bool case_sensitive = false) {
        TextContainsQueryBuilder builder_(_fbb);
        builder_.add_text(text);
        builder_.add_case_sensitive(case_sensitive);
        return builder_.Finish();
    }

    struct TextContainsQuery::Traits {
        using type = TextContainsQuery;
        static auto constexpr Create = CreateTextContainsQuery;
        static constexpr auto name = "TextContainsQuery";
        static constexpr auto fully_qualified_name = "pg.gen.TextContainsQuery";
        static constexpr std::array<const char*, 2> field_names = { "text", "case_sensitive" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    inline flatbuffers::Offset<TextContainsQuery> CreateTextContainsQueryDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const char* text = nullptr,
        bool case_sensitive = false) {
        auto text__ = text ? _fbb.CreateString(text) : 0;
        return pg::gen::CreateTextContainsQuery(_fbb, text__, case_sensitive);
    }

    flatbuffers::Offset<TextContainsQuery> CreateTextContainsQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextContainsQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct TextStartsWithQueryT: public flatbuffers::NativeTable {
        typedef TextStartsWithQuery TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.TextStartsWithQueryT";
        }
        std::string text {};
        bool case_sensitive = false;
    };

    inline bool operator==(const TextStartsWithQueryT& lhs, const TextStartsWithQueryT& rhs) {
        return (lhs.text == rhs.text) && (lhs.case_sensitive == rhs.case_sensitive);
    }

    inline bool operator!=(const TextStartsWithQueryT& lhs, const TextStartsWithQueryT& rhs) {
        return !(lhs == rhs);
    }

    struct TextStartsWithQuery FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef TextStartsWithQueryT NativeTableType;
        typedef TextStartsWithQueryBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return TextStartsWithQueryTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.TextStartsWithQuery";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TEXT = 4, VT_CASE_SENSITIVE = 6 };
        const flatbuffers::String* _Nullable text() const {
            return GetPointer<const flatbuffers::String*>(VT_TEXT);
        }
        bool case_sensitive() const {
            return GetField<uint8_t>(VT_CASE_SENSITIVE, 0) != 0;
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return text();
            else if constexpr (Index == 1)
                return case_sensitive();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TEXT) && verifier.VerifyString(text())
                && VerifyField<uint8_t>(verifier, VT_CASE_SENSITIVE) && verifier.EndTable();
        }
        TextStartsWithQueryT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(TextStartsWithQueryT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<TextStartsWithQuery> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const TextStartsWithQueryT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct TextStartsWithQueryBuilder {
        typedef TextStartsWithQuery Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_text(flatbuffers::Offset<flatbuffers::String> text) {
            fbb_.AddOffset(TextStartsWithQuery::VT_TEXT, text);
        }
        void add_case_sensitive(bool case_sensitive) {
            fbb_.AddElement<uint8_t>(TextStartsWithQuery::VT_CASE_SENSITIVE, static_cast<uint8_t>(case_sensitive), 0);
        }
        explicit TextStartsWithQueryBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<TextStartsWithQuery> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<TextStartsWithQuery>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<TextStartsWithQuery> CreateTextStartsWithQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::String> text = 0,
        bool case_sensitive = false) {
        TextStartsWithQueryBuilder builder_(_fbb);
        builder_.add_text(text);
        builder_.add_case_sensitive(case_sensitive);
        return builder_.Finish();
    }

    struct TextStartsWithQuery::Traits {
        using type = TextStartsWithQuery;
        static auto constexpr Create = CreateTextStartsWithQuery;
        static constexpr auto name = "TextStartsWithQuery";
        static constexpr auto fully_qualified_name = "pg.gen.TextStartsWithQuery";
        static constexpr std::array<const char*, 2> field_names = { "text", "case_sensitive" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    inline flatbuffers::Offset<TextStartsWithQuery> CreateTextStartsWithQueryDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const char* text = nullptr,
        bool case_sensitive = false) {
        auto text__ = text ? _fbb.CreateString(text) : 0;
        return pg::gen::CreateTextStartsWithQuery(_fbb, text__, case_sensitive);
    }

    flatbuffers::Offset<TextStartsWithQuery> CreateTextStartsWithQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextStartsWithQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct TextEndsWithQueryT: public flatbuffers::NativeTable {
        typedef TextEndsWithQuery TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.TextEndsWithQueryT";
        }
        std::string text {};
        bool case_sensitive = false;
    };

    inline bool operator==(const TextEndsWithQueryT& lhs, const TextEndsWithQueryT& rhs) {
        return (lhs.text == rhs.text) && (lhs.case_sensitive == rhs.case_sensitive);
    }

    inline bool operator!=(const TextEndsWithQueryT& lhs, const TextEndsWithQueryT& rhs) {
        return !(lhs == rhs);
    }

    struct TextEndsWithQuery FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef TextEndsWithQueryT NativeTableType;
        typedef TextEndsWithQueryBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return TextEndsWithQueryTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.TextEndsWithQuery";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TEXT = 4, VT_CASE_SENSITIVE = 6 };
        const flatbuffers::String* _Nullable text() const {
            return GetPointer<const flatbuffers::String*>(VT_TEXT);
        }
        bool case_sensitive() const {
            return GetField<uint8_t>(VT_CASE_SENSITIVE, 0) != 0;
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return text();
            else if constexpr (Index == 1)
                return case_sensitive();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TEXT) && verifier.VerifyString(text())
                && VerifyField<uint8_t>(verifier, VT_CASE_SENSITIVE) && verifier.EndTable();
        }
        TextEndsWithQueryT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(TextEndsWithQueryT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<TextEndsWithQuery> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const TextEndsWithQueryT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct TextEndsWithQueryBuilder {
        typedef TextEndsWithQuery Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_text(flatbuffers::Offset<flatbuffers::String> text) {
            fbb_.AddOffset(TextEndsWithQuery::VT_TEXT, text);
        }
        void add_case_sensitive(bool case_sensitive) {
            fbb_.AddElement<uint8_t>(TextEndsWithQuery::VT_CASE_SENSITIVE, static_cast<uint8_t>(case_sensitive), 0);
        }
        explicit TextEndsWithQueryBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<TextEndsWithQuery> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<TextEndsWithQuery>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<TextEndsWithQuery> CreateTextEndsWithQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::String> text = 0,
        bool case_sensitive = false) {
        TextEndsWithQueryBuilder builder_(_fbb);
        builder_.add_text(text);
        builder_.add_case_sensitive(case_sensitive);
        return builder_.Finish();
    }

    struct TextEndsWithQuery::Traits {
        using type = TextEndsWithQuery;
        static auto constexpr Create = CreateTextEndsWithQuery;
        static constexpr auto name = "TextEndsWithQuery";
        static constexpr auto fully_qualified_name = "pg.gen.TextEndsWithQuery";
        static constexpr std::array<const char*, 2> field_names = { "text", "case_sensitive" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    inline flatbuffers::Offset<TextEndsWithQuery> CreateTextEndsWithQueryDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const char* text = nullptr,
        bool case_sensitive = false) {
        auto text__ = text ? _fbb.CreateString(text) : 0;
        return pg::gen::CreateTextEndsWithQuery(_fbb, text__, case_sensitive);
    }

    flatbuffers::Offset<TextEndsWithQuery> CreateTextEndsWithQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextEndsWithQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct TextSearchKindT: public flatbuffers::NativeTable {
        typedef TextSearchKind TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.TextSearchKindT";
        }
        pg::gen::TextSearchKind_::KindUnionUnion kind {};
    };

    inline bool operator==(const TextSearchKindT& lhs, const TextSearchKindT& rhs) {
        return (lhs.kind == rhs.kind);
    }

    inline bool operator!=(const TextSearchKindT& lhs, const TextSearchKindT& rhs) {
        return !(lhs == rhs);
    }

    struct TextSearchKind FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef TextSearchKindT NativeTableType;
        typedef TextSearchKindBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return TextSearchKindTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.TextSearchKind";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_KIND_TYPE = 4, VT_KIND = 6 };
        pg::gen::TextSearchKind_::KindUnion kind_type() const {
            return static_cast<pg::gen::TextSearchKind_::KindUnion>(GetField<uint8_t>(VT_KIND_TYPE, 0));
        }
        const void* _Nullable kind() const {
            return GetPointer<const void*>(VT_KIND);
        }
        template<typename T>
        const T* _Nullable kind_as() const;
        const pg::gen::TextMatchesQuery* _Nullable kind_as_pg_gen_TextMatchesQuery() const {
            return kind_type() == pg::gen::TextSearchKind_::KindUnion::pg_gen_TextMatchesQuery
                ? static_cast<const pg::gen::TextMatchesQuery*>(kind())
                : nullptr;
        }
        const pg::gen::TextContainsQuery* _Nullable kind_as_pg_gen_TextContainsQuery() const {
            return kind_type() == pg::gen::TextSearchKind_::KindUnion::pg_gen_TextContainsQuery
                ? static_cast<const pg::gen::TextContainsQuery*>(kind())
                : nullptr;
        }
        const pg::gen::TextStartsWithQuery* _Nullable kind_as_pg_gen_TextStartsWithQuery() const {
            return kind_type() == pg::gen::TextSearchKind_::KindUnion::pg_gen_TextStartsWithQuery
                ? static_cast<const pg::gen::TextStartsWithQuery*>(kind())
                : nullptr;
        }
        const pg::gen::TextEndsWithQuery* _Nullable kind_as_pg_gen_TextEndsWithQuery() const {
            return kind_type() == pg::gen::TextSearchKind_::KindUnion::pg_gen_TextEndsWithQuery
                ? static_cast<const pg::gen::TextEndsWithQuery*>(kind())
                : nullptr;
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return kind_type();
            else if constexpr (Index == 1)
                return kind();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_KIND_TYPE)
                && VerifyOffset(verifier, VT_KIND) && VerifyKindUnion(verifier, kind(), kind_type())
                && verifier.EndTable();
        }
        TextSearchKindT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(TextSearchKindT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<TextSearchKind> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const TextSearchKindT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    template<>
    inline const pg::gen::TextMatchesQuery* TextSearchKind::kind_as<pg::gen::TextMatchesQuery>() const {
        return kind_as_pg_gen_TextMatchesQuery();
    }

    template<>
    inline const pg::gen::TextContainsQuery* TextSearchKind::kind_as<pg::gen::TextContainsQuery>() const {
        return kind_as_pg_gen_TextContainsQuery();
    }

    template<>
    inline const pg::gen::TextStartsWithQuery* TextSearchKind::kind_as<pg::gen::TextStartsWithQuery>() const {
        return kind_as_pg_gen_TextStartsWithQuery();
    }

    template<>
    inline const pg::gen::TextEndsWithQuery* TextSearchKind::kind_as<pg::gen::TextEndsWithQuery>() const {
        return kind_as_pg_gen_TextEndsWithQuery();
    }

    struct TextSearchKindBuilder {
        typedef TextSearchKind Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_kind_type(pg::gen::TextSearchKind_::KindUnion kind_type) {
            fbb_.AddElement<uint8_t>(TextSearchKind::VT_KIND_TYPE, static_cast<uint8_t>(kind_type), 0);
        }
        void add_kind(flatbuffers::Offset<void> kind) {
            fbb_.AddOffset(TextSearchKind::VT_KIND, kind);
        }
        explicit TextSearchKindBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<TextSearchKind> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<TextSearchKind>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<TextSearchKind> CreateTextSearchKind(
        flatbuffers::FlatBufferBuilder& _fbb,
        pg::gen::TextSearchKind_::KindUnion kind_type = pg::gen::TextSearchKind_::KindUnion::NONE,
        flatbuffers::Offset<void> kind = 0) {
        TextSearchKindBuilder builder_(_fbb);
        builder_.add_kind(kind);
        builder_.add_kind_type(kind_type);
        return builder_.Finish();
    }

    struct TextSearchKind::Traits {
        using type = TextSearchKind;
        static auto constexpr Create = CreateTextSearchKind;
        static constexpr auto name = "TextSearchKind";
        static constexpr auto fully_qualified_name = "pg.gen.TextSearchKind";
        static constexpr std::array<const char*, 2> field_names = { "kind_type", "kind" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    flatbuffers::Offset<TextSearchKind> CreateTextSearchKind(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextSearchKindT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct BeforeDateQueryT: public flatbuffers::NativeTable {
        typedef BeforeDateQuery TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.BeforeDateQueryT";
        }
        std::unique_ptr<pg::gen::TimestampT> date {};
    };

    inline bool operator==(const BeforeDateQueryT& lhs, const BeforeDateQueryT& rhs) {
        return (lhs.date == rhs.date);
    }

    inline bool operator!=(const BeforeDateQueryT& lhs, const BeforeDateQueryT& rhs) {
        return !(lhs == rhs);
    }

    struct BeforeDateQuery FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef BeforeDateQueryT NativeTableType;
        typedef BeforeDateQueryBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return BeforeDateQueryTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.BeforeDateQuery";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_DATE = 4 };
        const pg::gen::Timestamp* _Nullable date() const {
            return GetPointer<const pg::gen::Timestamp*>(VT_DATE);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return date();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_DATE) && verifier.VerifyTable(date())
                && verifier.EndTable();
        }
        BeforeDateQueryT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(BeforeDateQueryT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<BeforeDateQuery> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const BeforeDateQueryT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct BeforeDateQueryBuilder {
        typedef BeforeDateQuery Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_date(flatbuffers::Offset<pg::gen::Timestamp> date) {
            fbb_.AddOffset(BeforeDateQuery::VT_DATE, date);
        }
        explicit BeforeDateQueryBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<BeforeDateQuery> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<BeforeDateQuery>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<BeforeDateQuery>
    CreateBeforeDateQuery(flatbuffers::FlatBufferBuilder& _fbb, flatbuffers::Offset<pg::gen::Timestamp> date = 0) {
        BeforeDateQueryBuilder builder_(_fbb);
        builder_.add_date(date);
        return builder_.Finish();
    }

    struct BeforeDateQuery::Traits {
        using type = BeforeDateQuery;
        static auto constexpr Create = CreateBeforeDateQuery;
        static constexpr auto name = "BeforeDateQuery";
        static constexpr auto fully_qualified_name = "pg.gen.BeforeDateQuery";
        static constexpr std::array<const char*, 1> field_names = { "date" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    flatbuffers::Offset<BeforeDateQuery> CreateBeforeDateQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        const BeforeDateQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct AfterDateQueryT: public flatbuffers::NativeTable {
        typedef AfterDateQuery TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.AfterDateQueryT";
        }
        std::unique_ptr<pg::gen::TimestampT> date {};
    };

    inline bool operator==(const AfterDateQueryT& lhs, const AfterDateQueryT& rhs) {
        return (lhs.date == rhs.date);
    }

    inline bool operator!=(const AfterDateQueryT& lhs, const AfterDateQueryT& rhs) {
        return !(lhs == rhs);
    }

    struct AfterDateQuery FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef AfterDateQueryT NativeTableType;
        typedef AfterDateQueryBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return AfterDateQueryTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.AfterDateQuery";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_DATE = 4 };
        const pg::gen::Timestamp* _Nullable date() const {
            return GetPointer<const pg::gen::Timestamp*>(VT_DATE);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return date();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_DATE) && verifier.VerifyTable(date())
                && verifier.EndTable();
        }
        AfterDateQueryT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(AfterDateQueryT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<AfterDateQuery> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const AfterDateQueryT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct AfterDateQueryBuilder {
        typedef AfterDateQuery Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_date(flatbuffers::Offset<pg::gen::Timestamp> date) {
            fbb_.AddOffset(AfterDateQuery::VT_DATE, date);
        }
        explicit AfterDateQueryBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<AfterDateQuery> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<AfterDateQuery>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<AfterDateQuery>
    CreateAfterDateQuery(flatbuffers::FlatBufferBuilder& _fbb, flatbuffers::Offset<pg::gen::Timestamp> date = 0) {
        AfterDateQueryBuilder builder_(_fbb);
        builder_.add_date(date);
        return builder_.Finish();
    }

    struct AfterDateQuery::Traits {
        using type = AfterDateQuery;
        static auto constexpr Create = CreateAfterDateQuery;
        static constexpr auto name = "AfterDateQuery";
        static constexpr auto fully_qualified_name = "pg.gen.AfterDateQuery";
        static constexpr std::array<const char*, 1> field_names = { "date" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    flatbuffers::Offset<AfterDateQuery> CreateAfterDateQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        const AfterDateQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct InDateRangeQueryT: public flatbuffers::NativeTable {
        typedef InDateRangeQuery TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.InDateRangeQueryT";
        }
        std::unique_ptr<pg::gen::TimestampT> start {};
        std::unique_ptr<pg::gen::TimestampT> end {};
    };

    inline bool operator==(const InDateRangeQueryT& lhs, const InDateRangeQueryT& rhs) {
        return (lhs.start == rhs.start) && (lhs.end == rhs.end);
    }

    inline bool operator!=(const InDateRangeQueryT& lhs, const InDateRangeQueryT& rhs) {
        return !(lhs == rhs);
    }

    struct InDateRangeQuery FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef InDateRangeQueryT NativeTableType;
        typedef InDateRangeQueryBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return InDateRangeQueryTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.InDateRangeQuery";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_START = 4, VT_END = 6 };
        const pg::gen::Timestamp* _Nullable start() const {
            return GetPointer<const pg::gen::Timestamp*>(VT_START);
        }
        const pg::gen::Timestamp* _Nullable end() const {
            return GetPointer<const pg::gen::Timestamp*>(VT_END);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return start();
            else if constexpr (Index == 1)
                return end();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_START) && verifier.VerifyTable(start())
                && VerifyOffset(verifier, VT_END) && verifier.VerifyTable(end()) && verifier.EndTable();
        }
        InDateRangeQueryT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(InDateRangeQueryT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<InDateRangeQuery> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const InDateRangeQueryT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct InDateRangeQueryBuilder {
        typedef InDateRangeQuery Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_start(flatbuffers::Offset<pg::gen::Timestamp> start) {
            fbb_.AddOffset(InDateRangeQuery::VT_START, start);
        }
        void add_end(flatbuffers::Offset<pg::gen::Timestamp> end) {
            fbb_.AddOffset(InDateRangeQuery::VT_END, end);
        }
        explicit InDateRangeQueryBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<InDateRangeQuery> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<InDateRangeQuery>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<InDateRangeQuery> CreateInDateRangeQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<pg::gen::Timestamp> start = 0,
        flatbuffers::Offset<pg::gen::Timestamp> end = 0) {
        InDateRangeQueryBuilder builder_(_fbb);
        builder_.add_end(end);
        builder_.add_start(start);
        return builder_.Finish();
    }

    struct InDateRangeQuery::Traits {
        using type = InDateRangeQuery;
        static auto constexpr Create = CreateInDateRangeQuery;
        static constexpr auto name = "InDateRangeQuery";
        static constexpr auto fully_qualified_name = "pg.gen.InDateRangeQuery";
        static constexpr std::array<const char*, 2> field_names = { "start", "end" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    flatbuffers::Offset<InDateRangeQuery> CreateInDateRangeQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        const InDateRangeQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct NotInDateRangeQueryT: public flatbuffers::NativeTable {
        typedef NotInDateRangeQuery TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.NotInDateRangeQueryT";
        }
        std::unique_ptr<pg::gen::TimestampT> start {};
        std::unique_ptr<pg::gen::TimestampT> end {};
    };

    inline bool operator==(const NotInDateRangeQueryT& lhs, const NotInDateRangeQueryT& rhs) {
        return (lhs.start == rhs.start) && (lhs.end == rhs.end);
    }

    inline bool operator!=(const NotInDateRangeQueryT& lhs, const NotInDateRangeQueryT& rhs) {
        return !(lhs == rhs);
    }

    struct NotInDateRangeQuery FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef NotInDateRangeQueryT NativeTableType;
        typedef NotInDateRangeQueryBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return NotInDateRangeQueryTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.NotInDateRangeQuery";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_START = 4, VT_END = 6 };
        const pg::gen::Timestamp* _Nullable start() const {
            return GetPointer<const pg::gen::Timestamp*>(VT_START);
        }
        const pg::gen::Timestamp* _Nullable end() const {
            return GetPointer<const pg::gen::Timestamp*>(VT_END);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return start();
            else if constexpr (Index == 1)
                return end();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_START) && verifier.VerifyTable(start())
                && VerifyOffset(verifier, VT_END) && verifier.VerifyTable(end()) && verifier.EndTable();
        }
        NotInDateRangeQueryT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(NotInDateRangeQueryT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<NotInDateRangeQuery> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const NotInDateRangeQueryT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct NotInDateRangeQueryBuilder {
        typedef NotInDateRangeQuery Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_start(flatbuffers::Offset<pg::gen::Timestamp> start) {
            fbb_.AddOffset(NotInDateRangeQuery::VT_START, start);
        }
        void add_end(flatbuffers::Offset<pg::gen::Timestamp> end) {
            fbb_.AddOffset(NotInDateRangeQuery::VT_END, end);
        }
        explicit NotInDateRangeQueryBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<NotInDateRangeQuery> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<NotInDateRangeQuery>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<NotInDateRangeQuery> CreateNotInDateRangeQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<pg::gen::Timestamp> start = 0,
        flatbuffers::Offset<pg::gen::Timestamp> end = 0) {
        NotInDateRangeQueryBuilder builder_(_fbb);
        builder_.add_end(end);
        builder_.add_start(start);
        return builder_.Finish();
    }

    struct NotInDateRangeQuery::Traits {
        using type = NotInDateRangeQuery;
        static auto constexpr Create = CreateNotInDateRangeQuery;
        static constexpr auto name = "NotInDateRangeQuery";
        static constexpr auto fully_qualified_name = "pg.gen.NotInDateRangeQuery";
        static constexpr std::array<const char*, 2> field_names = { "start", "end" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    flatbuffers::Offset<NotInDateRangeQuery> CreateNotInDateRangeQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NotInDateRangeQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct DateSearchKindT: public flatbuffers::NativeTable {
        typedef DateSearchKind TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.DateSearchKindT";
        }
        pg::gen::DateSearchKind_::KindUnionUnion kind {};
    };

    inline bool operator==(const DateSearchKindT& lhs, const DateSearchKindT& rhs) {
        return (lhs.kind == rhs.kind);
    }

    inline bool operator!=(const DateSearchKindT& lhs, const DateSearchKindT& rhs) {
        return !(lhs == rhs);
    }

    struct DateSearchKind FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef DateSearchKindT NativeTableType;
        typedef DateSearchKindBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return DateSearchKindTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.DateSearchKind";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_KIND_TYPE = 4, VT_KIND = 6 };
        pg::gen::DateSearchKind_::KindUnion kind_type() const {
            return static_cast<pg::gen::DateSearchKind_::KindUnion>(GetField<uint8_t>(VT_KIND_TYPE, 0));
        }
        const void* _Nullable kind() const {
            return GetPointer<const void*>(VT_KIND);
        }
        template<typename T>
        const T* _Nullable kind_as() const;
        const pg::gen::BeforeDateQuery* _Nullable kind_as_pg_gen_BeforeDateQuery() const {
            return kind_type() == pg::gen::DateSearchKind_::KindUnion::pg_gen_BeforeDateQuery
                ? static_cast<const pg::gen::BeforeDateQuery*>(kind())
                : nullptr;
        }
        const pg::gen::AfterDateQuery* _Nullable kind_as_pg_gen_AfterDateQuery() const {
            return kind_type() == pg::gen::DateSearchKind_::KindUnion::pg_gen_AfterDateQuery
                ? static_cast<const pg::gen::AfterDateQuery*>(kind())
                : nullptr;
        }
        const pg::gen::InDateRangeQuery* _Nullable kind_as_pg_gen_InDateRangeQuery() const {
            return kind_type() == pg::gen::DateSearchKind_::KindUnion::pg_gen_InDateRangeQuery
                ? static_cast<const pg::gen::InDateRangeQuery*>(kind())
                : nullptr;
        }
        const pg::gen::NotInDateRangeQuery* _Nullable kind_as_pg_gen_NotInDateRangeQuery() const {
            return kind_type() == pg::gen::DateSearchKind_::KindUnion::pg_gen_NotInDateRangeQuery
                ? static_cast<const pg::gen::NotInDateRangeQuery*>(kind())
                : nullptr;
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return kind_type();
            else if constexpr (Index == 1)
                return kind();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_KIND_TYPE)
                && VerifyOffset(verifier, VT_KIND) && VerifyKindUnion(verifier, kind(), kind_type())
                && verifier.EndTable();
        }
        DateSearchKindT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(DateSearchKindT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<DateSearchKind> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const DateSearchKindT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    template<>
    inline const pg::gen::BeforeDateQuery* DateSearchKind::kind_as<pg::gen::BeforeDateQuery>() const {
        return kind_as_pg_gen_BeforeDateQuery();
    }

    template<>
    inline const pg::gen::AfterDateQuery* DateSearchKind::kind_as<pg::gen::AfterDateQuery>() const {
        return kind_as_pg_gen_AfterDateQuery();
    }

    template<>
    inline const pg::gen::InDateRangeQuery* DateSearchKind::kind_as<pg::gen::InDateRangeQuery>() const {
        return kind_as_pg_gen_InDateRangeQuery();
    }

    template<>
    inline const pg::gen::NotInDateRangeQuery* DateSearchKind::kind_as<pg::gen::NotInDateRangeQuery>() const {
        return kind_as_pg_gen_NotInDateRangeQuery();
    }

    struct DateSearchKindBuilder {
        typedef DateSearchKind Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_kind_type(pg::gen::DateSearchKind_::KindUnion kind_type) {
            fbb_.AddElement<uint8_t>(DateSearchKind::VT_KIND_TYPE, static_cast<uint8_t>(kind_type), 0);
        }
        void add_kind(flatbuffers::Offset<void> kind) {
            fbb_.AddOffset(DateSearchKind::VT_KIND, kind);
        }
        explicit DateSearchKindBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<DateSearchKind> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<DateSearchKind>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<DateSearchKind> CreateDateSearchKind(
        flatbuffers::FlatBufferBuilder& _fbb,
        pg::gen::DateSearchKind_::KindUnion kind_type = pg::gen::DateSearchKind_::KindUnion::NONE,
        flatbuffers::Offset<void> kind = 0) {
        DateSearchKindBuilder builder_(_fbb);
        builder_.add_kind(kind);
        builder_.add_kind_type(kind_type);
        return builder_.Finish();
    }

    struct DateSearchKind::Traits {
        using type = DateSearchKind;
        static auto constexpr Create = CreateDateSearchKind;
        static constexpr auto name = "DateSearchKind";
        static constexpr auto fully_qualified_name = "pg.gen.DateSearchKind";
        static constexpr std::array<const char*, 2> field_names = { "kind_type", "kind" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    flatbuffers::Offset<DateSearchKind> CreateDateSearchKind(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DateSearchKindT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct NoteTitleSearchT: public flatbuffers::NativeTable {
        typedef NoteTitleSearch TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.NoteTitleSearchT";
        }
        std::unique_ptr<pg::gen::TextSearchKindT> title_search {};
    };

    inline bool operator==(const NoteTitleSearchT& lhs, const NoteTitleSearchT& rhs) {
        return (lhs.title_search == rhs.title_search);
    }

    inline bool operator!=(const NoteTitleSearchT& lhs, const NoteTitleSearchT& rhs) {
        return !(lhs == rhs);
    }

    struct NoteTitleSearch FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef NoteTitleSearchT NativeTableType;
        typedef NoteTitleSearchBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return NoteTitleSearchTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.NoteTitleSearch";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TITLE_SEARCH = 4 };
        const pg::gen::TextSearchKind* _Nullable title_search() const {
            return GetPointer<const pg::gen::TextSearchKind*>(VT_TITLE_SEARCH);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return title_search();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TITLE_SEARCH)
                && verifier.VerifyTable(title_search()) && verifier.EndTable();
        }
        NoteTitleSearchT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(NoteTitleSearchT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<NoteTitleSearch> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const NoteTitleSearchT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct NoteTitleSearchBuilder {
        typedef NoteTitleSearch Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_title_search(flatbuffers::Offset<pg::gen::TextSearchKind> title_search) {
            fbb_.AddOffset(NoteTitleSearch::VT_TITLE_SEARCH, title_search);
        }
        explicit NoteTitleSearchBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<NoteTitleSearch> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<NoteTitleSearch>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<NoteTitleSearch> CreateNoteTitleSearch(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<pg::gen::TextSearchKind> title_search = 0) {
        NoteTitleSearchBuilder builder_(_fbb);
        builder_.add_title_search(title_search);
        return builder_.Finish();
    }

    struct NoteTitleSearch::Traits {
        using type = NoteTitleSearch;
        static auto constexpr Create = CreateNoteTitleSearch;
        static constexpr auto name = "NoteTitleSearch";
        static constexpr auto fully_qualified_name = "pg.gen.NoteTitleSearch";
        static constexpr std::array<const char*, 1> field_names = { "title_search" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    flatbuffers::Offset<NoteTitleSearch> CreateNoteTitleSearch(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteTitleSearchT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct NoteContentSearchT: public flatbuffers::NativeTable {
        typedef NoteContentSearch TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.NoteContentSearchT";
        }
        std::unique_ptr<pg::gen::TextSearchKindT> content_search {};
    };

    inline bool operator==(const NoteContentSearchT& lhs, const NoteContentSearchT& rhs) {
        return (lhs.content_search == rhs.content_search);
    }

    inline bool operator!=(const NoteContentSearchT& lhs, const NoteContentSearchT& rhs) {
        return !(lhs == rhs);
    }

    struct NoteContentSearch FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef NoteContentSearchT NativeTableType;
        typedef NoteContentSearchBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return NoteContentSearchTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.NoteContentSearch";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_CONTENT_SEARCH = 4 };
        const pg::gen::TextSearchKind* _Nullable content_search() const {
            return GetPointer<const pg::gen::TextSearchKind*>(VT_CONTENT_SEARCH);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return content_search();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_CONTENT_SEARCH)
                && verifier.VerifyTable(content_search()) && verifier.EndTable();
        }
        NoteContentSearchT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(NoteContentSearchT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<NoteContentSearch> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const NoteContentSearchT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct NoteContentSearchBuilder {
        typedef NoteContentSearch Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_content_search(flatbuffers::Offset<pg::gen::TextSearchKind> content_search) {
            fbb_.AddOffset(NoteContentSearch::VT_CONTENT_SEARCH, content_search);
        }
        explicit NoteContentSearchBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<NoteContentSearch> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<NoteContentSearch>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<NoteContentSearch> CreateNoteContentSearch(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<pg::gen::TextSearchKind> content_search = 0) {
        NoteContentSearchBuilder builder_(_fbb);
        builder_.add_content_search(content_search);
        return builder_.Finish();
    }

    struct NoteContentSearch::Traits {
        using type = NoteContentSearch;
        static auto constexpr Create = CreateNoteContentSearch;
        static constexpr auto name = "NoteContentSearch";
        static constexpr auto fully_qualified_name = "pg.gen.NoteContentSearch";
        static constexpr std::array<const char*, 1> field_names = { "content_search" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    flatbuffers::Offset<NoteContentSearch> CreateNoteContentSearch(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteContentSearchT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct NoteTagSearchT: public flatbuffers::NativeTable {
        typedef NoteTagSearch TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.NoteTagSearchT";
        }
        std::unique_ptr<pg::gen::TextSearchKindT> tag_search {};
    };

    inline bool operator==(const NoteTagSearchT& lhs, const NoteTagSearchT& rhs) {
        return (lhs.tag_search == rhs.tag_search);
    }

    inline bool operator!=(const NoteTagSearchT& lhs, const NoteTagSearchT& rhs) {
        return !(lhs == rhs);
    }

    struct NoteTagSearch FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef NoteTagSearchT NativeTableType;
        typedef NoteTagSearchBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return NoteTagSearchTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.NoteTagSearch";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TAG_SEARCH = 4 };
        const pg::gen::TextSearchKind* _Nullable tag_search() const {
            return GetPointer<const pg::gen::TextSearchKind*>(VT_TAG_SEARCH);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return tag_search();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TAG_SEARCH)
                && verifier.VerifyTable(tag_search()) && verifier.EndTable();
        }
        NoteTagSearchT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(NoteTagSearchT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<NoteTagSearch> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const NoteTagSearchT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct NoteTagSearchBuilder {
        typedef NoteTagSearch Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_tag_search(flatbuffers::Offset<pg::gen::TextSearchKind> tag_search) {
            fbb_.AddOffset(NoteTagSearch::VT_TAG_SEARCH, tag_search);
        }
        explicit NoteTagSearchBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<NoteTagSearch> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<NoteTagSearch>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<NoteTagSearch> CreateNoteTagSearch(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<pg::gen::TextSearchKind> tag_search = 0) {
        NoteTagSearchBuilder builder_(_fbb);
        builder_.add_tag_search(tag_search);
        return builder_.Finish();
    }

    struct NoteTagSearch::Traits {
        using type = NoteTagSearch;
        static auto constexpr Create = CreateNoteTagSearch;
        static constexpr auto name = "NoteTagSearch";
        static constexpr auto fully_qualified_name = "pg.gen.NoteTagSearch";
        static constexpr std::array<const char*, 1> field_names = { "tag_search" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    flatbuffers::Offset<NoteTagSearch> CreateNoteTagSearch(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteTagSearchT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct NoteCreatedSearchT: public flatbuffers::NativeTable {
        typedef NoteCreatedSearch TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.NoteCreatedSearchT";
        }
        std::unique_ptr<pg::gen::DateSearchKindT> created_search {};
    };

    inline bool operator==(const NoteCreatedSearchT& lhs, const NoteCreatedSearchT& rhs) {
        return (lhs.created_search == rhs.created_search);
    }

    inline bool operator!=(const NoteCreatedSearchT& lhs, const NoteCreatedSearchT& rhs) {
        return !(lhs == rhs);
    }

    struct NoteCreatedSearch FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef NoteCreatedSearchT NativeTableType;
        typedef NoteCreatedSearchBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return NoteCreatedSearchTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.NoteCreatedSearch";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_CREATED_SEARCH = 4 };
        const pg::gen::DateSearchKind* _Nullable created_search() const {
            return GetPointer<const pg::gen::DateSearchKind*>(VT_CREATED_SEARCH);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return created_search();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_CREATED_SEARCH)
                && verifier.VerifyTable(created_search()) && verifier.EndTable();
        }
        NoteCreatedSearchT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(NoteCreatedSearchT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<NoteCreatedSearch> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const NoteCreatedSearchT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct NoteCreatedSearchBuilder {
        typedef NoteCreatedSearch Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_created_search(flatbuffers::Offset<pg::gen::DateSearchKind> created_search) {
            fbb_.AddOffset(NoteCreatedSearch::VT_CREATED_SEARCH, created_search);
        }
        explicit NoteCreatedSearchBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<NoteCreatedSearch> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<NoteCreatedSearch>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<NoteCreatedSearch> CreateNoteCreatedSearch(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<pg::gen::DateSearchKind> created_search = 0) {
        NoteCreatedSearchBuilder builder_(_fbb);
        builder_.add_created_search(created_search);
        return builder_.Finish();
    }

    struct NoteCreatedSearch::Traits {
        using type = NoteCreatedSearch;
        static auto constexpr Create = CreateNoteCreatedSearch;
        static constexpr auto name = "NoteCreatedSearch";
        static constexpr auto fully_qualified_name = "pg.gen.NoteCreatedSearch";
        static constexpr std::array<const char*, 1> field_names = { "created_search" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    flatbuffers::Offset<NoteCreatedSearch> CreateNoteCreatedSearch(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteCreatedSearchT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct NoteUpdatedSearchT: public flatbuffers::NativeTable {
        typedef NoteUpdatedSearch TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.NoteUpdatedSearchT";
        }
        std::unique_ptr<pg::gen::DateSearchKindT> updated_search {};
    };

    inline bool operator==(const NoteUpdatedSearchT& lhs, const NoteUpdatedSearchT& rhs) {
        return (lhs.updated_search == rhs.updated_search);
    }

    inline bool operator!=(const NoteUpdatedSearchT& lhs, const NoteUpdatedSearchT& rhs) {
        return !(lhs == rhs);
    }

    struct NoteUpdatedSearch FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef NoteUpdatedSearchT NativeTableType;
        typedef NoteUpdatedSearchBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return NoteUpdatedSearchTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.NoteUpdatedSearch";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_UPDATED_SEARCH = 4 };
        const pg::gen::DateSearchKind* _Nullable updated_search() const {
            return GetPointer<const pg::gen::DateSearchKind*>(VT_UPDATED_SEARCH);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return updated_search();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_UPDATED_SEARCH)
                && verifier.VerifyTable(updated_search()) && verifier.EndTable();
        }
        NoteUpdatedSearchT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(NoteUpdatedSearchT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<NoteUpdatedSearch> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const NoteUpdatedSearchT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct NoteUpdatedSearchBuilder {
        typedef NoteUpdatedSearch Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_updated_search(flatbuffers::Offset<pg::gen::DateSearchKind> updated_search) {
            fbb_.AddOffset(NoteUpdatedSearch::VT_UPDATED_SEARCH, updated_search);
        }
        explicit NoteUpdatedSearchBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<NoteUpdatedSearch> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<NoteUpdatedSearch>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<NoteUpdatedSearch> CreateNoteUpdatedSearch(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<pg::gen::DateSearchKind> updated_search = 0) {
        NoteUpdatedSearchBuilder builder_(_fbb);
        builder_.add_updated_search(updated_search);
        return builder_.Finish();
    }

    struct NoteUpdatedSearch::Traits {
        using type = NoteUpdatedSearch;
        static auto constexpr Create = CreateNoteUpdatedSearch;
        static constexpr auto name = "NoteUpdatedSearch";
        static constexpr auto fully_qualified_name = "pg.gen.NoteUpdatedSearch";
        static constexpr std::array<const char*, 1> field_names = { "updated_search" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    flatbuffers::Offset<NoteUpdatedSearch> CreateNoteUpdatedSearch(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteUpdatedSearchT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct SearchNoteDataT: public flatbuffers::NativeTable {
        typedef SearchNoteData TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.SearchNoteDataT";
        }
        pg::gen::SearchNoteData_::KindUnionUnion kind {};
    };

    inline bool operator==(const SearchNoteDataT& lhs, const SearchNoteDataT& rhs) {
        return (lhs.kind == rhs.kind);
    }

    inline bool operator!=(const SearchNoteDataT& lhs, const SearchNoteDataT& rhs) {
        return !(lhs == rhs);
    }

    struct SearchNoteData FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef SearchNoteDataT NativeTableType;
        typedef SearchNoteDataBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return SearchNoteDataTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.SearchNoteData";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_KIND_TYPE = 4, VT_KIND = 6 };
        pg::gen::SearchNoteData_::KindUnion kind_type() const {
            return static_cast<pg::gen::SearchNoteData_::KindUnion>(GetField<uint8_t>(VT_KIND_TYPE, 0));
        }
        const void* _Nullable kind() const {
            return GetPointer<const void*>(VT_KIND);
        }
        template<typename T>
        const T* _Nullable kind_as() const;
        const pg::gen::NoteTitleSearch* _Nullable kind_as_pg_gen_NoteTitleSearch() const {
            return kind_type() == pg::gen::SearchNoteData_::KindUnion::pg_gen_NoteTitleSearch
                ? static_cast<const pg::gen::NoteTitleSearch*>(kind())
                : nullptr;
        }
        const pg::gen::NoteContentSearch* _Nullable kind_as_pg_gen_NoteContentSearch() const {
            return kind_type() == pg::gen::SearchNoteData_::KindUnion::pg_gen_NoteContentSearch
                ? static_cast<const pg::gen::NoteContentSearch*>(kind())
                : nullptr;
        }
        const pg::gen::NoteTagSearch* _Nullable kind_as_pg_gen_NoteTagSearch() const {
            return kind_type() == pg::gen::SearchNoteData_::KindUnion::pg_gen_NoteTagSearch
                ? static_cast<const pg::gen::NoteTagSearch*>(kind())
                : nullptr;
        }
        const pg::gen::NoteCreatedSearch* _Nullable kind_as_pg_gen_NoteCreatedSearch() const {
            return kind_type() == pg::gen::SearchNoteData_::KindUnion::pg_gen_NoteCreatedSearch
                ? static_cast<const pg::gen::NoteCreatedSearch*>(kind())
                : nullptr;
        }
        const pg::gen::NoteUpdatedSearch* _Nullable kind_as_pg_gen_NoteUpdatedSearch() const {
            return kind_type() == pg::gen::SearchNoteData_::KindUnion::pg_gen_NoteUpdatedSearch
                ? static_cast<const pg::gen::NoteUpdatedSearch*>(kind())
                : nullptr;
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return kind_type();
            else if constexpr (Index == 1)
                return kind();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_KIND_TYPE)
                && VerifyOffset(verifier, VT_KIND) && VerifyKindUnion(verifier, kind(), kind_type())
                && verifier.EndTable();
        }
        SearchNoteDataT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(SearchNoteDataT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<SearchNoteData> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const SearchNoteDataT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    template<>
    inline const pg::gen::NoteTitleSearch* SearchNoteData::kind_as<pg::gen::NoteTitleSearch>() const {
        return kind_as_pg_gen_NoteTitleSearch();
    }

    template<>
    inline const pg::gen::NoteContentSearch* SearchNoteData::kind_as<pg::gen::NoteContentSearch>() const {
        return kind_as_pg_gen_NoteContentSearch();
    }

    template<>
    inline const pg::gen::NoteTagSearch* SearchNoteData::kind_as<pg::gen::NoteTagSearch>() const {
        return kind_as_pg_gen_NoteTagSearch();
    }

    template<>
    inline const pg::gen::NoteCreatedSearch* SearchNoteData::kind_as<pg::gen::NoteCreatedSearch>() const {
        return kind_as_pg_gen_NoteCreatedSearch();
    }

    template<>
    inline const pg::gen::NoteUpdatedSearch* SearchNoteData::kind_as<pg::gen::NoteUpdatedSearch>() const {
        return kind_as_pg_gen_NoteUpdatedSearch();
    }

    struct SearchNoteDataBuilder {
        typedef SearchNoteData Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_kind_type(pg::gen::SearchNoteData_::KindUnion kind_type) {
            fbb_.AddElement<uint8_t>(SearchNoteData::VT_KIND_TYPE, static_cast<uint8_t>(kind_type), 0);
        }
        void add_kind(flatbuffers::Offset<void> kind) {
            fbb_.AddOffset(SearchNoteData::VT_KIND, kind);
        }
        explicit SearchNoteDataBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<SearchNoteData> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<SearchNoteData>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<SearchNoteData> CreateSearchNoteData(
        flatbuffers::FlatBufferBuilder& _fbb,
        pg::gen::SearchNoteData_::KindUnion kind_type = pg::gen::SearchNoteData_::KindUnion::NONE,
        flatbuffers::Offset<void> kind = 0) {
        SearchNoteDataBuilder builder_(_fbb);
        builder_.add_kind(kind);
        builder_.add_kind_type(kind_type);
        return builder_.Finish();
    }

    struct SearchNoteData::Traits {
        using type = SearchNoteData;
        static auto constexpr Create = CreateSearchNoteData;
        static constexpr auto name = "SearchNoteData";
        static constexpr auto fully_qualified_name = "pg.gen.SearchNoteData";
        static constexpr std::array<const char*, 2> field_names = { "kind_type", "kind" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    flatbuffers::Offset<SearchNoteData> CreateSearchNoteData(
        flatbuffers::FlatBufferBuilder& _fbb,
        const SearchNoteDataT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct SearchNoteRequestT: public flatbuffers::NativeTable {
        typedef SearchNoteRequest TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.SearchNoteRequestT";
        }
        std::vector<std::unique_ptr<pg::gen::SearchNoteDataT>> searches {};
        uint32_t page_size = 0;
        std::string page_token {};
    };

    inline bool operator==(const SearchNoteRequestT& lhs, const SearchNoteRequestT& rhs) {
        return (lhs.searches == rhs.searches) && (lhs.page_size == rhs.page_size) && (lhs.page_token == rhs.page_token);
    }

    inline bool operator!=(const SearchNoteRequestT& lhs, const SearchNoteRequestT& rhs) {
        return !(lhs == rhs);
    }

    struct SearchNoteRequest FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef SearchNoteRequestT NativeTableType;
        typedef SearchNoteRequestBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return SearchNoteRequestTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.SearchNoteRequest";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_SEARCHES = 4,
            VT_PAGE_SIZE = 6,
            VT_PAGE_TOKEN = 8
        };
        const flatbuffers::Vector<flatbuffers::Offset<pg::gen::SearchNoteData>>* _Nullable searches() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pg::gen::SearchNoteData>>*>(VT_SEARCHES);
        }
        uint32_t page_size() const {
            return GetField<uint32_t>(VT_PAGE_SIZE, 0);
        }
        const flatbuffers::String* _Nullable page_token() const {
            return GetPointer<const flatbuffers::String*>(VT_PAGE_TOKEN);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return searches();
            else if constexpr (Index == 1)
                return page_size();
            else if constexpr (Index == 2)
                return page_token();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SEARCHES)
                && verifier.VerifyVector(searches()) && verifier.VerifyVectorOfTables(searches())
                && VerifyField<uint32_t>(verifier, VT_PAGE_SIZE) && VerifyOffset(verifier, VT_PAGE_TOKEN)
                && verifier.VerifyString(page_token()) && verifier.EndTable();
        }
        SearchNoteRequestT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(SearchNoteRequestT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<SearchNoteRequest> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const SearchNoteRequestT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct SearchNoteRequestBuilder {
        typedef SearchNoteRequest Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void
        add_searches(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::SearchNoteData>>> searches) {
            fbb_.AddOffset(SearchNoteRequest::VT_SEARCHES, searches);
        }
        void add_page_size(uint32_t page_size) {
            fbb_.AddElement<uint32_t>(SearchNoteRequest::VT_PAGE_SIZE, page_size, 0);
        }
        void add_page_token(flatbuffers::Offset<flatbuffers::String> page_token) {
            fbb_.AddOffset(SearchNoteRequest::VT_PAGE_TOKEN, page_token);
        }
        explicit SearchNoteRequestBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<SearchNoteRequest> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<SearchNoteRequest>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<SearchNoteRequest> CreateSearchNoteRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::SearchNoteData>>> searches = 0,
        uint32_t page_size = 0,
        flatbuffers::Offset<flatbuffers::String> page_token = 0) {
        SearchNoteRequestBuilder builder_(_fbb);
        builder_.add_page_token(page_token);
        builder_.add_page_size(page_size);
        builder_.add_searches(searches);
        return builder_.Finish();
    }

    struct SearchNoteRequest::Traits {
        using type = SearchNoteRequest;
        static auto constexpr Create = CreateSearchNoteRequest;
        static constexpr auto name = "SearchNoteRequest";
        static constexpr auto fully_qualified_name = "pg.gen.SearchNoteRequest";
        static constexpr std::array<const char*, 3> field_names = { "searches", "page_size", "page_token" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 3;
    };

    inline flatbuffers::Offset<SearchNoteRequest> CreateSearchNoteRequestDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const std::vector<flatbuffers::Offset<pg::gen::SearchNoteData>>* searches = nullptr,
        uint32_t page_size = 0,
        const char* page_token = nullptr) {
        auto searches__ = searches ? _fbb.CreateVector<flatbuffers::Offset<pg::gen::SearchNoteData>>(*searches) : 0;
        auto page_token__ = page_token ? _fbb.CreateString(page_token) : 0;
        return pg::gen::CreateSearchNoteRequest(_fbb, searches__, page_size, page_token__);
    }

    flatbuffers::Offset<SearchNoteRequest> CreateSearchNoteRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        const SearchNoteRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct SearchNoteResponseT: public flatbuffers::NativeTable {
        typedef SearchNoteResponse TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.SearchNoteResponseT";
        }
        std::vector<std::unique_ptr<pg::gen::NoteObjectT>> notes {};
        std::string next_page_token {};
    };

    inline bool operator==(const SearchNoteResponseT& lhs, const SearchNoteResponseT& rhs) {
        return (lhs.notes == rhs.notes) && (lhs.next_page_token == rhs.next_page_token);
    }

    inline bool operator!=(const SearchNoteResponseT& lhs, const SearchNoteResponseT& rhs) {
        return !(lhs == rhs);
    }

    struct SearchNoteResponse FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef SearchNoteResponseT NativeTableType;
        typedef SearchNoteResponseBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return SearchNoteResponseTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.SearchNoteResponse";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NOTES = 4, VT_NEXT_PAGE_TOKEN = 6 };
        const flatbuffers::Vector<flatbuffers::Offset<pg::gen::NoteObject>>* _Nullable notes() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pg::gen::NoteObject>>*>(VT_NOTES);
        }
        const flatbuffers::String* _Nullable next_page_token() const {
            return GetPointer<const flatbuffers::String*>(VT_NEXT_PAGE_TOKEN);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return notes();
            else if constexpr (Index == 1)
                return next_page_token();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NOTES) && verifier.VerifyVector(notes())
                && verifier.VerifyVectorOfTables(notes()) && VerifyOffset(verifier, VT_NEXT_PAGE_TOKEN)
                && verifier.VerifyString(next_page_token()) && verifier.EndTable();
        }
        SearchNoteResponseT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(SearchNoteResponseT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<SearchNoteResponse> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const SearchNoteResponseT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct SearchNoteResponseBuilder {
        typedef SearchNoteResponse Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_notes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::NoteObject>>> notes) {
            fbb_.AddOffset(SearchNoteResponse::VT_NOTES, notes);
        }
        void add_next_page_token(flatbuffers::Offset<flatbuffers::String> next_page_token) {
            fbb_.AddOffset(SearchNoteResponse::VT_NEXT_PAGE_TOKEN, next_page_token);
        }
        explicit SearchNoteResponseBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<SearchNoteResponse> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<SearchNoteResponse>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<SearchNoteResponse> CreateSearchNoteResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::NoteObject>>> notes = 0,
        flatbuffers::Offset<flatbuffers::String> next_page_token = 0) {
        SearchNoteResponseBuilder builder_(_fbb);
        builder_.add_next_page_token(next_page_token);
        builder_.add_notes(notes);
        return builder_.Finish();
    }

    struct SearchNoteResponse::Traits {
        using type = SearchNoteResponse;
        static auto constexpr Create = CreateSearchNoteResponse;
        static constexpr auto name = "SearchNoteResponse";
        static constexpr auto fully_qualified_name = "pg.gen.SearchNoteResponse";
        static constexpr std::array<const char*, 2> field_names = { "notes", "next_page_token" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    inline flatbuffers::Offset<SearchNoteResponse> CreateSearchNoteResponseDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const std::vector<flatbuffers::Offset<pg::gen::NoteObject>>* notes = nullptr,
        const char* next_page_token = nullptr) {
        auto notes__ = notes ? _fbb.CreateVector<flatbuffers::Offset<pg::gen::NoteObject>>(*notes) : 0;
        auto next_page_token__ = next_page_token ? _fbb.CreateString(next_page_token) : 0;
        return pg::gen::CreateSearchNoteResponse(_fbb, notes__, next_page_token__);
    }

    flatbuffers::Offset<SearchNoteResponse> CreateSearchNoteResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        const SearchNoteResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct CreateNoteDataT: public flatbuffers::NativeTable {
        typedef CreateNoteData TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.CreateNoteDataT";
        }
        std::string title {};
        std::string content {};
        std::vector<std::string> tags {};
    };

    inline bool operator==(const CreateNoteDataT& lhs, const CreateNoteDataT& rhs) {
        return (lhs.title == rhs.title) && (lhs.content == rhs.content) && (lhs.tags == rhs.tags);
    }

    inline bool operator!=(const CreateNoteDataT& lhs, const CreateNoteDataT& rhs) {
        return !(lhs == rhs);
    }

    struct CreateNoteData FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef CreateNoteDataT NativeTableType;
        typedef CreateNoteDataBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return CreateNoteDataTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.CreateNoteData";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TITLE = 4, VT_CONTENT = 6, VT_TAGS = 8 };
        const flatbuffers::String* _Nullable title() const {
            return GetPointer<const flatbuffers::String*>(VT_TITLE);
        }
        const flatbuffers::String* _Nullable content() const {
            return GetPointer<const flatbuffers::String*>(VT_CONTENT);
        }
        const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>* _Nullable tags() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>*>(VT_TAGS);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return title();
            else if constexpr (Index == 1)
                return content();
            else if constexpr (Index == 2)
                return tags();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TITLE) && verifier.VerifyString(title())
                && VerifyOffset(verifier, VT_CONTENT) && verifier.VerifyString(content())
                && VerifyOffset(verifier, VT_TAGS) && verifier.VerifyVector(tags())
                && verifier.VerifyVectorOfStrings(tags()) && verifier.EndTable();
        }
        CreateNoteDataT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(CreateNoteDataT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<CreateNoteData> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const CreateNoteDataT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct CreateNoteDataBuilder {
        typedef CreateNoteData Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_title(flatbuffers::Offset<flatbuffers::String> title) {
            fbb_.AddOffset(CreateNoteData::VT_TITLE, title);
        }
        void add_content(flatbuffers::Offset<flatbuffers::String> content) {
            fbb_.AddOffset(CreateNoteData::VT_CONTENT, content);
        }
        void add_tags(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tags) {
            fbb_.AddOffset(CreateNoteData::VT_TAGS, tags);
        }
        explicit CreateNoteDataBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<CreateNoteData> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<CreateNoteData>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<CreateNoteData> CreateCreateNoteData(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::String> title = 0,
        flatbuffers::Offset<flatbuffers::String> content = 0,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tags = 0) {
        CreateNoteDataBuilder builder_(_fbb);
        builder_.add_tags(tags);
        builder_.add_content(content);
        builder_.add_title(title);
        return builder_.Finish();
    }

    struct CreateNoteData::Traits {
        using type = CreateNoteData;
        static auto constexpr Create = CreateCreateNoteData;
        static constexpr auto name = "CreateNoteData";
        static constexpr auto fully_qualified_name = "pg.gen.CreateNoteData";
        static constexpr std::array<const char*, 3> field_names = { "title", "content", "tags" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 3;
    };

    inline flatbuffers::Offset<CreateNoteData> CreateCreateNoteDataDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const char* title = nullptr,
        const char* content = nullptr,
        const std::vector<flatbuffers::Offset<flatbuffers::String>>* tags = nullptr) {
        auto title__ = title ? _fbb.CreateString(title) : 0;
        auto content__ = content ? _fbb.CreateString(content) : 0;
        auto tags__ = tags ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tags) : 0;
        return pg::gen::CreateCreateNoteData(_fbb, title__, content__, tags__);
    }

    flatbuffers::Offset<CreateNoteData> CreateCreateNoteData(
        flatbuffers::FlatBufferBuilder& _fbb,
        const CreateNoteDataT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct CreateNoteRequestT: public flatbuffers::NativeTable {
        typedef CreateNoteRequest TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.CreateNoteRequestT";
        }
        std::string parent {};
        std::unique_ptr<pg::gen::CreateNoteDataT> note {};
        std::string id {};
    };

    inline bool operator==(const CreateNoteRequestT& lhs, const CreateNoteRequestT& rhs) {
        return (lhs.parent == rhs.parent) && (lhs.note == rhs.note) && (lhs.id == rhs.id);
    }

    inline bool operator!=(const CreateNoteRequestT& lhs, const CreateNoteRequestT& rhs) {
        return !(lhs == rhs);
    }

    struct CreateNoteRequest FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef CreateNoteRequestT NativeTableType;
        typedef CreateNoteRequestBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return CreateNoteRequestTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.CreateNoteRequest";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_PARENT = 4, VT_NOTE = 6, VT_ID = 8 };
        const flatbuffers::String* _Nullable parent() const {
            return GetPointer<const flatbuffers::String*>(VT_PARENT);
        }
        const pg::gen::CreateNoteData* _Nullable note() const {
            return GetPointer<const pg::gen::CreateNoteData*>(VT_NOTE);
        }
        const flatbuffers::String* _Nullable id() const {
            return GetPointer<const flatbuffers::String*>(VT_ID);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return parent();
            else if constexpr (Index == 1)
                return note();
            else if constexpr (Index == 2)
                return id();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_PARENT) && verifier.VerifyString(parent())
                && VerifyOffset(verifier, VT_NOTE) && verifier.VerifyTable(note()) && VerifyOffset(verifier, VT_ID)
                && verifier.VerifyString(id()) && verifier.EndTable();
        }
        CreateNoteRequestT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(CreateNoteRequestT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<CreateNoteRequest> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const CreateNoteRequestT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct CreateNoteRequestBuilder {
        typedef CreateNoteRequest Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_parent(flatbuffers::Offset<flatbuffers::String> parent) {
            fbb_.AddOffset(CreateNoteRequest::VT_PARENT, parent);
        }
        void add_note(flatbuffers::Offset<pg::gen::CreateNoteData> note) {
            fbb_.AddOffset(CreateNoteRequest::VT_NOTE, note);
        }
        void add_id(flatbuffers::Offset<flatbuffers::String> id) {
            fbb_.AddOffset(CreateNoteRequest::VT_ID, id);
        }
        explicit CreateNoteRequestBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<CreateNoteRequest> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<CreateNoteRequest>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<CreateNoteRequest> CreateCreateNoteRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::String> parent = 0,
        flatbuffers::Offset<pg::gen::CreateNoteData> note = 0,
        flatbuffers::Offset<flatbuffers::String> id = 0) {
        CreateNoteRequestBuilder builder_(_fbb);
        builder_.add_id(id);
        builder_.add_note(note);
        builder_.add_parent(parent);
        return builder_.Finish();
    }

    struct CreateNoteRequest::Traits {
        using type = CreateNoteRequest;
        static auto constexpr Create = CreateCreateNoteRequest;
        static constexpr auto name = "CreateNoteRequest";
        static constexpr auto fully_qualified_name = "pg.gen.CreateNoteRequest";
        static constexpr std::array<const char*, 3> field_names = { "parent", "note", "id" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 3;
    };

    inline flatbuffers::Offset<CreateNoteRequest> CreateCreateNoteRequestDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const char* parent = nullptr,
        flatbuffers::Offset<pg::gen::CreateNoteData> note = 0,
        const char* id = nullptr) {
        auto parent__ = parent ? _fbb.CreateString(parent) : 0;
        auto id__ = id ? _fbb.CreateString(id) : 0;
        return pg::gen::CreateCreateNoteRequest(_fbb, parent__, note, id__);
    }

    flatbuffers::Offset<CreateNoteRequest> CreateCreateNoteRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        const CreateNoteRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct CreateNoteResponseT: public flatbuffers::NativeTable {
        typedef CreateNoteResponse TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.CreateNoteResponseT";
        }
        pg::gen::CreateNoteResponse_::RespUnionUnion resp {};
    };

    inline bool operator==(const CreateNoteResponseT& lhs, const CreateNoteResponseT& rhs) {
        return (lhs.resp == rhs.resp);
    }

    inline bool operator!=(const CreateNoteResponseT& lhs, const CreateNoteResponseT& rhs) {
        return !(lhs == rhs);
    }

    struct CreateNoteResponse FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef CreateNoteResponseT NativeTableType;
        typedef CreateNoteResponseBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return CreateNoteResponseTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.CreateNoteResponse";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_RESP_TYPE = 4, VT_RESP = 6 };
        pg::gen::CreateNoteResponse_::RespUnion resp_type() const {
            return static_cast<pg::gen::CreateNoteResponse_::RespUnion>(GetField<uint8_t>(VT_RESP_TYPE, 0));
        }
        const void* _Nullable resp() const {
            return GetPointer<const void*>(VT_RESP);
        }
        template<typename T>
        const T* _Nullable resp_as() const;
        const pg::gen::NoteObject* _Nullable resp_as_pg_gen_NoteObject() const {
            return resp_type() == pg::gen::CreateNoteResponse_::RespUnion::pg_gen_NoteObject
                ? static_cast<const pg::gen::NoteObject*>(resp())
                : nullptr;
        }
        const pg::gen::ResponseError* _Nullable resp_as_pg_gen_ResponseError() const {
            return resp_type() == pg::gen::CreateNoteResponse_::RespUnion::pg_gen_ResponseError
                ? static_cast<const pg::gen::ResponseError*>(resp())
                : nullptr;
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return resp_type();
            else if constexpr (Index == 1)
                return resp();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_RESP_TYPE)
                && VerifyOffset(verifier, VT_RESP) && VerifyRespUnion(verifier, resp(), resp_type())
                && verifier.EndTable();
        }
        CreateNoteResponseT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(CreateNoteResponseT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<CreateNoteResponse> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const CreateNoteResponseT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    template<>
    inline const pg::gen::NoteObject* CreateNoteResponse::resp_as<pg::gen::NoteObject>() const {
        return resp_as_pg_gen_NoteObject();
    }

    template<>
    inline const pg::gen::ResponseError* CreateNoteResponse::resp_as<pg::gen::ResponseError>() const {
        return resp_as_pg_gen_ResponseError();
    }

    struct CreateNoteResponseBuilder {
        typedef CreateNoteResponse Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_resp_type(pg::gen::CreateNoteResponse_::RespUnion resp_type) {
            fbb_.AddElement<uint8_t>(CreateNoteResponse::VT_RESP_TYPE, static_cast<uint8_t>(resp_type), 0);
        }
        void add_resp(flatbuffers::Offset<void> resp) {
            fbb_.AddOffset(CreateNoteResponse::VT_RESP, resp);
        }
        explicit CreateNoteResponseBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<CreateNoteResponse> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<CreateNoteResponse>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<CreateNoteResponse> CreateCreateNoteResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        pg::gen::CreateNoteResponse_::RespUnion resp_type = pg::gen::CreateNoteResponse_::RespUnion::NONE,
        flatbuffers::Offset<void> resp = 0) {
        CreateNoteResponseBuilder builder_(_fbb);
        builder_.add_resp(resp);
        builder_.add_resp_type(resp_type);
        return builder_.Finish();
    }

    struct CreateNoteResponse::Traits {
        using type = CreateNoteResponse;
        static auto constexpr Create = CreateCreateNoteResponse;
        static constexpr auto name = "CreateNoteResponse";
        static constexpr auto fully_qualified_name = "pg.gen.CreateNoteResponse";
        static constexpr std::array<const char*, 2> field_names = { "resp_type", "resp" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    flatbuffers::Offset<CreateNoteResponse> CreateCreateNoteResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        const CreateNoteResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct UpdateNoteDataT: public flatbuffers::NativeTable {
        typedef UpdateNoteData TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.UpdateNoteDataT";
        }
        std::string id {};
        std::vector<std::unique_ptr<pg::gen::TextModificationKindT>> title_mods {};
        std::vector<std::unique_ptr<pg::gen::TextModificationKindT>> content_mods {};
        std::vector<std::unique_ptr<pg::gen::TextModificationKindT>> tag_mods {};
    };

    inline bool operator==(const UpdateNoteDataT& lhs, const UpdateNoteDataT& rhs) {
        return (lhs.id == rhs.id) && (lhs.title_mods == rhs.title_mods) && (lhs.content_mods == rhs.content_mods)
            && (lhs.tag_mods == rhs.tag_mods);
    }

    inline bool operator!=(const UpdateNoteDataT& lhs, const UpdateNoteDataT& rhs) {
        return !(lhs == rhs);
    }

    struct UpdateNoteData FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef UpdateNoteDataT NativeTableType;
        typedef UpdateNoteDataBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return UpdateNoteDataTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.UpdateNoteData";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_ID = 4,
            VT_TITLE_MODS = 6,
            VT_CONTENT_MODS = 8,
            VT_TAG_MODS = 10
        };
        const flatbuffers::String* _Nullable id() const {
            return GetPointer<const flatbuffers::String*>(VT_ID);
        }
        const flatbuffers::Vector<flatbuffers::Offset<pg::gen::TextModificationKind>>* _Nullable title_mods() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pg::gen::TextModificationKind>>*>(
                VT_TITLE_MODS);
        }
        const flatbuffers::Vector<flatbuffers::Offset<pg::gen::TextModificationKind>>* _Nullable content_mods() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pg::gen::TextModificationKind>>*>(
                VT_CONTENT_MODS);
        }
        const flatbuffers::Vector<flatbuffers::Offset<pg::gen::TextModificationKind>>* _Nullable tag_mods() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pg::gen::TextModificationKind>>*>(
                VT_TAG_MODS);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return id();
            else if constexpr (Index == 1)
                return title_mods();
            else if constexpr (Index == 2)
                return content_mods();
            else if constexpr (Index == 3)
                return tag_mods();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ID) && verifier.VerifyString(id())
                && VerifyOffset(verifier, VT_TITLE_MODS) && verifier.VerifyVector(title_mods())
                && verifier.VerifyVectorOfTables(title_mods()) && VerifyOffset(verifier, VT_CONTENT_MODS)
                && verifier.VerifyVector(content_mods()) && verifier.VerifyVectorOfTables(content_mods())
                && VerifyOffset(verifier, VT_TAG_MODS) && verifier.VerifyVector(tag_mods())
                && verifier.VerifyVectorOfTables(tag_mods()) && verifier.EndTable();
        }
        UpdateNoteDataT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(UpdateNoteDataT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<UpdateNoteData> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const UpdateNoteDataT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct UpdateNoteDataBuilder {
        typedef UpdateNoteData Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_id(flatbuffers::Offset<flatbuffers::String> id) {
            fbb_.AddOffset(UpdateNoteData::VT_ID, id);
        }
        void add_title_mods(
            flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::TextModificationKind>>> title_mods) {
            fbb_.AddOffset(UpdateNoteData::VT_TITLE_MODS, title_mods);
        }
        void add_content_mods(
            flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::TextModificationKind>>> content_mods) {
            fbb_.AddOffset(UpdateNoteData::VT_CONTENT_MODS, content_mods);
        }
        void add_tag_mods(
            flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::TextModificationKind>>> tag_mods) {
            fbb_.AddOffset(UpdateNoteData::VT_TAG_MODS, tag_mods);
        }
        explicit UpdateNoteDataBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<UpdateNoteData> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<UpdateNoteData>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<UpdateNoteData> CreateUpdateNoteData(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::String> id = 0,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::TextModificationKind>>> title_mods = 0,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::TextModificationKind>>> content_mods = 0,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::TextModificationKind>>> tag_mods = 0) {
        UpdateNoteDataBuilder builder_(_fbb);
        builder_.add_tag_mods(tag_mods);
        builder_.add_content_mods(content_mods);
        builder_.add_title_mods(title_mods);
        builder_.add_id(id);
        return builder_.Finish();
    }

    struct UpdateNoteData::Traits {
        using type = UpdateNoteData;
        static auto constexpr Create = CreateUpdateNoteData;
        static constexpr auto name = "UpdateNoteData";
        static constexpr auto fully_qualified_name = "pg.gen.UpdateNoteData";
        static constexpr std::array<const char*, 4> field_names = { "id", "title_mods", "content_mods", "tag_mods" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 4;
    };

    inline flatbuffers::Offset<UpdateNoteData> CreateUpdateNoteDataDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const char* id = nullptr,
        const std::vector<flatbuffers::Offset<pg::gen::TextModificationKind>>* title_mods = nullptr,
        const std::vector<flatbuffers::Offset<pg::gen::TextModificationKind>>* content_mods = nullptr,
        const std::vector<flatbuffers::Offset<pg::gen::TextModificationKind>>* tag_mods = nullptr) {
        auto id__ = id ? _fbb.CreateString(id) : 0;
        auto title_mods__ =
            title_mods ? _fbb.CreateVector<flatbuffers::Offset<pg::gen::TextModificationKind>>(*title_mods) : 0;
        auto content_mods__ =
            content_mods ? _fbb.CreateVector<flatbuffers::Offset<pg::gen::TextModificationKind>>(*content_mods) : 0;
        auto tag_mods__ =
            tag_mods ? _fbb.CreateVector<flatbuffers::Offset<pg::gen::TextModificationKind>>(*tag_mods) : 0;
        return pg::gen::CreateUpdateNoteData(_fbb, id__, title_mods__, content_mods__, tag_mods__);
    }

    flatbuffers::Offset<UpdateNoteData> CreateUpdateNoteData(
        flatbuffers::FlatBufferBuilder& _fbb,
        const UpdateNoteDataT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct UpdateNoteRequestT: public flatbuffers::NativeTable {
        typedef UpdateNoteRequest TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.UpdateNoteRequestT";
        }
        std::unique_ptr<pg::gen::UpdateNoteDataT> target {};
    };

    inline bool operator==(const UpdateNoteRequestT& lhs, const UpdateNoteRequestT& rhs) {
        return (lhs.target == rhs.target);
    }

    inline bool operator!=(const UpdateNoteRequestT& lhs, const UpdateNoteRequestT& rhs) {
        return !(lhs == rhs);
    }

    struct UpdateNoteRequest FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef UpdateNoteRequestT NativeTableType;
        typedef UpdateNoteRequestBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return UpdateNoteRequestTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.UpdateNoteRequest";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TARGET = 4 };
        const pg::gen::UpdateNoteData* _Nullable target() const {
            return GetPointer<const pg::gen::UpdateNoteData*>(VT_TARGET);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return target();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TARGET) && verifier.VerifyTable(target())
                && verifier.EndTable();
        }
        UpdateNoteRequestT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(UpdateNoteRequestT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<UpdateNoteRequest> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const UpdateNoteRequestT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct UpdateNoteRequestBuilder {
        typedef UpdateNoteRequest Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_target(flatbuffers::Offset<pg::gen::UpdateNoteData> target) {
            fbb_.AddOffset(UpdateNoteRequest::VT_TARGET, target);
        }
        explicit UpdateNoteRequestBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<UpdateNoteRequest> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<UpdateNoteRequest>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<UpdateNoteRequest> CreateUpdateNoteRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<pg::gen::UpdateNoteData> target = 0) {
        UpdateNoteRequestBuilder builder_(_fbb);
        builder_.add_target(target);
        return builder_.Finish();
    }

    struct UpdateNoteRequest::Traits {
        using type = UpdateNoteRequest;
        static auto constexpr Create = CreateUpdateNoteRequest;
        static constexpr auto name = "UpdateNoteRequest";
        static constexpr auto fully_qualified_name = "pg.gen.UpdateNoteRequest";
        static constexpr std::array<const char*, 1> field_names = { "target" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    flatbuffers::Offset<UpdateNoteRequest> CreateUpdateNoteRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        const UpdateNoteRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct UpdateNoteResponseT: public flatbuffers::NativeTable {
        typedef UpdateNoteResponse TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.UpdateNoteResponseT";
        }
        pg::gen::UpdateNoteResponse_::RespUnionUnion resp {};
    };

    inline bool operator==(const UpdateNoteResponseT& lhs, const UpdateNoteResponseT& rhs) {
        return (lhs.resp == rhs.resp);
    }

    inline bool operator!=(const UpdateNoteResponseT& lhs, const UpdateNoteResponseT& rhs) {
        return !(lhs == rhs);
    }

    struct UpdateNoteResponse FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef UpdateNoteResponseT NativeTableType;
        typedef UpdateNoteResponseBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return UpdateNoteResponseTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.UpdateNoteResponse";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_RESP_TYPE = 4, VT_RESP = 6 };
        pg::gen::UpdateNoteResponse_::RespUnion resp_type() const {
            return static_cast<pg::gen::UpdateNoteResponse_::RespUnion>(GetField<uint8_t>(VT_RESP_TYPE, 0));
        }
        const void* _Nullable resp() const {
            return GetPointer<const void*>(VT_RESP);
        }
        template<typename T>
        const T* _Nullable resp_as() const;
        const pg::gen::NoteObject* _Nullable resp_as_pg_gen_NoteObject() const {
            return resp_type() == pg::gen::UpdateNoteResponse_::RespUnion::pg_gen_NoteObject
                ? static_cast<const pg::gen::NoteObject*>(resp())
                : nullptr;
        }
        const pg::gen::ResponseError* _Nullable resp_as_pg_gen_ResponseError() const {
            return resp_type() == pg::gen::UpdateNoteResponse_::RespUnion::pg_gen_ResponseError
                ? static_cast<const pg::gen::ResponseError*>(resp())
                : nullptr;
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return resp_type();
            else if constexpr (Index == 1)
                return resp();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_RESP_TYPE)
                && VerifyOffset(verifier, VT_RESP) && VerifyRespUnion(verifier, resp(), resp_type())
                && verifier.EndTable();
        }
        UpdateNoteResponseT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(UpdateNoteResponseT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<UpdateNoteResponse> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const UpdateNoteResponseT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    template<>
    inline const pg::gen::NoteObject* UpdateNoteResponse::resp_as<pg::gen::NoteObject>() const {
        return resp_as_pg_gen_NoteObject();
    }

    template<>
    inline const pg::gen::ResponseError* UpdateNoteResponse::resp_as<pg::gen::ResponseError>() const {
        return resp_as_pg_gen_ResponseError();
    }

    struct UpdateNoteResponseBuilder {
        typedef UpdateNoteResponse Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_resp_type(pg::gen::UpdateNoteResponse_::RespUnion resp_type) {
            fbb_.AddElement<uint8_t>(UpdateNoteResponse::VT_RESP_TYPE, static_cast<uint8_t>(resp_type), 0);
        }
        void add_resp(flatbuffers::Offset<void> resp) {
            fbb_.AddOffset(UpdateNoteResponse::VT_RESP, resp);
        }
        explicit UpdateNoteResponseBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<UpdateNoteResponse> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<UpdateNoteResponse>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<UpdateNoteResponse> CreateUpdateNoteResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        pg::gen::UpdateNoteResponse_::RespUnion resp_type = pg::gen::UpdateNoteResponse_::RespUnion::NONE,
        flatbuffers::Offset<void> resp = 0) {
        UpdateNoteResponseBuilder builder_(_fbb);
        builder_.add_resp(resp);
        builder_.add_resp_type(resp_type);
        return builder_.Finish();
    }

    struct UpdateNoteResponse::Traits {
        using type = UpdateNoteResponse;
        static auto constexpr Create = CreateUpdateNoteResponse;
        static constexpr auto name = "UpdateNoteResponse";
        static constexpr auto fully_qualified_name = "pg.gen.UpdateNoteResponse";
        static constexpr std::array<const char*, 2> field_names = { "resp_type", "resp" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    flatbuffers::Offset<UpdateNoteResponse> CreateUpdateNoteResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        const UpdateNoteResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct UpdateNotesRequestT: public flatbuffers::NativeTable {
        typedef UpdateNotesRequest TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.UpdateNotesRequestT";
        }
        std::vector<std::unique_ptr<pg::gen::UpdateNoteDataT>> targets {};
    };

    inline bool operator==(const UpdateNotesRequestT& lhs, const UpdateNotesRequestT& rhs) {
        return (lhs.targets == rhs.targets);
    }

    inline bool operator!=(const UpdateNotesRequestT& lhs, const UpdateNotesRequestT& rhs) {
        return !(lhs == rhs);
    }

    struct UpdateNotesRequest FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef UpdateNotesRequestT NativeTableType;
        typedef UpdateNotesRequestBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return UpdateNotesRequestTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.UpdateNotesRequest";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TARGETS = 4 };
        const flatbuffers::Vector<flatbuffers::Offset<pg::gen::UpdateNoteData>>* _Nullable targets() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pg::gen::UpdateNoteData>>*>(VT_TARGETS);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return targets();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TARGETS) && verifier.VerifyVector(targets())
                && verifier.VerifyVectorOfTables(targets()) && verifier.EndTable();
        }
        UpdateNotesRequestT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(UpdateNotesRequestT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<UpdateNotesRequest> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const UpdateNotesRequestT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct UpdateNotesRequestBuilder {
        typedef UpdateNotesRequest Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void
        add_targets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::UpdateNoteData>>> targets) {
            fbb_.AddOffset(UpdateNotesRequest::VT_TARGETS, targets);
        }
        explicit UpdateNotesRequestBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<UpdateNotesRequest> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<UpdateNotesRequest>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<UpdateNotesRequest> CreateUpdateNotesRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::UpdateNoteData>>> targets = 0) {
        UpdateNotesRequestBuilder builder_(_fbb);
        builder_.add_targets(targets);
        return builder_.Finish();
    }

    struct UpdateNotesRequest::Traits {
        using type = UpdateNotesRequest;
        static auto constexpr Create = CreateUpdateNotesRequest;
        static constexpr auto name = "UpdateNotesRequest";
        static constexpr auto fully_qualified_name = "pg.gen.UpdateNotesRequest";
        static constexpr std::array<const char*, 1> field_names = { "targets" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    inline flatbuffers::Offset<UpdateNotesRequest> CreateUpdateNotesRequestDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const std::vector<flatbuffers::Offset<pg::gen::UpdateNoteData>>* targets = nullptr) {
        auto targets__ = targets ? _fbb.CreateVector<flatbuffers::Offset<pg::gen::UpdateNoteData>>(*targets) : 0;
        return pg::gen::CreateUpdateNotesRequest(_fbb, targets__);
    }

    flatbuffers::Offset<UpdateNotesRequest> CreateUpdateNotesRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        const UpdateNotesRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct UpdateNotesResponseT: public flatbuffers::NativeTable {
        typedef UpdateNotesResponse TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.UpdateNotesResponseT";
        }
        uint32_t updated_count = 0;
        uint32_t error_count = 0;
        std::vector<std::unique_ptr<pg::gen::NoteObjectT>> updated {};
        std::vector<std::unique_ptr<pg::gen::ResponseErrorT>> errors {};
    };

    inline bool operator==(const UpdateNotesResponseT& lhs, const UpdateNotesResponseT& rhs) {
        return (lhs.updated_count == rhs.updated_count) && (lhs.error_count == rhs.error_count)
            && (lhs.updated == rhs.updated) && (lhs.errors == rhs.errors);
    }

    inline bool operator!=(const UpdateNotesResponseT& lhs, const UpdateNotesResponseT& rhs) {
        return !(lhs == rhs);
    }

    struct UpdateNotesResponse FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef UpdateNotesResponseT NativeTableType;
        typedef UpdateNotesResponseBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return UpdateNotesResponseTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.UpdateNotesResponse";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_UPDATED_COUNT = 4,
            VT_ERROR_COUNT = 6,
            VT_UPDATED = 8,
            VT_ERRORS = 10
        };
        uint32_t updated_count() const {
            return GetField<uint32_t>(VT_UPDATED_COUNT, 0);
        }
        uint32_t error_count() const {
            return GetField<uint32_t>(VT_ERROR_COUNT, 0);
        }
        const flatbuffers::Vector<flatbuffers::Offset<pg::gen::NoteObject>>* _Nullable updated() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pg::gen::NoteObject>>*>(VT_UPDATED);
        }
        const flatbuffers::Vector<flatbuffers::Offset<pg::gen::ResponseError>>* _Nullable errors() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pg::gen::ResponseError>>*>(VT_ERRORS);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return updated_count();
            else if constexpr (Index == 1)
                return error_count();
            else if constexpr (Index == 2)
                return updated();
            else if constexpr (Index == 3)
                return errors();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_UPDATED_COUNT)
                && VerifyField<uint32_t>(verifier, VT_ERROR_COUNT) && VerifyOffset(verifier, VT_UPDATED)
                && verifier.VerifyVector(updated()) && verifier.VerifyVectorOfTables(updated())
                && VerifyOffset(verifier, VT_ERRORS) && verifier.VerifyVector(errors())
                && verifier.VerifyVectorOfTables(errors()) && verifier.EndTable();
        }
        UpdateNotesResponseT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(UpdateNotesResponseT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<UpdateNotesResponse> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const UpdateNotesResponseT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct UpdateNotesResponseBuilder {
        typedef UpdateNotesResponse Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_updated_count(uint32_t updated_count) {
            fbb_.AddElement<uint32_t>(UpdateNotesResponse::VT_UPDATED_COUNT, updated_count, 0);
        }
        void add_error_count(uint32_t error_count) {
            fbb_.AddElement<uint32_t>(UpdateNotesResponse::VT_ERROR_COUNT, error_count, 0);
        }
        void add_updated(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::NoteObject>>> updated) {
            fbb_.AddOffset(UpdateNotesResponse::VT_UPDATED, updated);
        }
        void add_errors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::ResponseError>>> errors) {
            fbb_.AddOffset(UpdateNotesResponse::VT_ERRORS, errors);
        }
        explicit UpdateNotesResponseBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<UpdateNotesResponse> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<UpdateNotesResponse>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<UpdateNotesResponse> CreateUpdateNotesResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        uint32_t updated_count = 0,
        uint32_t error_count = 0,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::NoteObject>>> updated = 0,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::ResponseError>>> errors = 0) {
        UpdateNotesResponseBuilder builder_(_fbb);
        builder_.add_errors(errors);
        builder_.add_updated(updated);
        builder_.add_error_count(error_count);
        builder_.add_updated_count(updated_count);
        return builder_.Finish();
    }

    struct UpdateNotesResponse::Traits {
        using type = UpdateNotesResponse;
        static auto constexpr Create = CreateUpdateNotesResponse;
        static constexpr auto name = "UpdateNotesResponse";
        static constexpr auto fully_qualified_name = "pg.gen.UpdateNotesResponse";
        static constexpr std::array<const char*, 4> field_names = { "updated_count",
                                                                    "error_count",
                                                                    "updated",
                                                                    "errors" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 4;
    };

    inline flatbuffers::Offset<UpdateNotesResponse> CreateUpdateNotesResponseDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        uint32_t updated_count = 0,
        uint32_t error_count = 0,
        const std::vector<flatbuffers::Offset<pg::gen::NoteObject>>* updated = nullptr,
        const std::vector<flatbuffers::Offset<pg::gen::ResponseError>>* errors = nullptr) {
        auto updated__ = updated ? _fbb.CreateVector<flatbuffers::Offset<pg::gen::NoteObject>>(*updated) : 0;
        auto errors__ = errors ? _fbb.CreateVector<flatbuffers::Offset<pg::gen::ResponseError>>(*errors) : 0;
        return pg::gen::CreateUpdateNotesResponse(_fbb, updated_count, error_count, updated__, errors__);
    }

    flatbuffers::Offset<UpdateNotesResponse> CreateUpdateNotesResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        const UpdateNotesResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct DeleteNoteDataT: public flatbuffers::NativeTable {
        typedef DeleteNoteData TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.DeleteNoteDataT";
        }
        std::string id {};
    };

    inline bool operator==(const DeleteNoteDataT& lhs, const DeleteNoteDataT& rhs) {
        return (lhs.id == rhs.id);
    }

    inline bool operator!=(const DeleteNoteDataT& lhs, const DeleteNoteDataT& rhs) {
        return !(lhs == rhs);
    }

    struct DeleteNoteData FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef DeleteNoteDataT NativeTableType;
        typedef DeleteNoteDataBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return DeleteNoteDataTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.DeleteNoteData";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_ID = 4 };
        const flatbuffers::String* _Nullable id() const {
            return GetPointer<const flatbuffers::String*>(VT_ID);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return id();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ID) && verifier.VerifyString(id())
                && verifier.EndTable();
        }
        DeleteNoteDataT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(DeleteNoteDataT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<DeleteNoteData> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const DeleteNoteDataT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct DeleteNoteDataBuilder {
        typedef DeleteNoteData Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_id(flatbuffers::Offset<flatbuffers::String> id) {
            fbb_.AddOffset(DeleteNoteData::VT_ID, id);
        }
        explicit DeleteNoteDataBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<DeleteNoteData> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<DeleteNoteData>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<DeleteNoteData>
    CreateDeleteNoteData(flatbuffers::FlatBufferBuilder& _fbb, flatbuffers::Offset<flatbuffers::String> id = 0) {
        DeleteNoteDataBuilder builder_(_fbb);
        builder_.add_id(id);
        return builder_.Finish();
    }

    struct DeleteNoteData::Traits {
        using type = DeleteNoteData;
        static auto constexpr Create = CreateDeleteNoteData;
        static constexpr auto name = "DeleteNoteData";
        static constexpr auto fully_qualified_name = "pg.gen.DeleteNoteData";
        static constexpr std::array<const char*, 1> field_names = { "id" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    inline flatbuffers::Offset<DeleteNoteData>
    CreateDeleteNoteDataDirect(flatbuffers::FlatBufferBuilder& _fbb, const char* id = nullptr) {
        auto id__ = id ? _fbb.CreateString(id) : 0;
        return pg::gen::CreateDeleteNoteData(_fbb, id__);
    }

    flatbuffers::Offset<DeleteNoteData> CreateDeleteNoteData(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DeleteNoteDataT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct DeleteNoteRequestT: public flatbuffers::NativeTable {
        typedef DeleteNoteRequest TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.DeleteNoteRequestT";
        }
        std::unique_ptr<pg::gen::DeleteNoteDataT> target {};
    };

    inline bool operator==(const DeleteNoteRequestT& lhs, const DeleteNoteRequestT& rhs) {
        return (lhs.target == rhs.target);
    }

    inline bool operator!=(const DeleteNoteRequestT& lhs, const DeleteNoteRequestT& rhs) {
        return !(lhs == rhs);
    }

    struct DeleteNoteRequest FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef DeleteNoteRequestT NativeTableType;
        typedef DeleteNoteRequestBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return DeleteNoteRequestTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.DeleteNoteRequest";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TARGET = 4 };
        const pg::gen::DeleteNoteData* _Nullable target() const {
            return GetPointer<const pg::gen::DeleteNoteData*>(VT_TARGET);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return target();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TARGET) && verifier.VerifyTable(target())
                && verifier.EndTable();
        }
        DeleteNoteRequestT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(DeleteNoteRequestT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<DeleteNoteRequest> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const DeleteNoteRequestT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct DeleteNoteRequestBuilder {
        typedef DeleteNoteRequest Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_target(flatbuffers::Offset<pg::gen::DeleteNoteData> target) {
            fbb_.AddOffset(DeleteNoteRequest::VT_TARGET, target);
        }
        explicit DeleteNoteRequestBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<DeleteNoteRequest> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<DeleteNoteRequest>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<DeleteNoteRequest> CreateDeleteNoteRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<pg::gen::DeleteNoteData> target = 0) {
        DeleteNoteRequestBuilder builder_(_fbb);
        builder_.add_target(target);
        return builder_.Finish();
    }

    struct DeleteNoteRequest::Traits {
        using type = DeleteNoteRequest;
        static auto constexpr Create = CreateDeleteNoteRequest;
        static constexpr auto name = "DeleteNoteRequest";
        static constexpr auto fully_qualified_name = "pg.gen.DeleteNoteRequest";
        static constexpr std::array<const char*, 1> field_names = { "target" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    flatbuffers::Offset<DeleteNoteRequest> CreateDeleteNoteRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DeleteNoteRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct BooleanT: public flatbuffers::NativeTable {
        typedef Boolean TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.BooleanT";
        }
        bool value = false;
    };

    inline bool operator==(const BooleanT& lhs, const BooleanT& rhs) {
        return (lhs.value == rhs.value);
    }

    inline bool operator!=(const BooleanT& lhs, const BooleanT& rhs) {
        return !(lhs == rhs);
    }

    struct Boolean FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef BooleanT NativeTableType;
        typedef BooleanBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return BooleanTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.Boolean";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4 };
        bool value() const {
            return GetField<uint8_t>(VT_VALUE, 0) != 0;
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return value();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_VALUE) && verifier.EndTable();
        }
        BooleanT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(BooleanT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<Boolean> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const BooleanT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct BooleanBuilder {
        typedef Boolean Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_value(bool value) {
            fbb_.AddElement<uint8_t>(Boolean::VT_VALUE, static_cast<uint8_t>(value), 0);
        }
        explicit BooleanBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<Boolean> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Boolean>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Boolean> CreateBoolean(flatbuffers::FlatBufferBuilder& _fbb, bool value = false) {
        BooleanBuilder builder_(_fbb);
        builder_.add_value(value);
        return builder_.Finish();
    }

    struct Boolean::Traits {
        using type = Boolean;
        static auto constexpr Create = CreateBoolean;
        static constexpr auto name = "Boolean";
        static constexpr auto fully_qualified_name = "pg.gen.Boolean";
        static constexpr std::array<const char*, 1> field_names = { "value" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    flatbuffers::Offset<Boolean> CreateBoolean(
        flatbuffers::FlatBufferBuilder& _fbb,
        const BooleanT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct DeleteNoteResponseT: public flatbuffers::NativeTable {
        typedef DeleteNoteResponse TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.DeleteNoteResponseT";
        }
        pg::gen::DeleteNoteResponse_::RespUnionUnion resp {};
    };

    inline bool operator==(const DeleteNoteResponseT& lhs, const DeleteNoteResponseT& rhs) {
        return (lhs.resp == rhs.resp);
    }

    inline bool operator!=(const DeleteNoteResponseT& lhs, const DeleteNoteResponseT& rhs) {
        return !(lhs == rhs);
    }

    struct DeleteNoteResponse FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef DeleteNoteResponseT NativeTableType;
        typedef DeleteNoteResponseBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return DeleteNoteResponseTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.DeleteNoteResponse";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_RESP_TYPE = 4, VT_RESP = 6 };
        pg::gen::DeleteNoteResponse_::RespUnion resp_type() const {
            return static_cast<pg::gen::DeleteNoteResponse_::RespUnion>(GetField<uint8_t>(VT_RESP_TYPE, 0));
        }
        const void* _Nullable resp() const {
            return GetPointer<const void*>(VT_RESP);
        }
        template<typename T>
        const T* _Nullable resp_as() const;
        const pg::gen::Boolean* _Nullable resp_as_pg_gen_Boolean() const {
            return resp_type() == pg::gen::DeleteNoteResponse_::RespUnion::pg_gen_Boolean
                ? static_cast<const pg::gen::Boolean*>(resp())
                : nullptr;
        }
        const pg::gen::ResponseError* _Nullable resp_as_pg_gen_ResponseError() const {
            return resp_type() == pg::gen::DeleteNoteResponse_::RespUnion::pg_gen_ResponseError
                ? static_cast<const pg::gen::ResponseError*>(resp())
                : nullptr;
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return resp_type();
            else if constexpr (Index == 1)
                return resp();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_RESP_TYPE)
                && VerifyOffset(verifier, VT_RESP) && VerifyRespUnion(verifier, resp(), resp_type())
                && verifier.EndTable();
        }
        DeleteNoteResponseT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(DeleteNoteResponseT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<DeleteNoteResponse> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const DeleteNoteResponseT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    template<>
    inline const pg::gen::Boolean* DeleteNoteResponse::resp_as<pg::gen::Boolean>() const {
        return resp_as_pg_gen_Boolean();
    }

    template<>
    inline const pg::gen::ResponseError* DeleteNoteResponse::resp_as<pg::gen::ResponseError>() const {
        return resp_as_pg_gen_ResponseError();
    }

    struct DeleteNoteResponseBuilder {
        typedef DeleteNoteResponse Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_resp_type(pg::gen::DeleteNoteResponse_::RespUnion resp_type) {
            fbb_.AddElement<uint8_t>(DeleteNoteResponse::VT_RESP_TYPE, static_cast<uint8_t>(resp_type), 0);
        }
        void add_resp(flatbuffers::Offset<void> resp) {
            fbb_.AddOffset(DeleteNoteResponse::VT_RESP, resp);
        }
        explicit DeleteNoteResponseBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<DeleteNoteResponse> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<DeleteNoteResponse>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<DeleteNoteResponse> CreateDeleteNoteResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        pg::gen::DeleteNoteResponse_::RespUnion resp_type = pg::gen::DeleteNoteResponse_::RespUnion::NONE,
        flatbuffers::Offset<void> resp = 0) {
        DeleteNoteResponseBuilder builder_(_fbb);
        builder_.add_resp(resp);
        builder_.add_resp_type(resp_type);
        return builder_.Finish();
    }

    struct DeleteNoteResponse::Traits {
        using type = DeleteNoteResponse;
        static auto constexpr Create = CreateDeleteNoteResponse;
        static constexpr auto name = "DeleteNoteResponse";
        static constexpr auto fully_qualified_name = "pg.gen.DeleteNoteResponse";
        static constexpr std::array<const char*, 2> field_names = { "resp_type", "resp" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    flatbuffers::Offset<DeleteNoteResponse> CreateDeleteNoteResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DeleteNoteResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct DeleteNotesRequestT: public flatbuffers::NativeTable {
        typedef DeleteNotesRequest TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.DeleteNotesRequestT";
        }
        std::vector<std::unique_ptr<pg::gen::DeleteNoteDataT>> targets {};
    };

    inline bool operator==(const DeleteNotesRequestT& lhs, const DeleteNotesRequestT& rhs) {
        return (lhs.targets == rhs.targets);
    }

    inline bool operator!=(const DeleteNotesRequestT& lhs, const DeleteNotesRequestT& rhs) {
        return !(lhs == rhs);
    }

    struct DeleteNotesRequest FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef DeleteNotesRequestT NativeTableType;
        typedef DeleteNotesRequestBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return DeleteNotesRequestTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.DeleteNotesRequest";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TARGETS = 4 };
        const flatbuffers::Vector<flatbuffers::Offset<pg::gen::DeleteNoteData>>* _Nullable targets() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pg::gen::DeleteNoteData>>*>(VT_TARGETS);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return targets();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TARGETS) && verifier.VerifyVector(targets())
                && verifier.VerifyVectorOfTables(targets()) && verifier.EndTable();
        }
        DeleteNotesRequestT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(DeleteNotesRequestT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<DeleteNotesRequest> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const DeleteNotesRequestT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct DeleteNotesRequestBuilder {
        typedef DeleteNotesRequest Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void
        add_targets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::DeleteNoteData>>> targets) {
            fbb_.AddOffset(DeleteNotesRequest::VT_TARGETS, targets);
        }
        explicit DeleteNotesRequestBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<DeleteNotesRequest> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<DeleteNotesRequest>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<DeleteNotesRequest> CreateDeleteNotesRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::DeleteNoteData>>> targets = 0) {
        DeleteNotesRequestBuilder builder_(_fbb);
        builder_.add_targets(targets);
        return builder_.Finish();
    }

    struct DeleteNotesRequest::Traits {
        using type = DeleteNotesRequest;
        static auto constexpr Create = CreateDeleteNotesRequest;
        static constexpr auto name = "DeleteNotesRequest";
        static constexpr auto fully_qualified_name = "pg.gen.DeleteNotesRequest";
        static constexpr std::array<const char*, 1> field_names = { "targets" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    inline flatbuffers::Offset<DeleteNotesRequest> CreateDeleteNotesRequestDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const std::vector<flatbuffers::Offset<pg::gen::DeleteNoteData>>* targets = nullptr) {
        auto targets__ = targets ? _fbb.CreateVector<flatbuffers::Offset<pg::gen::DeleteNoteData>>(*targets) : 0;
        return pg::gen::CreateDeleteNotesRequest(_fbb, targets__);
    }

    flatbuffers::Offset<DeleteNotesRequest> CreateDeleteNotesRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DeleteNotesRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct DeleteNotesResponseT: public flatbuffers::NativeTable {
        typedef DeleteNotesResponse TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.DeleteNotesResponseT";
        }
        uint32_t deleted_count = 0;
        std::vector<std::unique_ptr<pg::gen::ResponseErrorT>> errors {};
    };

    inline bool operator==(const DeleteNotesResponseT& lhs, const DeleteNotesResponseT& rhs) {
        return (lhs.deleted_count == rhs.deleted_count) && (lhs.errors == rhs.errors);
    }

    inline bool operator!=(const DeleteNotesResponseT& lhs, const DeleteNotesResponseT& rhs) {
        return !(lhs == rhs);
    }

    struct DeleteNotesResponse FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef DeleteNotesResponseT NativeTableType;
        typedef DeleteNotesResponseBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return DeleteNotesResponseTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.DeleteNotesResponse";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_DELETED_COUNT = 4, VT_ERRORS = 6 };
        uint32_t deleted_count() const {
            return GetField<uint32_t>(VT_DELETED_COUNT, 0);
        }
        const flatbuffers::Vector<flatbuffers::Offset<pg::gen::ResponseError>>* _Nullable errors() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pg::gen::ResponseError>>*>(VT_ERRORS);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return deleted_count();
            else if constexpr (Index == 1)
                return errors();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_DELETED_COUNT)
                && VerifyOffset(verifier, VT_ERRORS) && verifier.VerifyVector(errors())
                && verifier.VerifyVectorOfTables(errors()) && verifier.EndTable();
        }
        DeleteNotesResponseT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(DeleteNotesResponseT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<DeleteNotesResponse> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const DeleteNotesResponseT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct DeleteNotesResponseBuilder {
        typedef DeleteNotesResponse Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_deleted_count(uint32_t deleted_count) {
            fbb_.AddElement<uint32_t>(DeleteNotesResponse::VT_DELETED_COUNT, deleted_count, 0);
        }
        void add_errors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::ResponseError>>> errors) {
            fbb_.AddOffset(DeleteNotesResponse::VT_ERRORS, errors);
        }
        explicit DeleteNotesResponseBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<DeleteNotesResponse> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<DeleteNotesResponse>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<DeleteNotesResponse> CreateDeleteNotesResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        uint32_t deleted_count = 0,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::ResponseError>>> errors = 0) {
        DeleteNotesResponseBuilder builder_(_fbb);
        builder_.add_errors(errors);
        builder_.add_deleted_count(deleted_count);
        return builder_.Finish();
    }

    struct DeleteNotesResponse::Traits {
        using type = DeleteNotesResponse;
        static auto constexpr Create = CreateDeleteNotesResponse;
        static constexpr auto name = "DeleteNotesResponse";
        static constexpr auto fully_qualified_name = "pg.gen.DeleteNotesResponse";
        static constexpr std::array<const char*, 2> field_names = { "deleted_count", "errors" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    inline flatbuffers::Offset<DeleteNotesResponse> CreateDeleteNotesResponseDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        uint32_t deleted_count = 0,
        const std::vector<flatbuffers::Offset<pg::gen::ResponseError>>* errors = nullptr) {
        auto errors__ = errors ? _fbb.CreateVector<flatbuffers::Offset<pg::gen::ResponseError>>(*errors) : 0;
        return pg::gen::CreateDeleteNotesResponse(_fbb, deleted_count, errors__);
    }

    flatbuffers::Offset<DeleteNotesResponse> CreateDeleteNotesResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DeleteNotesResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct ListNotesRequestT: public flatbuffers::NativeTable {
        typedef ListNotesRequest TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.ListNotesRequestT";
        }
        int32_t page_size = 0;
        std::string page_token {};
    };

    inline bool operator==(const ListNotesRequestT& lhs, const ListNotesRequestT& rhs) {
        return (lhs.page_size == rhs.page_size) && (lhs.page_token == rhs.page_token);
    }

    inline bool operator!=(const ListNotesRequestT& lhs, const ListNotesRequestT& rhs) {
        return !(lhs == rhs);
    }

    struct ListNotesRequest FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef ListNotesRequestT NativeTableType;
        typedef ListNotesRequestBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return ListNotesRequestTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.ListNotesRequest";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_PAGE_SIZE = 4, VT_PAGE_TOKEN = 6 };
        int32_t page_size() const {
            return GetField<int32_t>(VT_PAGE_SIZE, 0);
        }
        const flatbuffers::String* _Nullable page_token() const {
            return GetPointer<const flatbuffers::String*>(VT_PAGE_TOKEN);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return page_size();
            else if constexpr (Index == 1)
                return page_token();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_PAGE_SIZE)
                && VerifyOffset(verifier, VT_PAGE_TOKEN) && verifier.VerifyString(page_token()) && verifier.EndTable();
        }
        ListNotesRequestT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(ListNotesRequestT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<ListNotesRequest> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const ListNotesRequestT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct ListNotesRequestBuilder {
        typedef ListNotesRequest Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_page_size(int32_t page_size) {
            fbb_.AddElement<int32_t>(ListNotesRequest::VT_PAGE_SIZE, page_size, 0);
        }
        void add_page_token(flatbuffers::Offset<flatbuffers::String> page_token) {
            fbb_.AddOffset(ListNotesRequest::VT_PAGE_TOKEN, page_token);
        }
        explicit ListNotesRequestBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<ListNotesRequest> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<ListNotesRequest>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<ListNotesRequest> CreateListNotesRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        int32_t page_size = 0,
        flatbuffers::Offset<flatbuffers::String> page_token = 0) {
        ListNotesRequestBuilder builder_(_fbb);
        builder_.add_page_token(page_token);
        builder_.add_page_size(page_size);
        return builder_.Finish();
    }

    struct ListNotesRequest::Traits {
        using type = ListNotesRequest;
        static auto constexpr Create = CreateListNotesRequest;
        static constexpr auto name = "ListNotesRequest";
        static constexpr auto fully_qualified_name = "pg.gen.ListNotesRequest";
        static constexpr std::array<const char*, 2> field_names = { "page_size", "page_token" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    inline flatbuffers::Offset<ListNotesRequest> CreateListNotesRequestDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        int32_t page_size = 0,
        const char* page_token = nullptr) {
        auto page_token__ = page_token ? _fbb.CreateString(page_token) : 0;
        return pg::gen::CreateListNotesRequest(_fbb, page_size, page_token__);
    }

    flatbuffers::Offset<ListNotesRequest> CreateListNotesRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ListNotesRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct ListNotesResponseT: public flatbuffers::NativeTable {
        typedef ListNotesResponse TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.ListNotesResponseT";
        }
        std::vector<std::unique_ptr<pg::gen::NoteObjectT>> notes {};
        std::string next_page_token {};
    };

    inline bool operator==(const ListNotesResponseT& lhs, const ListNotesResponseT& rhs) {
        return (lhs.notes == rhs.notes) && (lhs.next_page_token == rhs.next_page_token);
    }

    inline bool operator!=(const ListNotesResponseT& lhs, const ListNotesResponseT& rhs) {
        return !(lhs == rhs);
    }

    struct ListNotesResponse FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef ListNotesResponseT NativeTableType;
        typedef ListNotesResponseBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return ListNotesResponseTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.ListNotesResponse";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NOTES = 4, VT_NEXT_PAGE_TOKEN = 6 };
        const flatbuffers::Vector<flatbuffers::Offset<pg::gen::NoteObject>>* _Nullable notes() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pg::gen::NoteObject>>*>(VT_NOTES);
        }
        const flatbuffers::String* _Nullable next_page_token() const {
            return GetPointer<const flatbuffers::String*>(VT_NEXT_PAGE_TOKEN);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return notes();
            else if constexpr (Index == 1)
                return next_page_token();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NOTES) && verifier.VerifyVector(notes())
                && verifier.VerifyVectorOfTables(notes()) && VerifyOffset(verifier, VT_NEXT_PAGE_TOKEN)
                && verifier.VerifyString(next_page_token()) && verifier.EndTable();
        }
        ListNotesResponseT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(ListNotesResponseT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<ListNotesResponse> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const ListNotesResponseT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct ListNotesResponseBuilder {
        typedef ListNotesResponse Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_notes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::NoteObject>>> notes) {
            fbb_.AddOffset(ListNotesResponse::VT_NOTES, notes);
        }
        void add_next_page_token(flatbuffers::Offset<flatbuffers::String> next_page_token) {
            fbb_.AddOffset(ListNotesResponse::VT_NEXT_PAGE_TOKEN, next_page_token);
        }
        explicit ListNotesResponseBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<ListNotesResponse> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<ListNotesResponse>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<ListNotesResponse> CreateListNotesResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::NoteObject>>> notes = 0,
        flatbuffers::Offset<flatbuffers::String> next_page_token = 0) {
        ListNotesResponseBuilder builder_(_fbb);
        builder_.add_next_page_token(next_page_token);
        builder_.add_notes(notes);
        return builder_.Finish();
    }

    struct ListNotesResponse::Traits {
        using type = ListNotesResponse;
        static auto constexpr Create = CreateListNotesResponse;
        static constexpr auto name = "ListNotesResponse";
        static constexpr auto fully_qualified_name = "pg.gen.ListNotesResponse";
        static constexpr std::array<const char*, 2> field_names = { "notes", "next_page_token" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    inline flatbuffers::Offset<ListNotesResponse> CreateListNotesResponseDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const std::vector<flatbuffers::Offset<pg::gen::NoteObject>>* notes = nullptr,
        const char* next_page_token = nullptr) {
        auto notes__ = notes ? _fbb.CreateVector<flatbuffers::Offset<pg::gen::NoteObject>>(*notes) : 0;
        auto next_page_token__ = next_page_token ? _fbb.CreateString(next_page_token) : 0;
        return pg::gen::CreateListNotesResponse(_fbb, notes__, next_page_token__);
    }

    flatbuffers::Offset<ListNotesResponse> CreateListNotesResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ListNotesResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct GetNoteRequestT: public flatbuffers::NativeTable {
        typedef GetNoteRequest TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.GetNoteRequestT";
        }
        std::string id {};
    };

    inline bool operator==(const GetNoteRequestT& lhs, const GetNoteRequestT& rhs) {
        return (lhs.id == rhs.id);
    }

    inline bool operator!=(const GetNoteRequestT& lhs, const GetNoteRequestT& rhs) {
        return !(lhs == rhs);
    }

    struct GetNoteRequest FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef GetNoteRequestT NativeTableType;
        typedef GetNoteRequestBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return GetNoteRequestTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.GetNoteRequest";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_ID = 4 };
        const flatbuffers::String* _Nullable id() const {
            return GetPointer<const flatbuffers::String*>(VT_ID);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return id();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ID) && verifier.VerifyString(id())
                && verifier.EndTable();
        }
        GetNoteRequestT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(GetNoteRequestT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<GetNoteRequest> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const GetNoteRequestT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct GetNoteRequestBuilder {
        typedef GetNoteRequest Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_id(flatbuffers::Offset<flatbuffers::String> id) {
            fbb_.AddOffset(GetNoteRequest::VT_ID, id);
        }
        explicit GetNoteRequestBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<GetNoteRequest> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<GetNoteRequest>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<GetNoteRequest>
    CreateGetNoteRequest(flatbuffers::FlatBufferBuilder& _fbb, flatbuffers::Offset<flatbuffers::String> id = 0) {
        GetNoteRequestBuilder builder_(_fbb);
        builder_.add_id(id);
        return builder_.Finish();
    }

    struct GetNoteRequest::Traits {
        using type = GetNoteRequest;
        static auto constexpr Create = CreateGetNoteRequest;
        static constexpr auto name = "GetNoteRequest";
        static constexpr auto fully_qualified_name = "pg.gen.GetNoteRequest";
        static constexpr std::array<const char*, 1> field_names = { "id" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    inline flatbuffers::Offset<GetNoteRequest>
    CreateGetNoteRequestDirect(flatbuffers::FlatBufferBuilder& _fbb, const char* id = nullptr) {
        auto id__ = id ? _fbb.CreateString(id) : 0;
        return pg::gen::CreateGetNoteRequest(_fbb, id__);
    }

    flatbuffers::Offset<GetNoteRequest> CreateGetNoteRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        const GetNoteRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct GetNoteResponseT: public flatbuffers::NativeTable {
        typedef GetNoteResponse TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.GetNoteResponseT";
        }
        pg::gen::GetNoteResponse_::RespUnionUnion resp {};
    };

    inline bool operator==(const GetNoteResponseT& lhs, const GetNoteResponseT& rhs) {
        return (lhs.resp == rhs.resp);
    }

    inline bool operator!=(const GetNoteResponseT& lhs, const GetNoteResponseT& rhs) {
        return !(lhs == rhs);
    }

    struct GetNoteResponse FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef GetNoteResponseT NativeTableType;
        typedef GetNoteResponseBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return GetNoteResponseTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.GetNoteResponse";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_RESP_TYPE = 4, VT_RESP = 6 };
        pg::gen::GetNoteResponse_::RespUnion resp_type() const {
            return static_cast<pg::gen::GetNoteResponse_::RespUnion>(GetField<uint8_t>(VT_RESP_TYPE, 0));
        }
        const void* _Nullable resp() const {
            return GetPointer<const void*>(VT_RESP);
        }
        template<typename T>
        const T* _Nullable resp_as() const;
        const pg::gen::NoteObject* _Nullable resp_as_pg_gen_NoteObject() const {
            return resp_type() == pg::gen::GetNoteResponse_::RespUnion::pg_gen_NoteObject
                ? static_cast<const pg::gen::NoteObject*>(resp())
                : nullptr;
        }
        const pg::gen::ResponseError* _Nullable resp_as_pg_gen_ResponseError() const {
            return resp_type() == pg::gen::GetNoteResponse_::RespUnion::pg_gen_ResponseError
                ? static_cast<const pg::gen::ResponseError*>(resp())
                : nullptr;
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return resp_type();
            else if constexpr (Index == 1)
                return resp();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_RESP_TYPE)
                && VerifyOffset(verifier, VT_RESP) && VerifyRespUnion(verifier, resp(), resp_type())
                && verifier.EndTable();
        }
        GetNoteResponseT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(GetNoteResponseT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<GetNoteResponse> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const GetNoteResponseT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    template<>
    inline const pg::gen::NoteObject* GetNoteResponse::resp_as<pg::gen::NoteObject>() const {
        return resp_as_pg_gen_NoteObject();
    }

    template<>
    inline const pg::gen::ResponseError* GetNoteResponse::resp_as<pg::gen::ResponseError>() const {
        return resp_as_pg_gen_ResponseError();
    }

    struct GetNoteResponseBuilder {
        typedef GetNoteResponse Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_resp_type(pg::gen::GetNoteResponse_::RespUnion resp_type) {
            fbb_.AddElement<uint8_t>(GetNoteResponse::VT_RESP_TYPE, static_cast<uint8_t>(resp_type), 0);
        }
        void add_resp(flatbuffers::Offset<void> resp) {
            fbb_.AddOffset(GetNoteResponse::VT_RESP, resp);
        }
        explicit GetNoteResponseBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<GetNoteResponse> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<GetNoteResponse>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<GetNoteResponse> CreateGetNoteResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        pg::gen::GetNoteResponse_::RespUnion resp_type = pg::gen::GetNoteResponse_::RespUnion::NONE,
        flatbuffers::Offset<void> resp = 0) {
        GetNoteResponseBuilder builder_(_fbb);
        builder_.add_resp(resp);
        builder_.add_resp_type(resp_type);
        return builder_.Finish();
    }

    struct GetNoteResponse::Traits {
        using type = GetNoteResponse;
        static auto constexpr Create = CreateGetNoteResponse;
        static constexpr auto name = "GetNoteResponse";
        static constexpr auto fully_qualified_name = "pg.gen.GetNoteResponse";
        static constexpr std::array<const char*, 2> field_names = { "resp_type", "resp" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 2;
    };

    flatbuffers::Offset<GetNoteResponse> CreateGetNoteResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        const GetNoteResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct NoteObjectT: public flatbuffers::NativeTable {
        typedef NoteObject TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.NoteObjectT";
        }
        std::string id {};
        std::string title {};
        std::string content {};
        std::vector<std::string> tags {};
        std::unique_ptr<pg::gen::TimestampT> created {};
        std::unique_ptr<pg::gen::TimestampT> updated {};
    };

    inline bool operator==(const NoteObjectT& lhs, const NoteObjectT& rhs) {
        return (lhs.id == rhs.id) && (lhs.title == rhs.title) && (lhs.content == rhs.content) && (lhs.tags == rhs.tags)
            && (lhs.created == rhs.created) && (lhs.updated == rhs.updated);
    }

    inline bool operator!=(const NoteObjectT& lhs, const NoteObjectT& rhs) {
        return !(lhs == rhs);
    }

    struct NoteObject FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef NoteObjectT NativeTableType;
        typedef NoteObjectBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return NoteObjectTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.NoteObject";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_ID = 4,
            VT_TITLE = 6,
            VT_CONTENT = 8,
            VT_TAGS = 10,
            VT_CREATED = 12,
            VT_UPDATED = 14
        };
        const flatbuffers::String* _Nullable id() const {
            return GetPointer<const flatbuffers::String*>(VT_ID);
        }
        const flatbuffers::String* _Nullable title() const {
            return GetPointer<const flatbuffers::String*>(VT_TITLE);
        }
        const flatbuffers::String* _Nullable content() const {
            return GetPointer<const flatbuffers::String*>(VT_CONTENT);
        }
        const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>* _Nullable tags() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>*>(VT_TAGS);
        }
        const pg::gen::Timestamp* _Nullable created() const {
            return GetPointer<const pg::gen::Timestamp*>(VT_CREATED);
        }
        const pg::gen::Timestamp* _Nullable updated() const {
            return GetPointer<const pg::gen::Timestamp*>(VT_UPDATED);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return id();
            else if constexpr (Index == 1)
                return title();
            else if constexpr (Index == 2)
                return content();
            else if constexpr (Index == 3)
                return tags();
            else if constexpr (Index == 4)
                return created();
            else if constexpr (Index == 5)
                return updated();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ID) && verifier.VerifyString(id())
                && VerifyOffset(verifier, VT_TITLE) && verifier.VerifyString(title())
                && VerifyOffset(verifier, VT_CONTENT) && verifier.VerifyString(content())
                && VerifyOffset(verifier, VT_TAGS) && verifier.VerifyVector(tags())
                && verifier.VerifyVectorOfStrings(tags()) && VerifyOffset(verifier, VT_CREATED)
                && verifier.VerifyTable(created()) && VerifyOffset(verifier, VT_UPDATED)
                && verifier.VerifyTable(updated()) && verifier.EndTable();
        }
        NoteObjectT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(NoteObjectT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<NoteObject> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const NoteObjectT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct NoteObjectBuilder {
        typedef NoteObject Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_id(flatbuffers::Offset<flatbuffers::String> id) {
            fbb_.AddOffset(NoteObject::VT_ID, id);
        }
        void add_title(flatbuffers::Offset<flatbuffers::String> title) {
            fbb_.AddOffset(NoteObject::VT_TITLE, title);
        }
        void add_content(flatbuffers::Offset<flatbuffers::String> content) {
            fbb_.AddOffset(NoteObject::VT_CONTENT, content);
        }
        void add_tags(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tags) {
            fbb_.AddOffset(NoteObject::VT_TAGS, tags);
        }
        void add_created(flatbuffers::Offset<pg::gen::Timestamp> created) {
            fbb_.AddOffset(NoteObject::VT_CREATED, created);
        }
        void add_updated(flatbuffers::Offset<pg::gen::Timestamp> updated) {
            fbb_.AddOffset(NoteObject::VT_UPDATED, updated);
        }
        explicit NoteObjectBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<NoteObject> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<NoteObject>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<NoteObject> CreateNoteObject(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::String> id = 0,
        flatbuffers::Offset<flatbuffers::String> title = 0,
        flatbuffers::Offset<flatbuffers::String> content = 0,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tags = 0,
        flatbuffers::Offset<pg::gen::Timestamp> created = 0,
        flatbuffers::Offset<pg::gen::Timestamp> updated = 0) {
        NoteObjectBuilder builder_(_fbb);
        builder_.add_updated(updated);
        builder_.add_created(created);
        builder_.add_tags(tags);
        builder_.add_content(content);
        builder_.add_title(title);
        builder_.add_id(id);
        return builder_.Finish();
    }

    struct NoteObject::Traits {
        using type = NoteObject;
        static auto constexpr Create = CreateNoteObject;
        static constexpr auto name = "NoteObject";
        static constexpr auto fully_qualified_name = "pg.gen.NoteObject";
        static constexpr std::array<const char*, 6> field_names = { "id",   "title",   "content",
                                                                    "tags", "created", "updated" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 6;
    };

    inline flatbuffers::Offset<NoteObject> CreateNoteObjectDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const char* id = nullptr,
        const char* title = nullptr,
        const char* content = nullptr,
        const std::vector<flatbuffers::Offset<flatbuffers::String>>* tags = nullptr,
        flatbuffers::Offset<pg::gen::Timestamp> created = 0,
        flatbuffers::Offset<pg::gen::Timestamp> updated = 0) {
        auto id__ = id ? _fbb.CreateString(id) : 0;
        auto title__ = title ? _fbb.CreateString(title) : 0;
        auto content__ = content ? _fbb.CreateString(content) : 0;
        auto tags__ = tags ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tags) : 0;
        return pg::gen::CreateNoteObject(_fbb, id__, title__, content__, tags__, created, updated);
    }

    flatbuffers::Offset<NoteObject> CreateNoteObject(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteObjectT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    struct NoteStorageT: public flatbuffers::NativeTable {
        typedef NoteStorage TableType;
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.NoteStorageT";
        }
        std::vector<std::unique_ptr<pg::gen::NoteObjectT>> notes {};
    };

    inline bool operator==(const NoteStorageT& lhs, const NoteStorageT& rhs) {
        return (lhs.notes == rhs.notes);
    }

    inline bool operator!=(const NoteStorageT& lhs, const NoteStorageT& rhs) {
        return !(lhs == rhs);
    }

    struct NoteStorage FLATBUFFERS_FINAL_CLASS: private flatbuffers::Table {
        typedef NoteStorageT NativeTableType;
        typedef NoteStorageBuilder Builder;
        struct Traits;
        static const flatbuffers::TypeTable* MiniReflectTypeTable() {
            return NoteStorageTypeTable();
        }
        static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName() {
            return "pg.gen.NoteStorage";
        }
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NOTES = 4 };
        const flatbuffers::Vector<flatbuffers::Offset<pg::gen::NoteObject>>* _Nullable notes() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pg::gen::NoteObject>>*>(VT_NOTES);
        }
        template<size_t Index>
        auto get_field() const {
            if constexpr (Index == 0)
                return notes();
            else
                static_assert(Index != Index, "Invalid Field Index");
        }
        bool Verify(flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NOTES) && verifier.VerifyVector(notes())
                && verifier.VerifyVectorOfTables(notes()) && verifier.EndTable();
        }
        NoteStorageT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        void UnPackTo(NoteStorageT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
        static flatbuffers::Offset<NoteStorage> Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const NoteStorageT* _o,
            const flatbuffers::rehasher_function_t* _rehasher = nullptr);
    };

    struct NoteStorageBuilder {
        typedef NoteStorage Table;
        flatbuffers::FlatBufferBuilder& fbb_;
        flatbuffers::uoffset_t start_;
        void add_notes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::NoteObject>>> notes) {
            fbb_.AddOffset(NoteStorage::VT_NOTES, notes);
        }
        explicit NoteStorageBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        flatbuffers::Offset<NoteStorage> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<NoteStorage>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<NoteStorage> CreateNoteStorage(
        flatbuffers::FlatBufferBuilder& _fbb,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pg::gen::NoteObject>>> notes = 0) {
        NoteStorageBuilder builder_(_fbb);
        builder_.add_notes(notes);
        return builder_.Finish();
    }

    struct NoteStorage::Traits {
        using type = NoteStorage;
        static auto constexpr Create = CreateNoteStorage;
        static constexpr auto name = "NoteStorage";
        static constexpr auto fully_qualified_name = "pg.gen.NoteStorage";
        static constexpr std::array<const char*, 1> field_names = { "notes" };
        template<size_t Index>
        using FieldType = decltype(std::declval<type>().get_field<Index>());
        static constexpr size_t fields_number = 1;
    };

    inline flatbuffers::Offset<NoteStorage> CreateNoteStorageDirect(
        flatbuffers::FlatBufferBuilder& _fbb,
        const std::vector<flatbuffers::Offset<pg::gen::NoteObject>>* notes = nullptr) {
        auto notes__ = notes ? _fbb.CreateVector<flatbuffers::Offset<pg::gen::NoteObject>>(*notes) : 0;
        return pg::gen::CreateNoteStorage(_fbb, notes__);
    }

    flatbuffers::Offset<NoteStorage> CreateNoteStorage(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteStorageT* _o,
        const flatbuffers::rehasher_function_t* _rehasher = nullptr);

    inline TimestampT* Timestamp::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<TimestampT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void Timestamp::UnPackTo(TimestampT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = seconds();
            _o->seconds = _e;
        }
        {
            auto _e = nanos();
            _o->nanos = _e;
        }
    }

    inline flatbuffers::Offset<Timestamp> Timestamp::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TimestampT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateTimestamp(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<Timestamp> CreateTimestamp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TimestampT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const TimestampT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _seconds = _o->seconds;
        auto _nanos = _o->nanos;
        return pg::gen::CreateTimestamp(_fbb, _seconds, _nanos);
    }

    inline ResponseErrorT* ResponseError::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<ResponseErrorT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void ResponseError::UnPackTo(ResponseErrorT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = code();
            _o->code = _e;
        }
        {
            auto _e = message();
            if (_e)
                _o->message = _e->str();
        }
    }

    inline flatbuffers::Offset<ResponseError> ResponseError::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ResponseErrorT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateResponseError(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<ResponseError> CreateResponseError(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ResponseErrorT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const ResponseErrorT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _code = _o->code;
        auto _message = _o->message.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->message);
        return pg::gen::CreateResponseError(_fbb, _code, _message);
    }

    inline ReplaceTextPairT* ReplaceTextPair::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<ReplaceTextPairT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    ReplaceTextPair::UnPackTo(ReplaceTextPairT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = search();
            if (_e)
                _o->search = _e->str();
        }
        {
            auto _e = replace();
            if (_e)
                _o->replace = _e->str();
        }
    }

    inline flatbuffers::Offset<ReplaceTextPair> ReplaceTextPair::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ReplaceTextPairT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateReplaceTextPair(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<ReplaceTextPair> CreateReplaceTextPair(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ReplaceTextPairT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const ReplaceTextPairT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _search = _o->search.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->search);
        auto _replace = _o->replace.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->replace);
        return pg::gen::CreateReplaceTextPair(_fbb, _search, _replace);
    }

    inline AppendTextOpT* AppendTextOp::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<AppendTextOpT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void AppendTextOp::UnPackTo(AppendTextOpT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = text();
            if (_e)
                _o->text = _e->str();
        }
    }

    inline flatbuffers::Offset<AppendTextOp> AppendTextOp::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const AppendTextOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateAppendTextOp(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<AppendTextOp> CreateAppendTextOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const AppendTextOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const AppendTextOpT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _text = _o->text.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->text);
        return pg::gen::CreateAppendTextOp(_fbb, _text);
    }

    inline InsertTextOpT* InsertTextOp::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<InsertTextOpT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void InsertTextOp::UnPackTo(InsertTextOpT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = text();
            if (_e)
                _o->text = _e->str();
        }
        {
            auto _e = position();
            _o->position = _e;
        }
    }

    inline flatbuffers::Offset<InsertTextOp> InsertTextOp::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const InsertTextOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateInsertTextOp(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<InsertTextOp> CreateInsertTextOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const InsertTextOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const InsertTextOpT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _text = _o->text.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->text);
        auto _position = _o->position;
        return pg::gen::CreateInsertTextOp(_fbb, _text, _position);
    }

    inline PrependTextOpT* PrependTextOp::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<PrependTextOpT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void PrependTextOp::UnPackTo(PrependTextOpT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = text();
            if (_e)
                _o->text = _e->str();
        }
    }

    inline flatbuffers::Offset<PrependTextOp> PrependTextOp::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const PrependTextOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreatePrependTextOp(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<PrependTextOp> CreatePrependTextOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const PrependTextOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const PrependTextOpT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _text = _o->text.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->text);
        return pg::gen::CreatePrependTextOp(_fbb, _text);
    }

    inline RemoveTextRangeOpT* RemoveTextRangeOp::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<RemoveTextRangeOpT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    RemoveTextRangeOp::UnPackTo(RemoveTextRangeOpT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = start();
            _o->start = _e;
        }
        {
            auto _e = end();
            _o->end = _e;
        }
    }

    inline flatbuffers::Offset<RemoveTextRangeOp> RemoveTextRangeOp::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const RemoveTextRangeOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateRemoveTextRangeOp(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<RemoveTextRangeOp> CreateRemoveTextRangeOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const RemoveTextRangeOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const RemoveTextRangeOpT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _start = _o->start;
        auto _end = _o->end;
        return pg::gen::CreateRemoveTextRangeOp(_fbb, _start, _end);
    }

    inline ReplaceTextOpT* ReplaceTextOp::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<ReplaceTextOpT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void ReplaceTextOp::UnPackTo(ReplaceTextOpT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = input();
            if (_e)
                _o->input = std::unique_ptr<pg::gen::ReplaceTextPairT>(_e->UnPack(_resolver));
        }
    }

    inline flatbuffers::Offset<ReplaceTextOp> ReplaceTextOp::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ReplaceTextOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateReplaceTextOp(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<ReplaceTextOp> CreateReplaceTextOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ReplaceTextOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const ReplaceTextOpT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _input = _o->input ? CreateReplaceTextPair(_fbb, _o->input.get(), _rehasher) : 0;
        return pg::gen::CreateReplaceTextOp(_fbb, _input);
    }

    inline ReplaceTextMultipleOpT*
    ReplaceTextMultipleOp::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<ReplaceTextMultipleOpT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void ReplaceTextMultipleOp::UnPackTo(
        ReplaceTextMultipleOpT* _o,
        const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = pairs();
            if (_e) {
                _o->pairs.resize(_e->size());
                for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                    _o->pairs[_i] = std::unique_ptr<pg::gen::ReplaceTextPairT>(_e->Get(_i)->UnPack(_resolver));
                }
            }
        }
    }

    inline flatbuffers::Offset<ReplaceTextMultipleOp> ReplaceTextMultipleOp::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ReplaceTextMultipleOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateReplaceTextMultipleOp(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<ReplaceTextMultipleOp> CreateReplaceTextMultipleOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ReplaceTextMultipleOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const ReplaceTextMultipleOpT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _pairs = _fbb.CreateVector<flatbuffers::Offset<pg::gen::ReplaceTextPair>>(
            _o->pairs.size(),
            [](size_t i, _VectorArgs* __va) {
                return CreateReplaceTextPair(*__va->__fbb, __va->__o->pairs[i].get(), __va->__rehasher);
            },
            &_va);
        return pg::gen::CreateReplaceTextMultipleOp(_fbb, _pairs);
    }

    inline RemoveTextOpT* RemoveTextOp::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<RemoveTextOpT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void RemoveTextOp::UnPackTo(RemoveTextOpT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = removal();
            if (_e)
                _o->removal = _e->str();
        }
    }

    inline flatbuffers::Offset<RemoveTextOp> RemoveTextOp::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const RemoveTextOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateRemoveTextOp(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<RemoveTextOp> CreateRemoveTextOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const RemoveTextOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const RemoveTextOpT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _removal = _o->removal.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->removal);
        return pg::gen::CreateRemoveTextOp(_fbb, _removal);
    }

    inline RemoveTextMultipleOpT*
    RemoveTextMultipleOp::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<RemoveTextMultipleOpT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    RemoveTextMultipleOp::UnPackTo(RemoveTextMultipleOpT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = removals();
            if (_e) {
                _o->removals.resize(_e->size());
                for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                    _o->removals[_i] = _e->Get(_i)->str();
                }
            }
        }
    }

    inline flatbuffers::Offset<RemoveTextMultipleOp> RemoveTextMultipleOp::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const RemoveTextMultipleOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateRemoveTextMultipleOp(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<RemoveTextMultipleOp> CreateRemoveTextMultipleOp(
        flatbuffers::FlatBufferBuilder& _fbb,
        const RemoveTextMultipleOpT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const RemoveTextMultipleOpT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _removals = _fbb.CreateVectorOfStrings(_o->removals);
        return pg::gen::CreateRemoveTextMultipleOp(_fbb, _removals);
    }

    inline TextModificationKindT*
    TextModificationKind::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<TextModificationKindT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    TextModificationKind::UnPackTo(TextModificationKindT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = kind_type();
            _o->kind.type = _e;
        }
        {
            auto _e = kind();
            if (_e)
                _o->kind.value = pg::gen::TextModificationKind_::KindUnionUnion::UnPack(_e, kind_type(), _resolver);
        }
    }

    inline flatbuffers::Offset<TextModificationKind> TextModificationKind::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextModificationKindT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateTextModificationKind(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<TextModificationKind> CreateTextModificationKind(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextModificationKindT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const TextModificationKindT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _kind_type = _o->kind.type;
        auto _kind = _o->kind.Pack(_fbb);
        return pg::gen::CreateTextModificationKind(_fbb, _kind_type, _kind);
    }

    inline TextMatchesQueryT* TextMatchesQuery::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<TextMatchesQueryT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    TextMatchesQuery::UnPackTo(TextMatchesQueryT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = text();
            if (_e)
                _o->text = _e->str();
        }
        {
            auto _e = case_sensitive();
            _o->case_sensitive = _e;
        }
    }

    inline flatbuffers::Offset<TextMatchesQuery> TextMatchesQuery::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextMatchesQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateTextMatchesQuery(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<TextMatchesQuery> CreateTextMatchesQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextMatchesQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const TextMatchesQueryT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _text = _o->text.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->text);
        auto _case_sensitive = _o->case_sensitive;
        return pg::gen::CreateTextMatchesQuery(_fbb, _text, _case_sensitive);
    }

    inline TextContainsQueryT* TextContainsQuery::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<TextContainsQueryT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    TextContainsQuery::UnPackTo(TextContainsQueryT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = text();
            if (_e)
                _o->text = _e->str();
        }
        {
            auto _e = case_sensitive();
            _o->case_sensitive = _e;
        }
    }

    inline flatbuffers::Offset<TextContainsQuery> TextContainsQuery::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextContainsQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateTextContainsQuery(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<TextContainsQuery> CreateTextContainsQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextContainsQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const TextContainsQueryT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _text = _o->text.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->text);
        auto _case_sensitive = _o->case_sensitive;
        return pg::gen::CreateTextContainsQuery(_fbb, _text, _case_sensitive);
    }

    inline TextStartsWithQueryT* TextStartsWithQuery::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<TextStartsWithQueryT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    TextStartsWithQuery::UnPackTo(TextStartsWithQueryT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = text();
            if (_e)
                _o->text = _e->str();
        }
        {
            auto _e = case_sensitive();
            _o->case_sensitive = _e;
        }
    }

    inline flatbuffers::Offset<TextStartsWithQuery> TextStartsWithQuery::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextStartsWithQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateTextStartsWithQuery(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<TextStartsWithQuery> CreateTextStartsWithQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextStartsWithQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const TextStartsWithQueryT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _text = _o->text.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->text);
        auto _case_sensitive = _o->case_sensitive;
        return pg::gen::CreateTextStartsWithQuery(_fbb, _text, _case_sensitive);
    }

    inline TextEndsWithQueryT* TextEndsWithQuery::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<TextEndsWithQueryT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    TextEndsWithQuery::UnPackTo(TextEndsWithQueryT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = text();
            if (_e)
                _o->text = _e->str();
        }
        {
            auto _e = case_sensitive();
            _o->case_sensitive = _e;
        }
    }

    inline flatbuffers::Offset<TextEndsWithQuery> TextEndsWithQuery::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextEndsWithQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateTextEndsWithQuery(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<TextEndsWithQuery> CreateTextEndsWithQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextEndsWithQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const TextEndsWithQueryT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _text = _o->text.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->text);
        auto _case_sensitive = _o->case_sensitive;
        return pg::gen::CreateTextEndsWithQuery(_fbb, _text, _case_sensitive);
    }

    inline TextSearchKindT* TextSearchKind::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<TextSearchKindT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void TextSearchKind::UnPackTo(TextSearchKindT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = kind_type();
            _o->kind.type = _e;
        }
        {
            auto _e = kind();
            if (_e)
                _o->kind.value = pg::gen::TextSearchKind_::KindUnionUnion::UnPack(_e, kind_type(), _resolver);
        }
    }

    inline flatbuffers::Offset<TextSearchKind> TextSearchKind::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextSearchKindT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateTextSearchKind(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<TextSearchKind> CreateTextSearchKind(
        flatbuffers::FlatBufferBuilder& _fbb,
        const TextSearchKindT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const TextSearchKindT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _kind_type = _o->kind.type;
        auto _kind = _o->kind.Pack(_fbb);
        return pg::gen::CreateTextSearchKind(_fbb, _kind_type, _kind);
    }

    inline BeforeDateQueryT* BeforeDateQuery::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<BeforeDateQueryT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    BeforeDateQuery::UnPackTo(BeforeDateQueryT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = date();
            if (_e)
                _o->date = std::unique_ptr<pg::gen::TimestampT>(_e->UnPack(_resolver));
        }
    }

    inline flatbuffers::Offset<BeforeDateQuery> BeforeDateQuery::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const BeforeDateQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateBeforeDateQuery(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<BeforeDateQuery> CreateBeforeDateQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        const BeforeDateQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const BeforeDateQueryT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _date = _o->date ? CreateTimestamp(_fbb, _o->date.get(), _rehasher) : 0;
        return pg::gen::CreateBeforeDateQuery(_fbb, _date);
    }

    inline AfterDateQueryT* AfterDateQuery::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<AfterDateQueryT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void AfterDateQuery::UnPackTo(AfterDateQueryT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = date();
            if (_e)
                _o->date = std::unique_ptr<pg::gen::TimestampT>(_e->UnPack(_resolver));
        }
    }

    inline flatbuffers::Offset<AfterDateQuery> AfterDateQuery::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const AfterDateQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateAfterDateQuery(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<AfterDateQuery> CreateAfterDateQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        const AfterDateQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const AfterDateQueryT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _date = _o->date ? CreateTimestamp(_fbb, _o->date.get(), _rehasher) : 0;
        return pg::gen::CreateAfterDateQuery(_fbb, _date);
    }

    inline InDateRangeQueryT* InDateRangeQuery::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<InDateRangeQueryT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    InDateRangeQuery::UnPackTo(InDateRangeQueryT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = start();
            if (_e)
                _o->start = std::unique_ptr<pg::gen::TimestampT>(_e->UnPack(_resolver));
        }
        {
            auto _e = end();
            if (_e)
                _o->end = std::unique_ptr<pg::gen::TimestampT>(_e->UnPack(_resolver));
        }
    }

    inline flatbuffers::Offset<InDateRangeQuery> InDateRangeQuery::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const InDateRangeQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateInDateRangeQuery(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<InDateRangeQuery> CreateInDateRangeQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        const InDateRangeQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const InDateRangeQueryT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _start = _o->start ? CreateTimestamp(_fbb, _o->start.get(), _rehasher) : 0;
        auto _end = _o->end ? CreateTimestamp(_fbb, _o->end.get(), _rehasher) : 0;
        return pg::gen::CreateInDateRangeQuery(_fbb, _start, _end);
    }

    inline NotInDateRangeQueryT* NotInDateRangeQuery::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<NotInDateRangeQueryT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    NotInDateRangeQuery::UnPackTo(NotInDateRangeQueryT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = start();
            if (_e)
                _o->start = std::unique_ptr<pg::gen::TimestampT>(_e->UnPack(_resolver));
        }
        {
            auto _e = end();
            if (_e)
                _o->end = std::unique_ptr<pg::gen::TimestampT>(_e->UnPack(_resolver));
        }
    }

    inline flatbuffers::Offset<NotInDateRangeQuery> NotInDateRangeQuery::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NotInDateRangeQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateNotInDateRangeQuery(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<NotInDateRangeQuery> CreateNotInDateRangeQuery(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NotInDateRangeQueryT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const NotInDateRangeQueryT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _start = _o->start ? CreateTimestamp(_fbb, _o->start.get(), _rehasher) : 0;
        auto _end = _o->end ? CreateTimestamp(_fbb, _o->end.get(), _rehasher) : 0;
        return pg::gen::CreateNotInDateRangeQuery(_fbb, _start, _end);
    }

    inline DateSearchKindT* DateSearchKind::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<DateSearchKindT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void DateSearchKind::UnPackTo(DateSearchKindT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = kind_type();
            _o->kind.type = _e;
        }
        {
            auto _e = kind();
            if (_e)
                _o->kind.value = pg::gen::DateSearchKind_::KindUnionUnion::UnPack(_e, kind_type(), _resolver);
        }
    }

    inline flatbuffers::Offset<DateSearchKind> DateSearchKind::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DateSearchKindT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateDateSearchKind(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<DateSearchKind> CreateDateSearchKind(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DateSearchKindT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const DateSearchKindT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _kind_type = _o->kind.type;
        auto _kind = _o->kind.Pack(_fbb);
        return pg::gen::CreateDateSearchKind(_fbb, _kind_type, _kind);
    }

    inline NoteTitleSearchT* NoteTitleSearch::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<NoteTitleSearchT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    NoteTitleSearch::UnPackTo(NoteTitleSearchT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = title_search();
            if (_e)
                _o->title_search = std::unique_ptr<pg::gen::TextSearchKindT>(_e->UnPack(_resolver));
        }
    }

    inline flatbuffers::Offset<NoteTitleSearch> NoteTitleSearch::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteTitleSearchT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateNoteTitleSearch(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<NoteTitleSearch> CreateNoteTitleSearch(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteTitleSearchT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const NoteTitleSearchT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _title_search = _o->title_search ? CreateTextSearchKind(_fbb, _o->title_search.get(), _rehasher) : 0;
        return pg::gen::CreateNoteTitleSearch(_fbb, _title_search);
    }

    inline NoteContentSearchT* NoteContentSearch::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<NoteContentSearchT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    NoteContentSearch::UnPackTo(NoteContentSearchT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = content_search();
            if (_e)
                _o->content_search = std::unique_ptr<pg::gen::TextSearchKindT>(_e->UnPack(_resolver));
        }
    }

    inline flatbuffers::Offset<NoteContentSearch> NoteContentSearch::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteContentSearchT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateNoteContentSearch(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<NoteContentSearch> CreateNoteContentSearch(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteContentSearchT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const NoteContentSearchT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _content_search = _o->content_search ? CreateTextSearchKind(_fbb, _o->content_search.get(), _rehasher) : 0;
        return pg::gen::CreateNoteContentSearch(_fbb, _content_search);
    }

    inline NoteTagSearchT* NoteTagSearch::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<NoteTagSearchT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void NoteTagSearch::UnPackTo(NoteTagSearchT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = tag_search();
            if (_e)
                _o->tag_search = std::unique_ptr<pg::gen::TextSearchKindT>(_e->UnPack(_resolver));
        }
    }

    inline flatbuffers::Offset<NoteTagSearch> NoteTagSearch::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteTagSearchT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateNoteTagSearch(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<NoteTagSearch> CreateNoteTagSearch(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteTagSearchT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const NoteTagSearchT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _tag_search = _o->tag_search ? CreateTextSearchKind(_fbb, _o->tag_search.get(), _rehasher) : 0;
        return pg::gen::CreateNoteTagSearch(_fbb, _tag_search);
    }

    inline NoteCreatedSearchT* NoteCreatedSearch::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<NoteCreatedSearchT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    NoteCreatedSearch::UnPackTo(NoteCreatedSearchT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = created_search();
            if (_e)
                _o->created_search = std::unique_ptr<pg::gen::DateSearchKindT>(_e->UnPack(_resolver));
        }
    }

    inline flatbuffers::Offset<NoteCreatedSearch> NoteCreatedSearch::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteCreatedSearchT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateNoteCreatedSearch(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<NoteCreatedSearch> CreateNoteCreatedSearch(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteCreatedSearchT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const NoteCreatedSearchT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _created_search = _o->created_search ? CreateDateSearchKind(_fbb, _o->created_search.get(), _rehasher) : 0;
        return pg::gen::CreateNoteCreatedSearch(_fbb, _created_search);
    }

    inline NoteUpdatedSearchT* NoteUpdatedSearch::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<NoteUpdatedSearchT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    NoteUpdatedSearch::UnPackTo(NoteUpdatedSearchT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = updated_search();
            if (_e)
                _o->updated_search = std::unique_ptr<pg::gen::DateSearchKindT>(_e->UnPack(_resolver));
        }
    }

    inline flatbuffers::Offset<NoteUpdatedSearch> NoteUpdatedSearch::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteUpdatedSearchT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateNoteUpdatedSearch(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<NoteUpdatedSearch> CreateNoteUpdatedSearch(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteUpdatedSearchT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const NoteUpdatedSearchT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _updated_search = _o->updated_search ? CreateDateSearchKind(_fbb, _o->updated_search.get(), _rehasher) : 0;
        return pg::gen::CreateNoteUpdatedSearch(_fbb, _updated_search);
    }

    inline SearchNoteDataT* SearchNoteData::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<SearchNoteDataT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void SearchNoteData::UnPackTo(SearchNoteDataT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = kind_type();
            _o->kind.type = _e;
        }
        {
            auto _e = kind();
            if (_e)
                _o->kind.value = pg::gen::SearchNoteData_::KindUnionUnion::UnPack(_e, kind_type(), _resolver);
        }
    }

    inline flatbuffers::Offset<SearchNoteData> SearchNoteData::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const SearchNoteDataT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateSearchNoteData(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<SearchNoteData> CreateSearchNoteData(
        flatbuffers::FlatBufferBuilder& _fbb,
        const SearchNoteDataT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const SearchNoteDataT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _kind_type = _o->kind.type;
        auto _kind = _o->kind.Pack(_fbb);
        return pg::gen::CreateSearchNoteData(_fbb, _kind_type, _kind);
    }

    inline SearchNoteRequestT* SearchNoteRequest::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<SearchNoteRequestT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    SearchNoteRequest::UnPackTo(SearchNoteRequestT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = searches();
            if (_e) {
                _o->searches.resize(_e->size());
                for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                    _o->searches[_i] = std::unique_ptr<pg::gen::SearchNoteDataT>(_e->Get(_i)->UnPack(_resolver));
                }
            }
        }
        {
            auto _e = page_size();
            _o->page_size = _e;
        }
        {
            auto _e = page_token();
            if (_e)
                _o->page_token = _e->str();
        }
    }

    inline flatbuffers::Offset<SearchNoteRequest> SearchNoteRequest::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const SearchNoteRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateSearchNoteRequest(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<SearchNoteRequest> CreateSearchNoteRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        const SearchNoteRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const SearchNoteRequestT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _searches = _fbb.CreateVector<flatbuffers::Offset<pg::gen::SearchNoteData>>(
            _o->searches.size(),
            [](size_t i, _VectorArgs* __va) {
                return CreateSearchNoteData(*__va->__fbb, __va->__o->searches[i].get(), __va->__rehasher);
            },
            &_va);
        auto _page_size = _o->page_size;
        auto _page_token = _o->page_token.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->page_token);
        return pg::gen::CreateSearchNoteRequest(_fbb, _searches, _page_size, _page_token);
    }

    inline SearchNoteResponseT* SearchNoteResponse::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<SearchNoteResponseT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    SearchNoteResponse::UnPackTo(SearchNoteResponseT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = notes();
            if (_e) {
                _o->notes.resize(_e->size());
                for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                    _o->notes[_i] = std::unique_ptr<pg::gen::NoteObjectT>(_e->Get(_i)->UnPack(_resolver));
                }
            }
        }
        {
            auto _e = next_page_token();
            if (_e)
                _o->next_page_token = _e->str();
        }
    }

    inline flatbuffers::Offset<SearchNoteResponse> SearchNoteResponse::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const SearchNoteResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateSearchNoteResponse(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<SearchNoteResponse> CreateSearchNoteResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        const SearchNoteResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const SearchNoteResponseT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _notes = _fbb.CreateVector<flatbuffers::Offset<pg::gen::NoteObject>>(
            _o->notes.size(),
            [](size_t i, _VectorArgs* __va) {
                return CreateNoteObject(*__va->__fbb, __va->__o->notes[i].get(), __va->__rehasher);
            },
            &_va);
        auto _next_page_token =
            _o->next_page_token.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->next_page_token);
        return pg::gen::CreateSearchNoteResponse(_fbb, _notes, _next_page_token);
    }

    inline CreateNoteDataT* CreateNoteData::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<CreateNoteDataT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void CreateNoteData::UnPackTo(CreateNoteDataT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = title();
            if (_e)
                _o->title = _e->str();
        }
        {
            auto _e = content();
            if (_e)
                _o->content = _e->str();
        }
        {
            auto _e = tags();
            if (_e) {
                _o->tags.resize(_e->size());
                for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                    _o->tags[_i] = _e->Get(_i)->str();
                }
            }
        }
    }

    inline flatbuffers::Offset<CreateNoteData> CreateNoteData::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const CreateNoteDataT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateCreateNoteData(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<CreateNoteData> CreateCreateNoteData(
        flatbuffers::FlatBufferBuilder& _fbb,
        const CreateNoteDataT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const CreateNoteDataT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _title = _o->title.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->title);
        auto _content = _o->content.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->content);
        auto _tags = _fbb.CreateVectorOfStrings(_o->tags);
        return pg::gen::CreateCreateNoteData(_fbb, _title, _content, _tags);
    }

    inline CreateNoteRequestT* CreateNoteRequest::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<CreateNoteRequestT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    CreateNoteRequest::UnPackTo(CreateNoteRequestT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = parent();
            if (_e)
                _o->parent = _e->str();
        }
        {
            auto _e = note();
            if (_e)
                _o->note = std::unique_ptr<pg::gen::CreateNoteDataT>(_e->UnPack(_resolver));
        }
        {
            auto _e = id();
            if (_e)
                _o->id = _e->str();
        }
    }

    inline flatbuffers::Offset<CreateNoteRequest> CreateNoteRequest::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const CreateNoteRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateCreateNoteRequest(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<CreateNoteRequest> CreateCreateNoteRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        const CreateNoteRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const CreateNoteRequestT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _parent = _o->parent.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->parent);
        auto _note = _o->note ? CreateCreateNoteData(_fbb, _o->note.get(), _rehasher) : 0;
        auto _id = _o->id.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->id);
        return pg::gen::CreateCreateNoteRequest(_fbb, _parent, _note, _id);
    }

    inline CreateNoteResponseT* CreateNoteResponse::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<CreateNoteResponseT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    CreateNoteResponse::UnPackTo(CreateNoteResponseT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = resp_type();
            _o->resp.type = _e;
        }
        {
            auto _e = resp();
            if (_e)
                _o->resp.value = pg::gen::CreateNoteResponse_::RespUnionUnion::UnPack(_e, resp_type(), _resolver);
        }
    }

    inline flatbuffers::Offset<CreateNoteResponse> CreateNoteResponse::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const CreateNoteResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateCreateNoteResponse(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<CreateNoteResponse> CreateCreateNoteResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        const CreateNoteResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const CreateNoteResponseT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _resp_type = _o->resp.type;
        auto _resp = _o->resp.Pack(_fbb);
        return pg::gen::CreateCreateNoteResponse(_fbb, _resp_type, _resp);
    }

    inline UpdateNoteDataT* UpdateNoteData::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<UpdateNoteDataT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void UpdateNoteData::UnPackTo(UpdateNoteDataT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = id();
            if (_e)
                _o->id = _e->str();
        }
        {
            auto _e = title_mods();
            if (_e) {
                _o->title_mods.resize(_e->size());
                for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                    _o->title_mods[_i] =
                        std::unique_ptr<pg::gen::TextModificationKindT>(_e->Get(_i)->UnPack(_resolver));
                }
            }
        }
        {
            auto _e = content_mods();
            if (_e) {
                _o->content_mods.resize(_e->size());
                for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                    _o->content_mods[_i] =
                        std::unique_ptr<pg::gen::TextModificationKindT>(_e->Get(_i)->UnPack(_resolver));
                }
            }
        }
        {
            auto _e = tag_mods();
            if (_e) {
                _o->tag_mods.resize(_e->size());
                for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                    _o->tag_mods[_i] = std::unique_ptr<pg::gen::TextModificationKindT>(_e->Get(_i)->UnPack(_resolver));
                }
            }
        }
    }

    inline flatbuffers::Offset<UpdateNoteData> UpdateNoteData::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const UpdateNoteDataT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateUpdateNoteData(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<UpdateNoteData> CreateUpdateNoteData(
        flatbuffers::FlatBufferBuilder& _fbb,
        const UpdateNoteDataT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const UpdateNoteDataT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _id = _o->id.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->id);
        auto _title_mods = _fbb.CreateVector<flatbuffers::Offset<pg::gen::TextModificationKind>>(
            _o->title_mods.size(),
            [](size_t i, _VectorArgs* __va) {
                return CreateTextModificationKind(*__va->__fbb, __va->__o->title_mods[i].get(), __va->__rehasher);
            },
            &_va);
        auto _content_mods = _fbb.CreateVector<flatbuffers::Offset<pg::gen::TextModificationKind>>(
            _o->content_mods.size(),
            [](size_t i, _VectorArgs* __va) {
                return CreateTextModificationKind(*__va->__fbb, __va->__o->content_mods[i].get(), __va->__rehasher);
            },
            &_va);
        auto _tag_mods = _fbb.CreateVector<flatbuffers::Offset<pg::gen::TextModificationKind>>(
            _o->tag_mods.size(),
            [](size_t i, _VectorArgs* __va) {
                return CreateTextModificationKind(*__va->__fbb, __va->__o->tag_mods[i].get(), __va->__rehasher);
            },
            &_va);
        return pg::gen::CreateUpdateNoteData(_fbb, _id, _title_mods, _content_mods, _tag_mods);
    }

    inline UpdateNoteRequestT* UpdateNoteRequest::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<UpdateNoteRequestT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    UpdateNoteRequest::UnPackTo(UpdateNoteRequestT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = target();
            if (_e)
                _o->target = std::unique_ptr<pg::gen::UpdateNoteDataT>(_e->UnPack(_resolver));
        }
    }

    inline flatbuffers::Offset<UpdateNoteRequest> UpdateNoteRequest::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const UpdateNoteRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateUpdateNoteRequest(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<UpdateNoteRequest> CreateUpdateNoteRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        const UpdateNoteRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const UpdateNoteRequestT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _target = _o->target ? CreateUpdateNoteData(_fbb, _o->target.get(), _rehasher) : 0;
        return pg::gen::CreateUpdateNoteRequest(_fbb, _target);
    }

    inline UpdateNoteResponseT* UpdateNoteResponse::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<UpdateNoteResponseT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    UpdateNoteResponse::UnPackTo(UpdateNoteResponseT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = resp_type();
            _o->resp.type = _e;
        }
        {
            auto _e = resp();
            if (_e)
                _o->resp.value = pg::gen::UpdateNoteResponse_::RespUnionUnion::UnPack(_e, resp_type(), _resolver);
        }
    }

    inline flatbuffers::Offset<UpdateNoteResponse> UpdateNoteResponse::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const UpdateNoteResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateUpdateNoteResponse(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<UpdateNoteResponse> CreateUpdateNoteResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        const UpdateNoteResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const UpdateNoteResponseT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _resp_type = _o->resp.type;
        auto _resp = _o->resp.Pack(_fbb);
        return pg::gen::CreateUpdateNoteResponse(_fbb, _resp_type, _resp);
    }

    inline UpdateNotesRequestT* UpdateNotesRequest::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<UpdateNotesRequestT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    UpdateNotesRequest::UnPackTo(UpdateNotesRequestT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = targets();
            if (_e) {
                _o->targets.resize(_e->size());
                for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                    _o->targets[_i] = std::unique_ptr<pg::gen::UpdateNoteDataT>(_e->Get(_i)->UnPack(_resolver));
                }
            }
        }
    }

    inline flatbuffers::Offset<UpdateNotesRequest> UpdateNotesRequest::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const UpdateNotesRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateUpdateNotesRequest(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<UpdateNotesRequest> CreateUpdateNotesRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        const UpdateNotesRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const UpdateNotesRequestT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _targets = _fbb.CreateVector<flatbuffers::Offset<pg::gen::UpdateNoteData>>(
            _o->targets.size(),
            [](size_t i, _VectorArgs* __va) {
                return CreateUpdateNoteData(*__va->__fbb, __va->__o->targets[i].get(), __va->__rehasher);
            },
            &_va);
        return pg::gen::CreateUpdateNotesRequest(_fbb, _targets);
    }

    inline UpdateNotesResponseT* UpdateNotesResponse::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<UpdateNotesResponseT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    UpdateNotesResponse::UnPackTo(UpdateNotesResponseT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = updated_count();
            _o->updated_count = _e;
        }
        {
            auto _e = error_count();
            _o->error_count = _e;
        }
        {
            auto _e = updated();
            if (_e) {
                _o->updated.resize(_e->size());
                for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                    _o->updated[_i] = std::unique_ptr<pg::gen::NoteObjectT>(_e->Get(_i)->UnPack(_resolver));
                }
            }
        }
        {
            auto _e = errors();
            if (_e) {
                _o->errors.resize(_e->size());
                for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                    _o->errors[_i] = std::unique_ptr<pg::gen::ResponseErrorT>(_e->Get(_i)->UnPack(_resolver));
                }
            }
        }
    }

    inline flatbuffers::Offset<UpdateNotesResponse> UpdateNotesResponse::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const UpdateNotesResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateUpdateNotesResponse(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<UpdateNotesResponse> CreateUpdateNotesResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        const UpdateNotesResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const UpdateNotesResponseT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _updated_count = _o->updated_count;
        auto _error_count = _o->error_count;
        auto _updated = _fbb.CreateVector<flatbuffers::Offset<pg::gen::NoteObject>>(
            _o->updated.size(),
            [](size_t i, _VectorArgs* __va) {
                return CreateNoteObject(*__va->__fbb, __va->__o->updated[i].get(), __va->__rehasher);
            },
            &_va);
        auto _errors = _fbb.CreateVector<flatbuffers::Offset<pg::gen::ResponseError>>(
            _o->errors.size(),
            [](size_t i, _VectorArgs* __va) {
                return CreateResponseError(*__va->__fbb, __va->__o->errors[i].get(), __va->__rehasher);
            },
            &_va);
        return pg::gen::CreateUpdateNotesResponse(_fbb, _updated_count, _error_count, _updated, _errors);
    }

    inline DeleteNoteDataT* DeleteNoteData::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<DeleteNoteDataT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void DeleteNoteData::UnPackTo(DeleteNoteDataT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = id();
            if (_e)
                _o->id = _e->str();
        }
    }

    inline flatbuffers::Offset<DeleteNoteData> DeleteNoteData::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DeleteNoteDataT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateDeleteNoteData(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<DeleteNoteData> CreateDeleteNoteData(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DeleteNoteDataT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const DeleteNoteDataT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _id = _o->id.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->id);
        return pg::gen::CreateDeleteNoteData(_fbb, _id);
    }

    inline DeleteNoteRequestT* DeleteNoteRequest::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<DeleteNoteRequestT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    DeleteNoteRequest::UnPackTo(DeleteNoteRequestT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = target();
            if (_e)
                _o->target = std::unique_ptr<pg::gen::DeleteNoteDataT>(_e->UnPack(_resolver));
        }
    }

    inline flatbuffers::Offset<DeleteNoteRequest> DeleteNoteRequest::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DeleteNoteRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateDeleteNoteRequest(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<DeleteNoteRequest> CreateDeleteNoteRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DeleteNoteRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const DeleteNoteRequestT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _target = _o->target ? CreateDeleteNoteData(_fbb, _o->target.get(), _rehasher) : 0;
        return pg::gen::CreateDeleteNoteRequest(_fbb, _target);
    }

    inline BooleanT* Boolean::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<BooleanT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void Boolean::UnPackTo(BooleanT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = value();
            _o->value = _e;
        }
    }

    inline flatbuffers::Offset<Boolean> Boolean::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const BooleanT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateBoolean(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<Boolean> CreateBoolean(
        flatbuffers::FlatBufferBuilder& _fbb,
        const BooleanT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const BooleanT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _value = _o->value;
        return pg::gen::CreateBoolean(_fbb, _value);
    }

    inline DeleteNoteResponseT* DeleteNoteResponse::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<DeleteNoteResponseT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    DeleteNoteResponse::UnPackTo(DeleteNoteResponseT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = resp_type();
            _o->resp.type = _e;
        }
        {
            auto _e = resp();
            if (_e)
                _o->resp.value = pg::gen::DeleteNoteResponse_::RespUnionUnion::UnPack(_e, resp_type(), _resolver);
        }
    }

    inline flatbuffers::Offset<DeleteNoteResponse> DeleteNoteResponse::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DeleteNoteResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateDeleteNoteResponse(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<DeleteNoteResponse> CreateDeleteNoteResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DeleteNoteResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const DeleteNoteResponseT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _resp_type = _o->resp.type;
        auto _resp = _o->resp.Pack(_fbb);
        return pg::gen::CreateDeleteNoteResponse(_fbb, _resp_type, _resp);
    }

    inline DeleteNotesRequestT* DeleteNotesRequest::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<DeleteNotesRequestT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    DeleteNotesRequest::UnPackTo(DeleteNotesRequestT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = targets();
            if (_e) {
                _o->targets.resize(_e->size());
                for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                    _o->targets[_i] = std::unique_ptr<pg::gen::DeleteNoteDataT>(_e->Get(_i)->UnPack(_resolver));
                }
            }
        }
    }

    inline flatbuffers::Offset<DeleteNotesRequest> DeleteNotesRequest::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DeleteNotesRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateDeleteNotesRequest(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<DeleteNotesRequest> CreateDeleteNotesRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DeleteNotesRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const DeleteNotesRequestT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _targets = _fbb.CreateVector<flatbuffers::Offset<pg::gen::DeleteNoteData>>(
            _o->targets.size(),
            [](size_t i, _VectorArgs* __va) {
                return CreateDeleteNoteData(*__va->__fbb, __va->__o->targets[i].get(), __va->__rehasher);
            },
            &_va);
        return pg::gen::CreateDeleteNotesRequest(_fbb, _targets);
    }

    inline DeleteNotesResponseT* DeleteNotesResponse::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<DeleteNotesResponseT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    DeleteNotesResponse::UnPackTo(DeleteNotesResponseT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = deleted_count();
            _o->deleted_count = _e;
        }
        {
            auto _e = errors();
            if (_e) {
                _o->errors.resize(_e->size());
                for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                    _o->errors[_i] = std::unique_ptr<pg::gen::ResponseErrorT>(_e->Get(_i)->UnPack(_resolver));
                }
            }
        }
    }

    inline flatbuffers::Offset<DeleteNotesResponse> DeleteNotesResponse::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DeleteNotesResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateDeleteNotesResponse(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<DeleteNotesResponse> CreateDeleteNotesResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        const DeleteNotesResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const DeleteNotesResponseT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _deleted_count = _o->deleted_count;
        auto _errors = _fbb.CreateVector<flatbuffers::Offset<pg::gen::ResponseError>>(
            _o->errors.size(),
            [](size_t i, _VectorArgs* __va) {
                return CreateResponseError(*__va->__fbb, __va->__o->errors[i].get(), __va->__rehasher);
            },
            &_va);
        return pg::gen::CreateDeleteNotesResponse(_fbb, _deleted_count, _errors);
    }

    inline ListNotesRequestT* ListNotesRequest::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<ListNotesRequestT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    ListNotesRequest::UnPackTo(ListNotesRequestT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = page_size();
            _o->page_size = _e;
        }
        {
            auto _e = page_token();
            if (_e)
                _o->page_token = _e->str();
        }
    }

    inline flatbuffers::Offset<ListNotesRequest> ListNotesRequest::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ListNotesRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateListNotesRequest(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<ListNotesRequest> CreateListNotesRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ListNotesRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const ListNotesRequestT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _page_size = _o->page_size;
        auto _page_token = _o->page_token.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->page_token);
        return pg::gen::CreateListNotesRequest(_fbb, _page_size, _page_token);
    }

    inline ListNotesResponseT* ListNotesResponse::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<ListNotesResponseT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    ListNotesResponse::UnPackTo(ListNotesResponseT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = notes();
            if (_e) {
                _o->notes.resize(_e->size());
                for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                    _o->notes[_i] = std::unique_ptr<pg::gen::NoteObjectT>(_e->Get(_i)->UnPack(_resolver));
                }
            }
        }
        {
            auto _e = next_page_token();
            if (_e)
                _o->next_page_token = _e->str();
        }
    }

    inline flatbuffers::Offset<ListNotesResponse> ListNotesResponse::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ListNotesResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateListNotesResponse(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<ListNotesResponse> CreateListNotesResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        const ListNotesResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const ListNotesResponseT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _notes = _fbb.CreateVector<flatbuffers::Offset<pg::gen::NoteObject>>(
            _o->notes.size(),
            [](size_t i, _VectorArgs* __va) {
                return CreateNoteObject(*__va->__fbb, __va->__o->notes[i].get(), __va->__rehasher);
            },
            &_va);
        auto _next_page_token =
            _o->next_page_token.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->next_page_token);
        return pg::gen::CreateListNotesResponse(_fbb, _notes, _next_page_token);
    }

    inline GetNoteRequestT* GetNoteRequest::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<GetNoteRequestT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void GetNoteRequest::UnPackTo(GetNoteRequestT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = id();
            if (_e)
                _o->id = _e->str();
        }
    }

    inline flatbuffers::Offset<GetNoteRequest> GetNoteRequest::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const GetNoteRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateGetNoteRequest(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<GetNoteRequest> CreateGetNoteRequest(
        flatbuffers::FlatBufferBuilder& _fbb,
        const GetNoteRequestT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const GetNoteRequestT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _id = _o->id.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->id);
        return pg::gen::CreateGetNoteRequest(_fbb, _id);
    }

    inline GetNoteResponseT* GetNoteResponse::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<GetNoteResponseT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void
    GetNoteResponse::UnPackTo(GetNoteResponseT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = resp_type();
            _o->resp.type = _e;
        }
        {
            auto _e = resp();
            if (_e)
                _o->resp.value = pg::gen::GetNoteResponse_::RespUnionUnion::UnPack(_e, resp_type(), _resolver);
        }
    }

    inline flatbuffers::Offset<GetNoteResponse> GetNoteResponse::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const GetNoteResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateGetNoteResponse(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<GetNoteResponse> CreateGetNoteResponse(
        flatbuffers::FlatBufferBuilder& _fbb,
        const GetNoteResponseT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const GetNoteResponseT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _resp_type = _o->resp.type;
        auto _resp = _o->resp.Pack(_fbb);
        return pg::gen::CreateGetNoteResponse(_fbb, _resp_type, _resp);
    }

    inline NoteObjectT* NoteObject::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<NoteObjectT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void NoteObject::UnPackTo(NoteObjectT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = id();
            if (_e)
                _o->id = _e->str();
        }
        {
            auto _e = title();
            if (_e)
                _o->title = _e->str();
        }
        {
            auto _e = content();
            if (_e)
                _o->content = _e->str();
        }
        {
            auto _e = tags();
            if (_e) {
                _o->tags.resize(_e->size());
                for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                    _o->tags[_i] = _e->Get(_i)->str();
                }
            }
        }
        {
            auto _e = created();
            if (_e)
                _o->created = std::unique_ptr<pg::gen::TimestampT>(_e->UnPack(_resolver));
        }
        {
            auto _e = updated();
            if (_e)
                _o->updated = std::unique_ptr<pg::gen::TimestampT>(_e->UnPack(_resolver));
        }
    }

    inline flatbuffers::Offset<NoteObject> NoteObject::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteObjectT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateNoteObject(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<NoteObject> CreateNoteObject(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteObjectT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const NoteObjectT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _id = _o->id.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->id);
        auto _title = _o->title.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->title);
        auto _content = _o->content.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->content);
        auto _tags = _fbb.CreateVectorOfStrings(_o->tags);
        auto _created = _o->created ? CreateTimestamp(_fbb, _o->created.get(), _rehasher) : 0;
        auto _updated = _o->updated ? CreateTimestamp(_fbb, _o->updated.get(), _rehasher) : 0;
        return pg::gen::CreateNoteObject(_fbb, _id, _title, _content, _tags, _created, _updated);
    }

    inline NoteStorageT* NoteStorage::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
        auto _o = std::make_unique<NoteStorageT>();
        UnPackTo(_o.get(), _resolver);
        return _o.release();
    }

    inline void NoteStorage::UnPackTo(NoteStorageT* _o, const flatbuffers::resolver_function_t* _resolver) const {
        (void)_o;
        (void)_resolver;
        {
            auto _e = notes();
            if (_e) {
                _o->notes.resize(_e->size());
                for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                    _o->notes[_i] = std::unique_ptr<pg::gen::NoteObjectT>(_e->Get(_i)->UnPack(_resolver));
                }
            }
        }
    }

    inline flatbuffers::Offset<NoteStorage> NoteStorage::Pack(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteStorageT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        return CreateNoteStorage(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<NoteStorage> CreateNoteStorage(
        flatbuffers::FlatBufferBuilder& _fbb,
        const NoteStorageT* _o,
        const flatbuffers::rehasher_function_t* _rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs {
            flatbuffers::FlatBufferBuilder* __fbb;
            const NoteStorageT* __o;
            const flatbuffers::rehasher_function_t* __rehasher;
        } _va = { &_fbb, _o, _rehasher };
        (void)_va;
        auto _notes = _fbb.CreateVector<flatbuffers::Offset<pg::gen::NoteObject>>(
            _o->notes.size(),
            [](size_t i, _VectorArgs* __va) {
                return CreateNoteObject(*__va->__fbb, __va->__o->notes[i].get(), __va->__rehasher);
            },
            &_va);
        return pg::gen::CreateNoteStorage(_fbb, _notes);
    }

    namespace TextModificationKind_ {

        inline bool VerifyKindUnion(flatbuffers::Verifier& verifier, const void* obj, KindUnion type) {
            switch (type) {
                case KindUnion::NONE: {
                    return true;
                }
                case KindUnion::pg_gen_AppendTextOp: {
                    auto ptr = reinterpret_cast<const pg::gen::AppendTextOp*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_InsertTextOp: {
                    auto ptr = reinterpret_cast<const pg::gen::InsertTextOp*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_PrependTextOp: {
                    auto ptr = reinterpret_cast<const pg::gen::PrependTextOp*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_RemoveTextRangeOp: {
                    auto ptr = reinterpret_cast<const pg::gen::RemoveTextRangeOp*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_ReplaceTextOp: {
                    auto ptr = reinterpret_cast<const pg::gen::ReplaceTextOp*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_ReplaceTextMultipleOp: {
                    auto ptr = reinterpret_cast<const pg::gen::ReplaceTextMultipleOp*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_RemoveTextOp: {
                    auto ptr = reinterpret_cast<const pg::gen::RemoveTextOp*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_RemoveTextMultipleOp: {
                    auto ptr = reinterpret_cast<const pg::gen::RemoveTextMultipleOp*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                default:
                    return true;
            }
        }

        inline bool VerifyKindUnionVector(
            flatbuffers::Verifier& verifier,
            const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
            const flatbuffers::Vector<uint8_t>* types) {
            if (!values || !types)
                return !values && !types;
            if (values->size() != types->size())
                return false;
            for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
                if (!VerifyKindUnion(verifier, values->Get(i), types->GetEnum<KindUnion>(i))) {
                    return false;
                }
            }
            return true;
        }

        inline void*
        KindUnionUnion::UnPack(const void* obj, KindUnion type, const flatbuffers::resolver_function_t* resolver) {
            switch (type) {
                case KindUnion::pg_gen_AppendTextOp: {
                    auto ptr = reinterpret_cast<const pg::gen::AppendTextOp*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_InsertTextOp: {
                    auto ptr = reinterpret_cast<const pg::gen::InsertTextOp*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_PrependTextOp: {
                    auto ptr = reinterpret_cast<const pg::gen::PrependTextOp*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_RemoveTextRangeOp: {
                    auto ptr = reinterpret_cast<const pg::gen::RemoveTextRangeOp*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_ReplaceTextOp: {
                    auto ptr = reinterpret_cast<const pg::gen::ReplaceTextOp*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_ReplaceTextMultipleOp: {
                    auto ptr = reinterpret_cast<const pg::gen::ReplaceTextMultipleOp*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_RemoveTextOp: {
                    auto ptr = reinterpret_cast<const pg::gen::RemoveTextOp*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_RemoveTextMultipleOp: {
                    auto ptr = reinterpret_cast<const pg::gen::RemoveTextMultipleOp*>(obj);
                    return ptr->UnPack(resolver);
                }
                default:
                    return nullptr;
            }
        }

        inline flatbuffers::Offset<void> KindUnionUnion::Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const flatbuffers::rehasher_function_t* _rehasher) const {
            switch (type) {
                case KindUnion::pg_gen_AppendTextOp: {
                    auto ptr = reinterpret_cast<const pg::gen::AppendTextOpT*>(value);
                    return CreateAppendTextOp(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_InsertTextOp: {
                    auto ptr = reinterpret_cast<const pg::gen::InsertTextOpT*>(value);
                    return CreateInsertTextOp(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_PrependTextOp: {
                    auto ptr = reinterpret_cast<const pg::gen::PrependTextOpT*>(value);
                    return CreatePrependTextOp(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_RemoveTextRangeOp: {
                    auto ptr = reinterpret_cast<const pg::gen::RemoveTextRangeOpT*>(value);
                    return CreateRemoveTextRangeOp(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_ReplaceTextOp: {
                    auto ptr = reinterpret_cast<const pg::gen::ReplaceTextOpT*>(value);
                    return CreateReplaceTextOp(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_ReplaceTextMultipleOp: {
                    auto ptr = reinterpret_cast<const pg::gen::ReplaceTextMultipleOpT*>(value);
                    return CreateReplaceTextMultipleOp(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_RemoveTextOp: {
                    auto ptr = reinterpret_cast<const pg::gen::RemoveTextOpT*>(value);
                    return CreateRemoveTextOp(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_RemoveTextMultipleOp: {
                    auto ptr = reinterpret_cast<const pg::gen::RemoveTextMultipleOpT*>(value);
                    return CreateRemoveTextMultipleOp(_fbb, ptr, _rehasher).Union();
                }
                default:
                    return 0;
            }
        }

        inline KindUnionUnion::KindUnionUnion(const KindUnionUnion& u) : type(u.type), value(nullptr) {
            switch (type) {
                case KindUnion::pg_gen_AppendTextOp: {
                    value = new pg::gen::AppendTextOpT(*reinterpret_cast<pg::gen::AppendTextOpT*>(u.value));
                    break;
                }
                case KindUnion::pg_gen_InsertTextOp: {
                    value = new pg::gen::InsertTextOpT(*reinterpret_cast<pg::gen::InsertTextOpT*>(u.value));
                    break;
                }
                case KindUnion::pg_gen_PrependTextOp: {
                    value = new pg::gen::PrependTextOpT(*reinterpret_cast<pg::gen::PrependTextOpT*>(u.value));
                    break;
                }
                case KindUnion::pg_gen_RemoveTextRangeOp: {
                    value = new pg::gen::RemoveTextRangeOpT(*reinterpret_cast<pg::gen::RemoveTextRangeOpT*>(u.value));
                    break;
                }
                case KindUnion::pg_gen_ReplaceTextOp: {
                    FLATBUFFERS_ASSERT(false);  // pg::gen::ReplaceTextOpT not copyable.
                    break;
                }
                case KindUnion::pg_gen_ReplaceTextMultipleOp: {
                    FLATBUFFERS_ASSERT(false);  // pg::gen::ReplaceTextMultipleOpT not copyable.
                    break;
                }
                case KindUnion::pg_gen_RemoveTextOp: {
                    value = new pg::gen::RemoveTextOpT(*reinterpret_cast<pg::gen::RemoveTextOpT*>(u.value));
                    break;
                }
                case KindUnion::pg_gen_RemoveTextMultipleOp: {
                    value =
                        new pg::gen::RemoveTextMultipleOpT(*reinterpret_cast<pg::gen::RemoveTextMultipleOpT*>(u.value));
                    break;
                }
                default:
                    break;
            }
        }

        inline void KindUnionUnion::Reset() {
            switch (type) {
                case KindUnion::pg_gen_AppendTextOp: {
                    auto ptr = reinterpret_cast<pg::gen::AppendTextOpT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_InsertTextOp: {
                    auto ptr = reinterpret_cast<pg::gen::InsertTextOpT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_PrependTextOp: {
                    auto ptr = reinterpret_cast<pg::gen::PrependTextOpT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_RemoveTextRangeOp: {
                    auto ptr = reinterpret_cast<pg::gen::RemoveTextRangeOpT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_ReplaceTextOp: {
                    auto ptr = reinterpret_cast<pg::gen::ReplaceTextOpT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_ReplaceTextMultipleOp: {
                    auto ptr = reinterpret_cast<pg::gen::ReplaceTextMultipleOpT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_RemoveTextOp: {
                    auto ptr = reinterpret_cast<pg::gen::RemoveTextOpT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_RemoveTextMultipleOp: {
                    auto ptr = reinterpret_cast<pg::gen::RemoveTextMultipleOpT*>(value);
                    delete ptr;
                    break;
                }
                default:
                    break;
            }
            value = nullptr;
            type = KindUnion::NONE;
        }

    }  // namespace TextModificationKind_

    namespace TextSearchKind_ {

        inline bool VerifyKindUnion(flatbuffers::Verifier& verifier, const void* obj, KindUnion type) {
            switch (type) {
                case KindUnion::NONE: {
                    return true;
                }
                case KindUnion::pg_gen_TextMatchesQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::TextMatchesQuery*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_TextContainsQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::TextContainsQuery*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_TextStartsWithQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::TextStartsWithQuery*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_TextEndsWithQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::TextEndsWithQuery*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                default:
                    return true;
            }
        }

        inline bool VerifyKindUnionVector(
            flatbuffers::Verifier& verifier,
            const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
            const flatbuffers::Vector<uint8_t>* types) {
            if (!values || !types)
                return !values && !types;
            if (values->size() != types->size())
                return false;
            for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
                if (!VerifyKindUnion(verifier, values->Get(i), types->GetEnum<KindUnion>(i))) {
                    return false;
                }
            }
            return true;
        }

        inline void*
        KindUnionUnion::UnPack(const void* obj, KindUnion type, const flatbuffers::resolver_function_t* resolver) {
            switch (type) {
                case KindUnion::pg_gen_TextMatchesQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::TextMatchesQuery*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_TextContainsQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::TextContainsQuery*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_TextStartsWithQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::TextStartsWithQuery*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_TextEndsWithQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::TextEndsWithQuery*>(obj);
                    return ptr->UnPack(resolver);
                }
                default:
                    return nullptr;
            }
        }

        inline flatbuffers::Offset<void> KindUnionUnion::Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const flatbuffers::rehasher_function_t* _rehasher) const {
            switch (type) {
                case KindUnion::pg_gen_TextMatchesQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::TextMatchesQueryT*>(value);
                    return CreateTextMatchesQuery(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_TextContainsQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::TextContainsQueryT*>(value);
                    return CreateTextContainsQuery(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_TextStartsWithQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::TextStartsWithQueryT*>(value);
                    return CreateTextStartsWithQuery(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_TextEndsWithQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::TextEndsWithQueryT*>(value);
                    return CreateTextEndsWithQuery(_fbb, ptr, _rehasher).Union();
                }
                default:
                    return 0;
            }
        }

        inline KindUnionUnion::KindUnionUnion(const KindUnionUnion& u) : type(u.type), value(nullptr) {
            switch (type) {
                case KindUnion::pg_gen_TextMatchesQuery: {
                    value = new pg::gen::TextMatchesQueryT(*reinterpret_cast<pg::gen::TextMatchesQueryT*>(u.value));
                    break;
                }
                case KindUnion::pg_gen_TextContainsQuery: {
                    value = new pg::gen::TextContainsQueryT(*reinterpret_cast<pg::gen::TextContainsQueryT*>(u.value));
                    break;
                }
                case KindUnion::pg_gen_TextStartsWithQuery: {
                    value =
                        new pg::gen::TextStartsWithQueryT(*reinterpret_cast<pg::gen::TextStartsWithQueryT*>(u.value));
                    break;
                }
                case KindUnion::pg_gen_TextEndsWithQuery: {
                    value = new pg::gen::TextEndsWithQueryT(*reinterpret_cast<pg::gen::TextEndsWithQueryT*>(u.value));
                    break;
                }
                default:
                    break;
            }
        }

        inline void KindUnionUnion::Reset() {
            switch (type) {
                case KindUnion::pg_gen_TextMatchesQuery: {
                    auto ptr = reinterpret_cast<pg::gen::TextMatchesQueryT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_TextContainsQuery: {
                    auto ptr = reinterpret_cast<pg::gen::TextContainsQueryT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_TextStartsWithQuery: {
                    auto ptr = reinterpret_cast<pg::gen::TextStartsWithQueryT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_TextEndsWithQuery: {
                    auto ptr = reinterpret_cast<pg::gen::TextEndsWithQueryT*>(value);
                    delete ptr;
                    break;
                }
                default:
                    break;
            }
            value = nullptr;
            type = KindUnion::NONE;
        }

    }  // namespace TextSearchKind_

    namespace DateSearchKind_ {

        inline bool VerifyKindUnion(flatbuffers::Verifier& verifier, const void* obj, KindUnion type) {
            switch (type) {
                case KindUnion::NONE: {
                    return true;
                }
                case KindUnion::pg_gen_BeforeDateQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::BeforeDateQuery*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_AfterDateQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::AfterDateQuery*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_InDateRangeQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::InDateRangeQuery*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_NotInDateRangeQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::NotInDateRangeQuery*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                default:
                    return true;
            }
        }

        inline bool VerifyKindUnionVector(
            flatbuffers::Verifier& verifier,
            const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
            const flatbuffers::Vector<uint8_t>* types) {
            if (!values || !types)
                return !values && !types;
            if (values->size() != types->size())
                return false;
            for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
                if (!VerifyKindUnion(verifier, values->Get(i), types->GetEnum<KindUnion>(i))) {
                    return false;
                }
            }
            return true;
        }

        inline void*
        KindUnionUnion::UnPack(const void* obj, KindUnion type, const flatbuffers::resolver_function_t* resolver) {
            switch (type) {
                case KindUnion::pg_gen_BeforeDateQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::BeforeDateQuery*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_AfterDateQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::AfterDateQuery*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_InDateRangeQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::InDateRangeQuery*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_NotInDateRangeQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::NotInDateRangeQuery*>(obj);
                    return ptr->UnPack(resolver);
                }
                default:
                    return nullptr;
            }
        }

        inline flatbuffers::Offset<void> KindUnionUnion::Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const flatbuffers::rehasher_function_t* _rehasher) const {
            switch (type) {
                case KindUnion::pg_gen_BeforeDateQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::BeforeDateQueryT*>(value);
                    return CreateBeforeDateQuery(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_AfterDateQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::AfterDateQueryT*>(value);
                    return CreateAfterDateQuery(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_InDateRangeQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::InDateRangeQueryT*>(value);
                    return CreateInDateRangeQuery(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_NotInDateRangeQuery: {
                    auto ptr = reinterpret_cast<const pg::gen::NotInDateRangeQueryT*>(value);
                    return CreateNotInDateRangeQuery(_fbb, ptr, _rehasher).Union();
                }
                default:
                    return 0;
            }
        }

        inline KindUnionUnion::KindUnionUnion(const KindUnionUnion& u) : type(u.type), value(nullptr) {
            switch (type) {
                case KindUnion::pg_gen_BeforeDateQuery: {
                    FLATBUFFERS_ASSERT(false);  // pg::gen::BeforeDateQueryT not copyable.
                    break;
                }
                case KindUnion::pg_gen_AfterDateQuery: {
                    FLATBUFFERS_ASSERT(false);  // pg::gen::AfterDateQueryT not copyable.
                    break;
                }
                case KindUnion::pg_gen_InDateRangeQuery: {
                    FLATBUFFERS_ASSERT(false);  // pg::gen::InDateRangeQueryT not copyable.
                    break;
                }
                case KindUnion::pg_gen_NotInDateRangeQuery: {
                    FLATBUFFERS_ASSERT(false);  // pg::gen::NotInDateRangeQueryT not copyable.
                    break;
                }
                default:
                    break;
            }
        }

        inline void KindUnionUnion::Reset() {
            switch (type) {
                case KindUnion::pg_gen_BeforeDateQuery: {
                    auto ptr = reinterpret_cast<pg::gen::BeforeDateQueryT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_AfterDateQuery: {
                    auto ptr = reinterpret_cast<pg::gen::AfterDateQueryT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_InDateRangeQuery: {
                    auto ptr = reinterpret_cast<pg::gen::InDateRangeQueryT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_NotInDateRangeQuery: {
                    auto ptr = reinterpret_cast<pg::gen::NotInDateRangeQueryT*>(value);
                    delete ptr;
                    break;
                }
                default:
                    break;
            }
            value = nullptr;
            type = KindUnion::NONE;
        }

    }  // namespace DateSearchKind_

    namespace SearchNoteData_ {

        inline bool VerifyKindUnion(flatbuffers::Verifier& verifier, const void* obj, KindUnion type) {
            switch (type) {
                case KindUnion::NONE: {
                    return true;
                }
                case KindUnion::pg_gen_NoteTitleSearch: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteTitleSearch*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_NoteContentSearch: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteContentSearch*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_NoteTagSearch: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteTagSearch*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_NoteCreatedSearch: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteCreatedSearch*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case KindUnion::pg_gen_NoteUpdatedSearch: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteUpdatedSearch*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                default:
                    return true;
            }
        }

        inline bool VerifyKindUnionVector(
            flatbuffers::Verifier& verifier,
            const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
            const flatbuffers::Vector<uint8_t>* types) {
            if (!values || !types)
                return !values && !types;
            if (values->size() != types->size())
                return false;
            for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
                if (!VerifyKindUnion(verifier, values->Get(i), types->GetEnum<KindUnion>(i))) {
                    return false;
                }
            }
            return true;
        }

        inline void*
        KindUnionUnion::UnPack(const void* obj, KindUnion type, const flatbuffers::resolver_function_t* resolver) {
            switch (type) {
                case KindUnion::pg_gen_NoteTitleSearch: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteTitleSearch*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_NoteContentSearch: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteContentSearch*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_NoteTagSearch: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteTagSearch*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_NoteCreatedSearch: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteCreatedSearch*>(obj);
                    return ptr->UnPack(resolver);
                }
                case KindUnion::pg_gen_NoteUpdatedSearch: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteUpdatedSearch*>(obj);
                    return ptr->UnPack(resolver);
                }
                default:
                    return nullptr;
            }
        }

        inline flatbuffers::Offset<void> KindUnionUnion::Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const flatbuffers::rehasher_function_t* _rehasher) const {
            switch (type) {
                case KindUnion::pg_gen_NoteTitleSearch: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteTitleSearchT*>(value);
                    return CreateNoteTitleSearch(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_NoteContentSearch: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteContentSearchT*>(value);
                    return CreateNoteContentSearch(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_NoteTagSearch: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteTagSearchT*>(value);
                    return CreateNoteTagSearch(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_NoteCreatedSearch: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteCreatedSearchT*>(value);
                    return CreateNoteCreatedSearch(_fbb, ptr, _rehasher).Union();
                }
                case KindUnion::pg_gen_NoteUpdatedSearch: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteUpdatedSearchT*>(value);
                    return CreateNoteUpdatedSearch(_fbb, ptr, _rehasher).Union();
                }
                default:
                    return 0;
            }
        }

        inline KindUnionUnion::KindUnionUnion(const KindUnionUnion& u) : type(u.type), value(nullptr) {
            switch (type) {
                case KindUnion::pg_gen_NoteTitleSearch: {
                    FLATBUFFERS_ASSERT(false);  // pg::gen::NoteTitleSearchT not copyable.
                    break;
                }
                case KindUnion::pg_gen_NoteContentSearch: {
                    FLATBUFFERS_ASSERT(false);  // pg::gen::NoteContentSearchT not copyable.
                    break;
                }
                case KindUnion::pg_gen_NoteTagSearch: {
                    FLATBUFFERS_ASSERT(false);  // pg::gen::NoteTagSearchT not copyable.
                    break;
                }
                case KindUnion::pg_gen_NoteCreatedSearch: {
                    FLATBUFFERS_ASSERT(false);  // pg::gen::NoteCreatedSearchT not copyable.
                    break;
                }
                case KindUnion::pg_gen_NoteUpdatedSearch: {
                    FLATBUFFERS_ASSERT(false);  // pg::gen::NoteUpdatedSearchT not copyable.
                    break;
                }
                default:
                    break;
            }
        }

        inline void KindUnionUnion::Reset() {
            switch (type) {
                case KindUnion::pg_gen_NoteTitleSearch: {
                    auto ptr = reinterpret_cast<pg::gen::NoteTitleSearchT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_NoteContentSearch: {
                    auto ptr = reinterpret_cast<pg::gen::NoteContentSearchT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_NoteTagSearch: {
                    auto ptr = reinterpret_cast<pg::gen::NoteTagSearchT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_NoteCreatedSearch: {
                    auto ptr = reinterpret_cast<pg::gen::NoteCreatedSearchT*>(value);
                    delete ptr;
                    break;
                }
                case KindUnion::pg_gen_NoteUpdatedSearch: {
                    auto ptr = reinterpret_cast<pg::gen::NoteUpdatedSearchT*>(value);
                    delete ptr;
                    break;
                }
                default:
                    break;
            }
            value = nullptr;
            type = KindUnion::NONE;
        }

    }  // namespace SearchNoteData_

    namespace CreateNoteResponse_ {

        inline bool VerifyRespUnion(flatbuffers::Verifier& verifier, const void* obj, RespUnion type) {
            switch (type) {
                case RespUnion::NONE: {
                    return true;
                }
                case RespUnion::pg_gen_NoteObject: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteObject*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case RespUnion::pg_gen_ResponseError: {
                    auto ptr = reinterpret_cast<const pg::gen::ResponseError*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                default:
                    return true;
            }
        }

        inline bool VerifyRespUnionVector(
            flatbuffers::Verifier& verifier,
            const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
            const flatbuffers::Vector<uint8_t>* types) {
            if (!values || !types)
                return !values && !types;
            if (values->size() != types->size())
                return false;
            for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
                if (!VerifyRespUnion(verifier, values->Get(i), types->GetEnum<RespUnion>(i))) {
                    return false;
                }
            }
            return true;
        }

        inline void*
        RespUnionUnion::UnPack(const void* obj, RespUnion type, const flatbuffers::resolver_function_t* resolver) {
            switch (type) {
                case RespUnion::pg_gen_NoteObject: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteObject*>(obj);
                    return ptr->UnPack(resolver);
                }
                case RespUnion::pg_gen_ResponseError: {
                    auto ptr = reinterpret_cast<const pg::gen::ResponseError*>(obj);
                    return ptr->UnPack(resolver);
                }
                default:
                    return nullptr;
            }
        }

        inline flatbuffers::Offset<void> RespUnionUnion::Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const flatbuffers::rehasher_function_t* _rehasher) const {
            switch (type) {
                case RespUnion::pg_gen_NoteObject: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteObjectT*>(value);
                    return CreateNoteObject(_fbb, ptr, _rehasher).Union();
                }
                case RespUnion::pg_gen_ResponseError: {
                    auto ptr = reinterpret_cast<const pg::gen::ResponseErrorT*>(value);
                    return CreateResponseError(_fbb, ptr, _rehasher).Union();
                }
                default:
                    return 0;
            }
        }

        inline RespUnionUnion::RespUnionUnion(const RespUnionUnion& u) : type(u.type), value(nullptr) {
            switch (type) {
                case RespUnion::pg_gen_NoteObject: {
                    FLATBUFFERS_ASSERT(false);  // pg::gen::NoteObjectT not copyable.
                    break;
                }
                case RespUnion::pg_gen_ResponseError: {
                    value = new pg::gen::ResponseErrorT(*reinterpret_cast<pg::gen::ResponseErrorT*>(u.value));
                    break;
                }
                default:
                    break;
            }
        }

        inline void RespUnionUnion::Reset() {
            switch (type) {
                case RespUnion::pg_gen_NoteObject: {
                    auto ptr = reinterpret_cast<pg::gen::NoteObjectT*>(value);
                    delete ptr;
                    break;
                }
                case RespUnion::pg_gen_ResponseError: {
                    auto ptr = reinterpret_cast<pg::gen::ResponseErrorT*>(value);
                    delete ptr;
                    break;
                }
                default:
                    break;
            }
            value = nullptr;
            type = RespUnion::NONE;
        }

    }  // namespace CreateNoteResponse_

    namespace UpdateNoteResponse_ {

        inline bool VerifyRespUnion(flatbuffers::Verifier& verifier, const void* obj, RespUnion type) {
            switch (type) {
                case RespUnion::NONE: {
                    return true;
                }
                case RespUnion::pg_gen_NoteObject: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteObject*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case RespUnion::pg_gen_ResponseError: {
                    auto ptr = reinterpret_cast<const pg::gen::ResponseError*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                default:
                    return true;
            }
        }

        inline bool VerifyRespUnionVector(
            flatbuffers::Verifier& verifier,
            const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
            const flatbuffers::Vector<uint8_t>* types) {
            if (!values || !types)
                return !values && !types;
            if (values->size() != types->size())
                return false;
            for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
                if (!VerifyRespUnion(verifier, values->Get(i), types->GetEnum<RespUnion>(i))) {
                    return false;
                }
            }
            return true;
        }

        inline void*
        RespUnionUnion::UnPack(const void* obj, RespUnion type, const flatbuffers::resolver_function_t* resolver) {
            switch (type) {
                case RespUnion::pg_gen_NoteObject: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteObject*>(obj);
                    return ptr->UnPack(resolver);
                }
                case RespUnion::pg_gen_ResponseError: {
                    auto ptr = reinterpret_cast<const pg::gen::ResponseError*>(obj);
                    return ptr->UnPack(resolver);
                }
                default:
                    return nullptr;
            }
        }

        inline flatbuffers::Offset<void> RespUnionUnion::Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const flatbuffers::rehasher_function_t* _rehasher) const {
            switch (type) {
                case RespUnion::pg_gen_NoteObject: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteObjectT*>(value);
                    return CreateNoteObject(_fbb, ptr, _rehasher).Union();
                }
                case RespUnion::pg_gen_ResponseError: {
                    auto ptr = reinterpret_cast<const pg::gen::ResponseErrorT*>(value);
                    return CreateResponseError(_fbb, ptr, _rehasher).Union();
                }
                default:
                    return 0;
            }
        }

        inline RespUnionUnion::RespUnionUnion(const RespUnionUnion& u) : type(u.type), value(nullptr) {
            switch (type) {
                case RespUnion::pg_gen_NoteObject: {
                    FLATBUFFERS_ASSERT(false);  // pg::gen::NoteObjectT not copyable.
                    break;
                }
                case RespUnion::pg_gen_ResponseError: {
                    value = new pg::gen::ResponseErrorT(*reinterpret_cast<pg::gen::ResponseErrorT*>(u.value));
                    break;
                }
                default:
                    break;
            }
        }

        inline void RespUnionUnion::Reset() {
            switch (type) {
                case RespUnion::pg_gen_NoteObject: {
                    auto ptr = reinterpret_cast<pg::gen::NoteObjectT*>(value);
                    delete ptr;
                    break;
                }
                case RespUnion::pg_gen_ResponseError: {
                    auto ptr = reinterpret_cast<pg::gen::ResponseErrorT*>(value);
                    delete ptr;
                    break;
                }
                default:
                    break;
            }
            value = nullptr;
            type = RespUnion::NONE;
        }

    }  // namespace UpdateNoteResponse_

    namespace DeleteNoteResponse_ {

        inline bool VerifyRespUnion(flatbuffers::Verifier& verifier, const void* obj, RespUnion type) {
            switch (type) {
                case RespUnion::NONE: {
                    return true;
                }
                case RespUnion::pg_gen_Boolean: {
                    auto ptr = reinterpret_cast<const pg::gen::Boolean*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case RespUnion::pg_gen_ResponseError: {
                    auto ptr = reinterpret_cast<const pg::gen::ResponseError*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                default:
                    return true;
            }
        }

        inline bool VerifyRespUnionVector(
            flatbuffers::Verifier& verifier,
            const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
            const flatbuffers::Vector<uint8_t>* types) {
            if (!values || !types)
                return !values && !types;
            if (values->size() != types->size())
                return false;
            for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
                if (!VerifyRespUnion(verifier, values->Get(i), types->GetEnum<RespUnion>(i))) {
                    return false;
                }
            }
            return true;
        }

        inline void*
        RespUnionUnion::UnPack(const void* obj, RespUnion type, const flatbuffers::resolver_function_t* resolver) {
            switch (type) {
                case RespUnion::pg_gen_Boolean: {
                    auto ptr = reinterpret_cast<const pg::gen::Boolean*>(obj);
                    return ptr->UnPack(resolver);
                }
                case RespUnion::pg_gen_ResponseError: {
                    auto ptr = reinterpret_cast<const pg::gen::ResponseError*>(obj);
                    return ptr->UnPack(resolver);
                }
                default:
                    return nullptr;
            }
        }

        inline flatbuffers::Offset<void> RespUnionUnion::Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const flatbuffers::rehasher_function_t* _rehasher) const {
            switch (type) {
                case RespUnion::pg_gen_Boolean: {
                    auto ptr = reinterpret_cast<const pg::gen::BooleanT*>(value);
                    return CreateBoolean(_fbb, ptr, _rehasher).Union();
                }
                case RespUnion::pg_gen_ResponseError: {
                    auto ptr = reinterpret_cast<const pg::gen::ResponseErrorT*>(value);
                    return CreateResponseError(_fbb, ptr, _rehasher).Union();
                }
                default:
                    return 0;
            }
        }

        inline RespUnionUnion::RespUnionUnion(const RespUnionUnion& u) : type(u.type), value(nullptr) {
            switch (type) {
                case RespUnion::pg_gen_Boolean: {
                    value = new pg::gen::BooleanT(*reinterpret_cast<pg::gen::BooleanT*>(u.value));
                    break;
                }
                case RespUnion::pg_gen_ResponseError: {
                    value = new pg::gen::ResponseErrorT(*reinterpret_cast<pg::gen::ResponseErrorT*>(u.value));
                    break;
                }
                default:
                    break;
            }
        }

        inline void RespUnionUnion::Reset() {
            switch (type) {
                case RespUnion::pg_gen_Boolean: {
                    auto ptr = reinterpret_cast<pg::gen::BooleanT*>(value);
                    delete ptr;
                    break;
                }
                case RespUnion::pg_gen_ResponseError: {
                    auto ptr = reinterpret_cast<pg::gen::ResponseErrorT*>(value);
                    delete ptr;
                    break;
                }
                default:
                    break;
            }
            value = nullptr;
            type = RespUnion::NONE;
        }

    }  // namespace DeleteNoteResponse_

    namespace GetNoteResponse_ {

        inline bool VerifyRespUnion(flatbuffers::Verifier& verifier, const void* obj, RespUnion type) {
            switch (type) {
                case RespUnion::NONE: {
                    return true;
                }
                case RespUnion::pg_gen_NoteObject: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteObject*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                case RespUnion::pg_gen_ResponseError: {
                    auto ptr = reinterpret_cast<const pg::gen::ResponseError*>(obj);
                    return verifier.VerifyTable(ptr);
                }
                default:
                    return true;
            }
        }

        inline bool VerifyRespUnionVector(
            flatbuffers::Verifier& verifier,
            const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
            const flatbuffers::Vector<uint8_t>* types) {
            if (!values || !types)
                return !values && !types;
            if (values->size() != types->size())
                return false;
            for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
                if (!VerifyRespUnion(verifier, values->Get(i), types->GetEnum<RespUnion>(i))) {
                    return false;
                }
            }
            return true;
        }

        inline void*
        RespUnionUnion::UnPack(const void* obj, RespUnion type, const flatbuffers::resolver_function_t* resolver) {
            switch (type) {
                case RespUnion::pg_gen_NoteObject: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteObject*>(obj);
                    return ptr->UnPack(resolver);
                }
                case RespUnion::pg_gen_ResponseError: {
                    auto ptr = reinterpret_cast<const pg::gen::ResponseError*>(obj);
                    return ptr->UnPack(resolver);
                }
                default:
                    return nullptr;
            }
        }

        inline flatbuffers::Offset<void> RespUnionUnion::Pack(
            flatbuffers::FlatBufferBuilder& _fbb,
            const flatbuffers::rehasher_function_t* _rehasher) const {
            switch (type) {
                case RespUnion::pg_gen_NoteObject: {
                    auto ptr = reinterpret_cast<const pg::gen::NoteObjectT*>(value);
                    return CreateNoteObject(_fbb, ptr, _rehasher).Union();
                }
                case RespUnion::pg_gen_ResponseError: {
                    auto ptr = reinterpret_cast<const pg::gen::ResponseErrorT*>(value);
                    return CreateResponseError(_fbb, ptr, _rehasher).Union();
                }
                default:
                    return 0;
            }
        }

        inline RespUnionUnion::RespUnionUnion(const RespUnionUnion& u) : type(u.type), value(nullptr) {
            switch (type) {
                case RespUnion::pg_gen_NoteObject: {
                    FLATBUFFERS_ASSERT(false);  // pg::gen::NoteObjectT not copyable.
                    break;
                }
                case RespUnion::pg_gen_ResponseError: {
                    value = new pg::gen::ResponseErrorT(*reinterpret_cast<pg::gen::ResponseErrorT*>(u.value));
                    break;
                }
                default:
                    break;
            }
        }

        inline void RespUnionUnion::Reset() {
            switch (type) {
                case RespUnion::pg_gen_NoteObject: {
                    auto ptr = reinterpret_cast<pg::gen::NoteObjectT*>(value);
                    delete ptr;
                    break;
                }
                case RespUnion::pg_gen_ResponseError: {
                    auto ptr = reinterpret_cast<pg::gen::ResponseErrorT*>(value);
                    delete ptr;
                    break;
                }
                default:
                    break;
            }
            value = nullptr;
            type = RespUnion::NONE;
        }

    }  // namespace GetNoteResponse_

    namespace TextModificationKind_ {

        inline const flatbuffers::TypeTable* KindUnionTypeTable() {
            static const flatbuffers::TypeCode type_codes[] = {
                { flatbuffers::ET_SEQUENCE, 0, -1 }, { flatbuffers::ET_SEQUENCE, 0, 0 },
                { flatbuffers::ET_SEQUENCE, 0, 1 },  { flatbuffers::ET_SEQUENCE, 0, 2 },
                { flatbuffers::ET_SEQUENCE, 0, 3 },  { flatbuffers::ET_SEQUENCE, 0, 4 },
                { flatbuffers::ET_SEQUENCE, 0, 5 },  { flatbuffers::ET_SEQUENCE, 0, 6 },
                { flatbuffers::ET_SEQUENCE, 0, 7 }
            };
            static const flatbuffers::TypeFunction type_refs[] = {
                pg::gen::AppendTextOpTypeTable,  pg::gen::InsertTextOpTypeTable,
                pg::gen::PrependTextOpTypeTable, pg::gen::RemoveTextRangeOpTypeTable,
                pg::gen::ReplaceTextOpTypeTable, pg::gen::ReplaceTextMultipleOpTypeTable,
                pg::gen::RemoveTextOpTypeTable,  pg::gen::RemoveTextMultipleOpTypeTable
            };
            static const char* const names[] = { "NONE",
                                                 "pg_gen_AppendTextOp",
                                                 "pg_gen_InsertTextOp",
                                                 "pg_gen_PrependTextOp",
                                                 "pg_gen_RemoveTextRangeOp",
                                                 "pg_gen_ReplaceTextOp",
                                                 "pg_gen_ReplaceTextMultipleOp",
                                                 "pg_gen_RemoveTextOp",
                                                 "pg_gen_RemoveTextMultipleOp" };
            static const flatbuffers::TypeTable tt = {
                flatbuffers::ST_UNION, 9, type_codes, type_refs, nullptr, nullptr, names
            };
            return &tt;
        }

    }  // namespace TextModificationKind_

    namespace TextSearchKind_ {

        inline const flatbuffers::TypeTable* KindUnionTypeTable() {
            static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, -1 },
                                                                { flatbuffers::ET_SEQUENCE, 0, 0 },
                                                                { flatbuffers::ET_SEQUENCE, 0, 1 },
                                                                { flatbuffers::ET_SEQUENCE, 0, 2 },
                                                                { flatbuffers::ET_SEQUENCE, 0, 3 } };
            static const flatbuffers::TypeFunction type_refs[] = { pg::gen::TextMatchesQueryTypeTable,
                                                                   pg::gen::TextContainsQueryTypeTable,
                                                                   pg::gen::TextStartsWithQueryTypeTable,
                                                                   pg::gen::TextEndsWithQueryTypeTable };
            static const char* const names[] = { "NONE",
                                                 "pg_gen_TextMatchesQuery",
                                                 "pg_gen_TextContainsQuery",
                                                 "pg_gen_TextStartsWithQuery",
                                                 "pg_gen_TextEndsWithQuery" };
            static const flatbuffers::TypeTable tt = {
                flatbuffers::ST_UNION, 5, type_codes, type_refs, nullptr, nullptr, names
            };
            return &tt;
        }

    }  // namespace TextSearchKind_

    namespace DateSearchKind_ {

        inline const flatbuffers::TypeTable* KindUnionTypeTable() {
            static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, -1 },
                                                                { flatbuffers::ET_SEQUENCE, 0, 0 },
                                                                { flatbuffers::ET_SEQUENCE, 0, 1 },
                                                                { flatbuffers::ET_SEQUENCE, 0, 2 },
                                                                { flatbuffers::ET_SEQUENCE, 0, 3 } };
            static const flatbuffers::TypeFunction type_refs[] = { pg::gen::BeforeDateQueryTypeTable,
                                                                   pg::gen::AfterDateQueryTypeTable,
                                                                   pg::gen::InDateRangeQueryTypeTable,
                                                                   pg::gen::NotInDateRangeQueryTypeTable };
            static const char* const names[] = { "NONE",
                                                 "pg_gen_BeforeDateQuery",
                                                 "pg_gen_AfterDateQuery",
                                                 "pg_gen_InDateRangeQuery",
                                                 "pg_gen_NotInDateRangeQuery" };
            static const flatbuffers::TypeTable tt = {
                flatbuffers::ST_UNION, 5, type_codes, type_refs, nullptr, nullptr, names
            };
            return &tt;
        }

    }  // namespace DateSearchKind_

    namespace SearchNoteData_ {

        inline const flatbuffers::TypeTable* KindUnionTypeTable() {
            static const flatbuffers::TypeCode type_codes[] = {
                { flatbuffers::ET_SEQUENCE, 0, -1 }, { flatbuffers::ET_SEQUENCE, 0, 0 },
                { flatbuffers::ET_SEQUENCE, 0, 1 },  { flatbuffers::ET_SEQUENCE, 0, 2 },
                { flatbuffers::ET_SEQUENCE, 0, 3 },  { flatbuffers::ET_SEQUENCE, 0, 4 }
            };
            static const flatbuffers::TypeFunction type_refs[] = { pg::gen::NoteTitleSearchTypeTable,
                                                                   pg::gen::NoteContentSearchTypeTable,
                                                                   pg::gen::NoteTagSearchTypeTable,
                                                                   pg::gen::NoteCreatedSearchTypeTable,
                                                                   pg::gen::NoteUpdatedSearchTypeTable };
            static const char* const names[] = { "NONE",
                                                 "pg_gen_NoteTitleSearch",
                                                 "pg_gen_NoteContentSearch",
                                                 "pg_gen_NoteTagSearch",
                                                 "pg_gen_NoteCreatedSearch",
                                                 "pg_gen_NoteUpdatedSearch" };
            static const flatbuffers::TypeTable tt = {
                flatbuffers::ST_UNION, 6, type_codes, type_refs, nullptr, nullptr, names
            };
            return &tt;
        }

    }  // namespace SearchNoteData_

    namespace CreateNoteResponse_ {

        inline const flatbuffers::TypeTable* RespUnionTypeTable() {
            static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, -1 },
                                                                { flatbuffers::ET_SEQUENCE, 0, 0 },
                                                                { flatbuffers::ET_SEQUENCE, 0, 1 } };
            static const flatbuffers::TypeFunction type_refs[] = { pg::gen::NoteObjectTypeTable,
                                                                   pg::gen::ResponseErrorTypeTable };
            static const char* const names[] = { "NONE", "pg_gen_NoteObject", "pg_gen_ResponseError" };
            static const flatbuffers::TypeTable tt = {
                flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, nullptr, names
            };
            return &tt;
        }

    }  // namespace CreateNoteResponse_

    namespace UpdateNoteResponse_ {

        inline const flatbuffers::TypeTable* RespUnionTypeTable() {
            static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, -1 },
                                                                { flatbuffers::ET_SEQUENCE, 0, 0 },
                                                                { flatbuffers::ET_SEQUENCE, 0, 1 } };
            static const flatbuffers::TypeFunction type_refs[] = { pg::gen::NoteObjectTypeTable,
                                                                   pg::gen::ResponseErrorTypeTable };
            static const char* const names[] = { "NONE", "pg_gen_NoteObject", "pg_gen_ResponseError" };
            static const flatbuffers::TypeTable tt = {
                flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, nullptr, names
            };
            return &tt;
        }

    }  // namespace UpdateNoteResponse_

    namespace DeleteNoteResponse_ {

        inline const flatbuffers::TypeTable* RespUnionTypeTable() {
            static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, -1 },
                                                                { flatbuffers::ET_SEQUENCE, 0, 0 },
                                                                { flatbuffers::ET_SEQUENCE, 0, 1 } };
            static const flatbuffers::TypeFunction type_refs[] = { pg::gen::BooleanTypeTable,
                                                                   pg::gen::ResponseErrorTypeTable };
            static const char* const names[] = { "NONE", "pg_gen_Boolean", "pg_gen_ResponseError" };
            static const flatbuffers::TypeTable tt = {
                flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, nullptr, names
            };
            return &tt;
        }

    }  // namespace DeleteNoteResponse_

    namespace GetNoteResponse_ {

        inline const flatbuffers::TypeTable* RespUnionTypeTable() {
            static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, -1 },
                                                                { flatbuffers::ET_SEQUENCE, 0, 0 },
                                                                { flatbuffers::ET_SEQUENCE, 0, 1 } };
            static const flatbuffers::TypeFunction type_refs[] = { pg::gen::NoteObjectTypeTable,
                                                                   pg::gen::ResponseErrorTypeTable };
            static const char* const names[] = { "NONE", "pg_gen_NoteObject", "pg_gen_ResponseError" };
            static const flatbuffers::TypeTable tt = {
                flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, nullptr, names
            };
            return &tt;
        }

    }  // namespace GetNoteResponse_

    inline const flatbuffers::TypeTable* TimestampTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_LONG, 0, -1 },
                                                            { flatbuffers::ET_INT, 0, -1 } };
        static const char* const names[] = { "seconds", "nanos" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* ResponseErrorTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_UINT, 0, -1 },
                                                            { flatbuffers::ET_STRING, 0, -1 } };
        static const char* const names[] = { "code", "message" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* ReplaceTextPairTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_STRING, 0, -1 },
                                                            { flatbuffers::ET_STRING, 0, -1 } };
        static const char* const names[] = { "search", "replace" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* AppendTextOpTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_STRING, 0, -1 } };
        static const char* const names[] = { "text" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* InsertTextOpTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_STRING, 0, -1 },
                                                            { flatbuffers::ET_UINT, 0, -1 } };
        static const char* const names[] = { "text", "position" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* PrependTextOpTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_STRING, 0, -1 } };
        static const char* const names[] = { "text" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* RemoveTextRangeOpTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_UINT, 0, -1 },
                                                            { flatbuffers::ET_UINT, 0, -1 } };
        static const char* const names[] = { "start", "end" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* ReplaceTextOpTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::ReplaceTextPairTypeTable };
        static const char* const names[] = { "input" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* ReplaceTextMultipleOpTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 1, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::ReplaceTextPairTypeTable };
        static const char* const names[] = { "pairs" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* RemoveTextOpTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_STRING, 0, -1 } };
        static const char* const names[] = { "removal" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* RemoveTextMultipleOpTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_STRING, 1, -1 } };
        static const char* const names[] = { "removals" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* TextModificationKindTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_UTYPE, 0, 0 },
                                                            { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::TextModificationKind_::KindUnionTypeTable };
        static const char* const names[] = { "kind_type", "kind" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* TextMatchesQueryTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_STRING, 0, -1 },
                                                            { flatbuffers::ET_BOOL, 0, -1 } };
        static const char* const names[] = { "text", "case_sensitive" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* TextContainsQueryTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_STRING, 0, -1 },
                                                            { flatbuffers::ET_BOOL, 0, -1 } };
        static const char* const names[] = { "text", "case_sensitive" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* TextStartsWithQueryTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_STRING, 0, -1 },
                                                            { flatbuffers::ET_BOOL, 0, -1 } };
        static const char* const names[] = { "text", "case_sensitive" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* TextEndsWithQueryTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_STRING, 0, -1 },
                                                            { flatbuffers::ET_BOOL, 0, -1 } };
        static const char* const names[] = { "text", "case_sensitive" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* TextSearchKindTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_UTYPE, 0, 0 },
                                                            { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::TextSearchKind_::KindUnionTypeTable };
        static const char* const names[] = { "kind_type", "kind" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* BeforeDateQueryTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::TimestampTypeTable };
        static const char* const names[] = { "date" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* AfterDateQueryTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::TimestampTypeTable };
        static const char* const names[] = { "date" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* InDateRangeQueryTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, 0 },
                                                            { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::TimestampTypeTable };
        static const char* const names[] = { "start", "end" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* NotInDateRangeQueryTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, 0 },
                                                            { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::TimestampTypeTable };
        static const char* const names[] = { "start", "end" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* DateSearchKindTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_UTYPE, 0, 0 },
                                                            { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::DateSearchKind_::KindUnionTypeTable };
        static const char* const names[] = { "kind_type", "kind" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* NoteTitleSearchTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::TextSearchKindTypeTable };
        static const char* const names[] = { "title_search" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* NoteContentSearchTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::TextSearchKindTypeTable };
        static const char* const names[] = { "content_search" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* NoteTagSearchTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::TextSearchKindTypeTable };
        static const char* const names[] = { "tag_search" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* NoteCreatedSearchTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::DateSearchKindTypeTable };
        static const char* const names[] = { "created_search" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* NoteUpdatedSearchTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::DateSearchKindTypeTable };
        static const char* const names[] = { "updated_search" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* SearchNoteDataTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_UTYPE, 0, 0 },
                                                            { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::SearchNoteData_::KindUnionTypeTable };
        static const char* const names[] = { "kind_type", "kind" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* SearchNoteRequestTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 1, 0 },
                                                            { flatbuffers::ET_UINT, 0, -1 },
                                                            { flatbuffers::ET_STRING, 0, -1 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::SearchNoteDataTypeTable };
        static const char* const names[] = { "searches", "page_size", "page_token" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* SearchNoteResponseTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 1, 0 },
                                                            { flatbuffers::ET_STRING, 0, -1 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::NoteObjectTypeTable };
        static const char* const names[] = { "notes", "next_page_token" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* CreateNoteDataTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_STRING, 0, -1 },
                                                            { flatbuffers::ET_STRING, 0, -1 },
                                                            { flatbuffers::ET_STRING, 1, -1 } };
        static const char* const names[] = { "title", "content", "tags" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* CreateNoteRequestTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_STRING, 0, -1 },
                                                            { flatbuffers::ET_SEQUENCE, 0, 0 },
                                                            { flatbuffers::ET_STRING, 0, -1 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::CreateNoteDataTypeTable };
        static const char* const names[] = { "parent", "note", "id" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* CreateNoteResponseTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_UTYPE, 0, 0 },
                                                            { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::CreateNoteResponse_::RespUnionTypeTable };
        static const char* const names[] = { "resp_type", "resp" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* UpdateNoteDataTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_STRING, 0, -1 },
                                                            { flatbuffers::ET_SEQUENCE, 1, 0 },
                                                            { flatbuffers::ET_SEQUENCE, 1, 0 },
                                                            { flatbuffers::ET_SEQUENCE, 1, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::TextModificationKindTypeTable };
        static const char* const names[] = { "id", "title_mods", "content_mods", "tag_mods" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* UpdateNoteRequestTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::UpdateNoteDataTypeTable };
        static const char* const names[] = { "target" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* UpdateNoteResponseTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_UTYPE, 0, 0 },
                                                            { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::UpdateNoteResponse_::RespUnionTypeTable };
        static const char* const names[] = { "resp_type", "resp" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* UpdateNotesRequestTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 1, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::UpdateNoteDataTypeTable };
        static const char* const names[] = { "targets" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* UpdateNotesResponseTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_UINT, 0, -1 },
                                                            { flatbuffers::ET_UINT, 0, -1 },
                                                            { flatbuffers::ET_SEQUENCE, 1, 0 },
                                                            { flatbuffers::ET_SEQUENCE, 1, 1 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::NoteObjectTypeTable,
                                                               pg::gen::ResponseErrorTypeTable };
        static const char* const names[] = { "updated_count", "error_count", "updated", "errors" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* DeleteNoteDataTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_STRING, 0, -1 } };
        static const char* const names[] = { "id" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* DeleteNoteRequestTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::DeleteNoteDataTypeTable };
        static const char* const names[] = { "target" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* BooleanTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_BOOL, 0, -1 } };
        static const char* const names[] = { "value" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* DeleteNoteResponseTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_UTYPE, 0, 0 },
                                                            { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::DeleteNoteResponse_::RespUnionTypeTable };
        static const char* const names[] = { "resp_type", "resp" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* DeleteNotesRequestTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 1, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::DeleteNoteDataTypeTable };
        static const char* const names[] = { "targets" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* DeleteNotesResponseTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_UINT, 0, -1 },
                                                            { flatbuffers::ET_SEQUENCE, 1, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::ResponseErrorTypeTable };
        static const char* const names[] = { "deleted_count", "errors" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* ListNotesRequestTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_INT, 0, -1 },
                                                            { flatbuffers::ET_STRING, 0, -1 } };
        static const char* const names[] = { "page_size", "page_token" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* ListNotesResponseTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 1, 0 },
                                                            { flatbuffers::ET_STRING, 0, -1 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::NoteObjectTypeTable };
        static const char* const names[] = { "notes", "next_page_token" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* GetNoteRequestTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_STRING, 0, -1 } };
        static const char* const names[] = { "id" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* GetNoteResponseTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_UTYPE, 0, 0 },
                                                            { flatbuffers::ET_SEQUENCE, 0, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::GetNoteResponse_::RespUnionTypeTable };
        static const char* const names[] = { "resp_type", "resp" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* NoteObjectTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = {
            { flatbuffers::ET_STRING, 0, -1 }, { flatbuffers::ET_STRING, 0, -1 },  { flatbuffers::ET_STRING, 0, -1 },
            { flatbuffers::ET_STRING, 1, -1 }, { flatbuffers::ET_SEQUENCE, 0, 0 }, { flatbuffers::ET_SEQUENCE, 0, 0 }
        };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::TimestampTypeTable };
        static const char* const names[] = { "id", "title", "content", "tags", "created", "updated" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

    inline const flatbuffers::TypeTable* NoteStorageTypeTable() {
        static const flatbuffers::TypeCode type_codes[] = { { flatbuffers::ET_SEQUENCE, 1, 0 } };
        static const flatbuffers::TypeFunction type_refs[] = { pg::gen::NoteObjectTypeTable };
        static const char* const names[] = { "notes" };
        static const flatbuffers::TypeTable tt = {
            flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
        };
        return &tt;
    }

}  // namespace gen
}  // namespace pg

#endif  // FLATBUFFERS_GENERATED_NOTE_PG_GEN_H_
